<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="内存管理  虚拟内存," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="内存管理转载一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。原文
This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.If you missed th">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc">
<meta property="og:url" content="http://yoursite.com/2017/09/20/malloc/index.html">
<meta property="og:site_name" content="知而智">
<meta property="og:description" content="内存管理转载一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。原文
This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.If you missed th">
<meta property="og:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/htvm3.png">
<meta property="og:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-before.png">
<meta property="og:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-after.png">
<meta property="og:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/0x10-malloc.png">
<meta property="og:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/malloc-chunk.png">
<meta property="og:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/virtual_memory_diagram_v2.png">
<meta property="og:image" content="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg">
<meta property="og:image" content="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/diggit.png">
<meta property="og:image" content="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/stumbleupon.png">
<meta property="og:updated_time" content="2017-10-10T05:02:10.261Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="malloc">
<meta name="twitter:description" content="内存管理转载一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。原文
This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.If you missed th">
<meta name="twitter:image" content="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/htvm3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/20/malloc/"/>





  <title>malloc | 知而智</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <!-- <div class="headband"></div> -->

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">知而智</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>


<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">malloc</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T13:35:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="内存管理转载"><a href="#内存管理转载" class="headerlink" title="内存管理转载"></a>内存管理转载</h3><p>一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。<br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">原文</a></p>
<div class="entry-content"><br><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/htvm3.png" alt="Hack the VM!" scale="0"></p><br><p>This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.</p><br><p>If you missed the previous chapters, you should probably start there:</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br></ul><br><h2>The heap</h2><br><p>In this chapter we will look at the heap and <code>malloc</code> in order to answer some of the questions we ended with at the end of the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>:</p><br><ul><br><li>Why doesn’t our allocated memory start at the very beginning of the heap (0x2050010 vs 02050000)? What are those first 16 bytes used for?</li><br><li>Is the heap actually growing upwards?</li><br></ul><br><h2>Prerequisites</h2><br><p>In order to fully understand this article, you will need to know:</p><br><ul><br><li>The basics of the C programming language (especially pointers)</li><br><li>The very basics of the Linux filesystem and the shell</li><br><li>We will also use the <code>/proc/[pid]/maps</code> file (see <code>man proc</code> or read our first article <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory, chapter 0: C strings &amp; /proc</a>)</li><br></ul><br><h2>Environment</h2><br><p>All scripts and programs have been tested on the following system:</p><br><ul><br><li>Ubuntu<br><ul><br><li>Linux ubuntu 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</li><br></ul><br></li><br></ul><br><p>Tools used:</p><br><ul><br><li>gcc<br><ul><br><li>gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4</li><br></ul><br></li><br><li>glibc 2.19 (see <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break/version.c" target="_blank" rel="external">version.c</a> if you need to check your glibc version)</li><br><li>strace<br><ul><br><li>strace — version 4.8</li><br></ul><br></li><br></ul><br><p><strong>Everything we will write will be true for this system/environment, but may be different on another system</strong></p><br><p>We will also go through the Linux source code. If you are on Ubuntu, you can download the sources of your current kernel by running this command:</p><br><pre><code>apt-get source linux-image-$(uname -r)<br></code></pre><br><h2><code>malloc</code></h2><br><p><code>malloc</code> is the common function used to dynamically allocate memory. This memory is allocated on the “heap”.<br><br><em>Note: <code>malloc</code> is not a system call.</em></p><br><p>From <code>man malloc</code>:</p><br><pre><code>[…] allocate dynamic memory[…]<br>void <em>malloc(size_t size);<br>[…]<br>The malloc() function allocates size bytes and returns a pointer to the allocated memory.<br></em></code></pre><br><h3>No malloc, no [heap]</h3><br><p>Let’s look at memory regions of a process that does not call <code>malloc</code> (<code>0-main.c</code>).</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <stdio.h>;<br><br>/**
  main - do nothing<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br><br></em></stdio.h></stdlib.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 0-main.c -o 0<br>julien@holberton:~/holberton/w/hackthevm3$ ./0<br><br></code></pre><br><p><em>Quick reminder (1/3): the memory regions of a process are listed in the <code>/proc/[pid]/maps</code> file. As a result, we first need to know the PID of the process. That is done using the <code>ps</code> command; the second column of <code>ps aux</code> output will give us the PID of the process. Please read <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">chapter 0</a> to learn more.</em></p><br><pre><code>julien@holberton:/tmp$ ps aux | grep \ ./0$<br>julien     3638  0.0  0.0   4200   648 pts/9    S+   12:01   0:00 ./0<br></code></pre><br><p><em>Quick reminder (2/3): from the above output, we can see that the PID of the process we want to look at is <code>3638</code>. As a result, the <code>maps</code> file will be found in the directory <code>/proc/3638</code>.</em></p><br><pre><code>julien@holberton:/tmp$ cd /proc/3638<br></code></pre><br><p><em>Quick reminder (3/3): The <code>maps</code> file contains the memory regions of the process. The format of each line in this file is:<br><br>address           perms offset  dev   inode       pathname</em></p><br><pre><code>julien@holberton:/proc/3638$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00600000-00601000 r–p 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00601000-00602000 rw-p 00001000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>7f38f87d7000-7f38f8991000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8991000-7f38f8b91000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b91000-7f38f8b95000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b95000-7f38f8b97000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b97000-7f38f8b9c000 rw-p 00000000 00:00 0<br>7f38f8b9c000-7f38f8bbf000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8da3000-7f38f8da6000 rw-p 00000000 00:00 0<br>7f38f8dbb000-7f38f8dbe000 rw-p 00000000 00:00 0<br>7f38f8dbe000-7f38f8dbf000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dbf000-7f38f8dc0000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dc0000-7f38f8dc1000 rw-p 00000000 00:00 0<br>7ffdd85c5000-7ffdd85e6000 rw-p 00000000 00:00 0                          [stack]<br>7ffdd85f2000-7ffdd85f4000 r–p 00000000 00:00 0                          [vvar]<br>7ffdd85f4000-7ffdd85f6000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/3638$<br></code></pre><br><p><em>Note: <code>hackthevm3</code> is a symbolic link to <code>hack_the_virtual_memory/03. The Heap/</code></em></p><br><p>-&gt;; As we can see from the above maps file, there’s no [heap] region allocated.</p><br><h3><code>malloc(x)</code></h3><br><p>Let’s do the same but with a program that calls <code>malloc</code> (<code>1-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - 1 call to malloc<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    malloc(1);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 1-main.c -o 1<br>julien@holberton:~/holberton/w/hackthevm3$ ./1<br><br></code></pre><br><pre><code>julien@holberton:/proc/3638$ ps aux | grep \ ./1$<br>julien     3718  0.0  0.0   4332   660 pts/9    S+   12:09   0:00 ./1<br>julien@holberton:/proc/3638$ cd /proc/3718<br>julien@holberton:/proc/3718$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00600000-00601000 r–p 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00601000-00602000 rw-p 00001000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>01195000-011b6000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3718$<br></code></pre><br><p>-&gt;; the [heap] is here.</p><br><p>Let’s check the return value of <code>malloc</code> to make sure the returned address is in the heap region (<code>2-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - prints the malloc returned address<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br><br>    p = malloc(1);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 2-main.c -o 2<br>julien@holberton:~/holberton/w/hackthevm3$ ./2<br>0x24d6010<br><br></code></pre><br><pre><code>julien@holberton:/proc/3718$ ps aux | grep \ ./2$<br>julien     3834  0.0  0.0   4336   676 pts/9    S+   12:48   0:00 ./2<br>julien@holberton:/proc/3718$ cd /proc/3834<br>julien@holberton:/proc/3834$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00600000-00601000 r–p 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00601000-00602000 rw-p 00001000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>024d6000-024f7000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3834$<br></code></pre><br><p>-&gt;; <code>024d6000</code> &lt;<code>0x24d6010</code> &lt; <code>024f7000</code></p><br><p>The returned address is inside the heap region. And as we have seen in the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>, the returned address does not start exactly at the beginning of the region; we’ll see why later.</p><br><h2><code>strace</code>, <code>brk</code> and <code>sbrk</code></h2><br><p><code>malloc</code> is a “regular” function (as opposed to a system call), so it must call some kind of syscall in order to manipulate the heap. Let’s use <code>strace</code> to find out.</p><br><p><code>strace</code> is a program used to trace system calls and signals. Any program will always use a few syscalls before your <code>main</code> function is executed. In order to know which syscalls are used by <code>malloc</code>, we will add a <code>write</code> syscall before and after the call to <code>malloc</code>(<code>3-main.c</code>).</p><br><pre><code>#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> main - let’s find out which syscall malloc is using
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC\n”, 14);<br>    p = malloc(1);<br>    write(1, “AFTER MALLOC\n”, 13);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></strong></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 3-main.c -o 3<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./3<br>execve(“./3”, [“./3”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC\n”, 14BEFORE MALLOC<br>)         = 14<br>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br>write(1, “AFTER MALLOC\n”, 13AFTER MALLOC<br>)          = 13<br>…<br>read(0,<br></em></code></pre><br><p>From the above listing we can focus on this:</p><br><pre><code>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br></code></pre><br><p>-&gt;; <code>malloc</code> is using the <code>brk</code> system call in order to manipulate the heap. From <code>brk</code> man page (<code>man brk</code>), we can see what this system call is doing:</p><br><pre><code>…<br>       int brk(void addr);<br>       void *sbrk(intptr_t increment);<br>…<br>DESCRIPTION<br>       brk() and sbrk() change the location of the program  break,  which  defines<br>       the end of the process’s data segment (i.e., the program break is the first<br>       location after the end of the uninitialized data segment).  Increasing  the<br>       program  break has the effect of allocating memory to the process; decreas‐<br>       ing the break deallocates memory.<br><br>       brk() sets the end of the data segment to the value specified by addr, when<br>       that  value  is  reasonable,  the system has enough memory, and the process<br>       does not exceed its maximum data size (see setrlimit(2)).<br><br>       sbrk() increments the program’s data space  by  increment  bytes.   Calling<br>       sbrk()  with  an increment of 0 can be used to find the current location of<br>       the program break.<br></code></pre><br><p>The program break is the address of the first location beyond the current end of the data region of the program in the virual memory.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-before.png" alt="program break before the call to malloc / brk" scale="0"></p><br><p>By increasing the value of the program break, via <code>brk</code> or <code>sbrk</code>, the function <code>malloc</code> creates a new space that can then be used by the process to dynamically allocate memory (using <code>malloc</code>).</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-after.png" alt="program break after the malloc / brk call" scale="0"></p><br><p>So the heap is actually an extension of the data segment of the program.</p><br><p>The first call to <code>brk</code> (<code>brk(0)</code>) returns the current address of the program break to <code>malloc</code>. And the second call is the one that actually creates new memory (since <code>0xe91000</code> &gt;; <code>0xe70000</code>) by increasing the value of the program break. In the above example, the heap is now starting at <code>0xe70000</code> and ends at <code>0xe91000</code>. Let’s double check with the <code>/proc/[PID]/maps</code> file:</p><br><pre><code>julien@holberton:/proc/3855$ ps aux | grep \ ./3$<br>julien     4011  0.0  0.0   4748   708 pts/9    S+   13:04   0:00 strace ./3<br>julien     4014  0.0  0.0   4336   644 pts/9    S+   13:04   0:00 ./3<br>julien@holberton:/proc/3855$ cd /proc/4014<br>julien@holberton:/proc/4014$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00600000-00601000 r–p 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00601000-00602000 rw-p 00001000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/4014$<br></code></pre><br><p>-&gt;; <code>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]</code> matches the pointers returned back to <code>malloc</code> by <code>brk</code>.</p><br><p>That’s great, but wait, why did<code>malloc</code> increment the heap by <code>00e91000</code> – <code>00e70000</code> = <code>0x21000</code> or <code>135168</code> bytes, when we only asked for only 1 byte?</p><br><h2>Many mallocs</h2><br><p>What will happen if we call <code>malloc</code> several times? (<code>4-main.c</code>)</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<br> <em> main - many calls to malloc
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC #0\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #0\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #1\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #1\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #2\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #2\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #3\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #3\n”, 16);<br>    printf(“%p\n”, p);<br><br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 4-main.c -o 4<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./4<br>execve(“./4”, [“./4”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC #0\n”, 17BEFORE MALLOC #0<br>)      = 17<br>brk(0)                                  = 0x1314000<br>brk(0x1335000)                          = 0x1335000<br>write(1, “AFTER MALLOC #0\n”, 16AFTER MALLOC #0<br>)       = 16<br>…<br>write(1, “0x1314010\n”, 100x1314010<br>)             = 10<br>write(1, “BEFORE MALLOC #1\n”, 17BEFORE MALLOC #1<br>)      = 17<br>write(1, “AFTER MALLOC #1\n”, 16AFTER MALLOC #1<br>)       = 16<br>write(1, “0x1314420\n”, 100x1314420<br>)             = 10<br>write(1, “BEFORE MALLOC #2\n”, 17BEFORE MALLOC #2<br>)      = 17<br>write(1, “AFTER MALLOC #2\n”, 16AFTER MALLOC #2<br>)       = 16<br>write(1, “0x1314830\n”, 100x1314830<br>)             = 10<br>write(1, “BEFORE MALLOC #3\n”, 17BEFORE MALLOC #3<br>)      = 17<br>write(1, “AFTER MALLOC #3\n”, 16AFTER MALLOC #3<br>)       = 16<br>write(1, “0x1314c40\n”, 100x1314c40<br>)             = 10<br>…<br>read(0,<br></em></code></pre><br><p>-&gt;; <code>malloc</code> is NOT calling <code>brk</code> each time we call it.</p><br><p>The first time, <code>malloc</code> creates a new space (the heap) for the program (by increasing the program break location). The following times, <code>malloc</code> uses the same space to give our program “new” chunks of memory. Those “new” chunks of memory are part of the memory previously allocated using <code>brk</code>. This way, <code>malloc</code> doesn’t have to use syscalls (<code>brk</code>) every time we call it, and thus it makes <code>malloc</code> – and our programs using <code>malloc</code> – faster. It also allows <code>malloc</code> and <code>free</code> to optimize the usage of the memory.</p><br><p>Let’s double check that we have only one heap, allocated by the first call to <code>brk</code>:</p><br><pre><code>julien@holberton:/proc/4014$ ps aux | grep \ ./4$<br>julien     4169  0.0  0.0   4748   688 pts/9    S+   13:33   0:00 strace ./4<br>julien     4172  0.0  0.0   4336   656 pts/9    S+   13:33   0:00 ./4<br>julien@holberton:/proc/4014$ cd /proc/4172<br>julien@holberton:/proc/4172$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00600000-00601000 r–p 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00601000-00602000 rw-p 00001000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>01314000-01335000 rw-p 00000000 00:00 0                                  [heap]<br>7f4a3f2c4000-7f4a3f47e000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f47e000-7f4a3f67e000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f67e000-7f4a3f682000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f682000-7f4a3f684000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f684000-7f4a3f689000 rw-p 00000000 00:00 0<br>7f4a3f689000-7f4a3f6ac000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f890000-7f4a3f893000 rw-p 00000000 00:00 0<br>7f4a3f8a7000-7f4a3f8ab000 rw-p 00000000 00:00 0<br>7f4a3f8ab000-7f4a3f8ac000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ac000-7f4a3f8ad000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ad000-7f4a3f8ae000 rw-p 00000000 00:00 0<br>7ffd1ba73000-7ffd1ba94000 rw-p 00000000 00:00 0                          [stack]<br>7ffd1bbed000-7ffd1bbef000 r–p 00000000 00:00 0                          [vvar]<br>7ffd1bbef000-7ffd1bbf1000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/4172$<br></code></pre><br><p>-&gt;; We have only one [heap] and the addresses match those returned by <code>sbrk</code>: <code>0x1314000</code> &amp; <code>0x1335000</code></p><br><h2>Naive malloc</h2><br><p>Based on the above, and assuming we won’t ever need to free anything, we can now write our own (naive) version of <code>malloc</code>, that would move the program break each time it is called.</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  malloc - naive version of malloc: dynamically allocates memory on the heap using sbrk<br> <em> @size: number of bytes to allocate                                                          
 </em><br> <em> Return: the memory address newly allocated, or NULL on error                                
 </em><br> <em> Note: don’t do this at home :)                                                              
 </em>/<br>void <em>malloc(size_t size)<br>{<br>    void </em>previous_break;<br><br>    previous_break = sbrk(size);<br>    /<em> check for error </em>/<br>    if (previous_break == (void <em>) -1)<br>    {<br>        /</em> on error malloc returns NULL <em>/<br>        return (NULL);<br>    }<br>    return (previous_break);<br>}<br></em></unistd.h></stdlib.h></code></pre><br><h2>The 0x10 lost bytes</h2><br><p>If we look at the output of the previous program (<code>4-main.c</code>), we can see that the first memory address returned by <code>malloc</code> doesn’t start at the beginning of the heap, but <code>0x10</code> bytes after: <code>0x1314010</code> vs <code>0x1314000</code>. Also, when we call <code>malloc(1024)</code> a second time, the address should be <code>0x1314010</code> (the returned value of the first call to <code>malloc</code>) + <code>1024</code> (or <code>0x400</code> in hexadecimal, since the first call to <code>malloc</code> was asking for <code>1024</code> bytes) = <code>0x1318010</code>. But the return value of the second call to <code>malloc</code> is <code>0x1314420</code>. We have lost <code>0x10</code> bytes again! Same goes for the subsequent calls.</p><br><p>Let’s look at what we can find inside those “lost” <code>0x10</code>-byte memory spaces (<code>5-main.c</code>) and whether the memory loss stays constant:</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  pmem - print mem<br> <em> @p: memory address to start printing from                                                   
 </em> @bytes: number of bytes to print<br> <em>                                                                                             
 </em> Return: nothing<br> <em>/<br>void pmem(void </em>p, unsigned int bytes)<br>{<br>    unsigned char <em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char </em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, <em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/**
 </em> main - the 0x10 lost bytes<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br>    int i;<br><br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1));<br>        printf(“%p\n”, p);<br>        printf(“bytes at %p:\n”, (void </em>)((char <em>)p - 0x10));<br>        pmem((char </em>)p - 0x10, 0x10);<br>    }<br>    return (EXIT_SUCCESS);<br>}<br></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 5-main.c -o 5<br>julien@holberton:~/holberton/w/hackthevm3$ ./5<br>0x1fa8010<br>bytes at 0x1fa8000:<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x1fa8420<br>bytes at 0x1fa8410:<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x1fa8c30<br>bytes at 0x1fa8c20:<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x1fa9840<br>bytes at 0x1fa9830:<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x1faa850<br>bytes at 0x1faa840:<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x1fabc60<br>bytes at 0x1fabc50:<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x1fad470<br>bytes at 0x1fad460:<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x1faf080<br>bytes at 0x1faf070:<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x1fb1090<br>bytes at 0x1fb1080:<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x1fb34a0<br>bytes at 0x1fb3490:<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>There is one clear pattern: the size of the malloc’ed memory chunk is always found in the preceding 0x10 bytes. For instance, the first <code>malloc</code> call is malloc’ing <code>1024</code> (<code>0x0400</code>) bytes and we can find <code>11 04 00 00 00 00 00 00</code> in the preceding <code>0x10</code> bytes. Those last bytes represent the number <code>0x 00 00 00 00 00 00 04 11</code> = <code>0x400</code> (1024) + <code>0x10</code> (the block size preceding those <code>1024</code> bytes + <code>1</code> (we’ll talk about this “+1” later in this chapter). If we look at each <code>0x10</code> bytes preceding the addresses returned by <code>malloc</code>, they all contain the size of the chunk of memory asked to <code>malloc</code> + <code>0x10</code> + <code>1</code>.</p><br><p>At this point, given what we said and saw earlier, we can probably guess that those 0x10 bytes are a sort of data structure used by <code>malloc</code> (and <code>free</code>) to deal with the heap. And indeed, even though we don’t understand everything yet, we can already use this data structure to go from one malloc’ed chunk of memory to the other (<code>6-main.c</code>) as long as we have the address of the beginning of the heap (<em>and as long as we have never called <code>free</code></em>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> pmem - print mem                                                                            
 </em> @p: memory address to start printing from<br> <em> @bytes: number of bytes to print                                                            
 </em><br> <em> Return: nothing                                                                             
 </em>/<br>void pmem(void <em>p, unsigned int bytes)<br>{<br>    unsigned char </em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char <em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, </em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/</strong><br> <em> main - using the 0x10 bytes to jump to next malloc’ed chunks
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br>    int i;<br>    void </em>heap_start;<br>    size_t size_of_the_block;<br><br>    heap_start = sbrk(0);<br>    write(1, “START\n”, 6);<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1)); 
        </em>((int <em>)p) = i;<br>        printf(“%p: [%i]\n”, p, i);<br>    }<br>    p = heap_start;<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        pmem(p, 0x10);<br>        size_of_the_block = </em>((size_t <em>)((char </em>)p + 8)) - 1;<br>        printf(“%p: [%i] - size = %lu\n”,<br>              (void <em>)((char </em>)p + 0x10),<br>              <em>((int </em>)((char <em>)p + 0x10)),<br>              size_of_the_block);<br>        p = (void </em>)((char <em>)p + size_of_the_block);<br>    }<br>    write(1, “END\n”, 4);<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 6-main.c -o 6<br>julien@holberton:~/holberton/w/hackthevm3$ ./6<br>START<br>0x9e6010: [0]<br>0x9e6420: [1]<br>0x9e6c30: [2]<br>0x9e7840: [3]<br>0x9e8850: [4]<br>0x9e9c60: [5]<br>0x9eb470: [6]<br>0x9ed080: [7]<br>0x9ef090: [8]<br>0x9f14a0: [9]<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x9e6010: [0] - size = 1040<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x9e6420: [1] - size = 2064<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x9e6c30: [2] - size = 3088<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x9e7840: [3] - size = 4112<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x9e8850: [4] - size = 5136<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x9e9c60: [5] - size = 6160<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x9eb470: [6] - size = 7184<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x9ed080: [7] - size = 8208<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x9ef090: [8] - size = 9232<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>0x9f14a0: [9] - size = 10256<br>END<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>One of our open questions from the previous chapter is now answered: <code>malloc</code> is using <code>0x10</code> additional bytes for each malloc’ed memory block to store the size of the block.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/0x10-malloc.png" alt="0x10 bytes preceeding malloc" scale="0"></p><br><p>This data will actually be used by <code>free</code> to save it to a list of available blocks for future calls to <code>malloc</code>.</p><br><p>But our study also raises a new question: what are the first 8 bytes of the 16 (<code>0x10</code> in hexadecimal) bytes used for? It seems to always be zero. Is it just padding?</p><br><h3>RTFSC</h3><br><p>At this stage, we probably want to check the source code of <code>malloc</code> to confirm what we just found (<code>malloc.c</code> from the glibc).</p><br><pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">1055 /*</div><div class="line">1056       malloc_chunk details:</div><div class="line">1057    </div><div class="line">1058        (The following includes lightly edited explanations by Colin Plumb.)</div><div class="line">1059    </div><div class="line">1060        Chunks of memory are maintained using a `boundary tag&apos; method as</div><div class="line">1061        described in e.g., Knuth or Standish.  (See the paper by Paul</div><div class="line">1062        Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</div><div class="line">1063        survey of such techniques.)  Sizes of free chunks are stored both</div><div class="line">1064        in the front of each chunk and at the end.  This makes</div><div class="line">1065        consolidating fragmented chunks into bigger chunks very fast.  The</div><div class="line">1066        size fields also hold bits representing whether chunks are free or</div><div class="line">1067        in use.</div><div class="line">1068    </div><div class="line">1069        An allocated chunk looks like this:</div><div class="line">1070    </div><div class="line">1071    </div><div class="line">1072        chunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1073                |             Size of previous chunk, if unallocated (P clear)  |</div><div class="line">1074                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1075                |             Size of chunk, in bytes                     |A|M|P|</div><div class="line">1076          mem-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1077                |             User data starts here...                          .</div><div class="line">1078                .                                                               .</div><div class="line">1079                .             (malloc_usable_size() bytes)                      .</div><div class="line">1080                .                                                               |</div><div class="line">1081    nextchunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1082                |             (size of chunk, but used for application data)    |</div><div class="line">1083                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1084                |             Size of next chunk, in bytes                |A|0|1|</div><div class="line">1085                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1086    </div><div class="line">1087        Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</div><div class="line">1088        the malloc code, but &quot;mem&quot; is the pointer that is returned to the</div><div class="line">1089        user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</div><div class="line">```&lt;/pre&gt;</div><div class="line">&lt;p&gt;-&gt;; We were correct \o/. Right before the address returned by &lt;code&gt;malloc&lt;/code&gt; to the user, we have two variables:&lt;/p&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">&lt;li&gt;Size of previous chunk, if unallocated: we never free’d any chunks so that is why it was always 0&lt;/li&gt;</div><div class="line">&lt;li&gt;Size of chunk, in bytes&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;p&gt;Let’s free some chunks to confirm that the first 8 bytes are used the way the source code describes it (&lt;code&gt;7-main.c&lt;/code&gt;):&lt;/p&gt;</div><div class="line">&lt;pre&gt;</div><div class="line">```C</div><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - confirm the source code</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">        printf(&quot;%p\n&quot;, p);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8)) - 1;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk, size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 7-main.c -o 7<br>julien@holberton:~/holberton/w/hackthevm3$ ./7<br>0x1536010<br>0x1536420<br>0x1536c30<br>0x1537840<br>0x1538850<br>0x1539c60<br>0x153b470<br>0x153d080<br>0x153f090<br>0x15414a0<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1536000, size = 1040, prev = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1536410, size = 2064, prev = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1536c20, size = 3088, prev = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1537830, size = 4112, prev = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1538840, size = 5135, prev = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1539c50, size = 6160, prev = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x153b460, size = 7184, prev = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x153d070, size = 8208, prev = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x153f080, size = 9231, prev = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x1541490, size = 10256, prev = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>As we can see from the above listing, when the previous chunk has been free’d, the malloc chunk’s first 8 bytes contain the size of the previous unallocated chunk. So the correct representation of a malloc chunk is the following:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/malloc-chunk.png" alt="malloc chunk" scale="0"></p><br><p>Also, it seems that the first bit of the next 8 bytes (containing the size of the current chunk) serves as a flag to check if the previous chunk is used (<code>1</code>) or not (<code>0</code>). So the correct updated version of our program should be written this way (<code>8-main.c</code>):</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - updating with correct checks</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8));</div><div class="line">        prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">        size_of_the_chunk -= prev_used;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev (%s) = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk,</div><div class="line">              (prev_used? &quot;allocated&quot;: &quot;unallocated&quot;), size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 8-main.c -o 8<br>julien@holberton:~/holberton/w/hackthevm3$ ./8<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1031000, size = 1040, prev (allocated) = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1031410, size = 2064, prev (allocated) = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1031c20, size = 3088, prev (allocated) = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1032830, size = 4112, prev (allocated) = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1033840, size = 5136, prev (unallocated) = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1034c50, size = 6160, prev (allocated) = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x1036460, size = 7184, prev (allocated) = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x1038070, size = 8208, prev (allocated) = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x103a080, size = 9232, prev (unallocated) = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x103c490, size = 10256, prev (allocated) = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><h2>Is the heap actually growing upwards?</h2><br><p>The last question left unanswered is: “Is the heap actually growing upwards?”. From the <code>brk</code> man page, it seems so:</p><br><pre><code>DESCRIPTION<br>       brk() and sbrk() change the location of the program break, which defines the end  of  the<br>       process’s  data  segment  (i.e., the program break is the first location after the end of<br>       the uninitialized data segment).  Increasing the program break has the effect of allocat‐<br>       ing memory to the process; decreasing the break deallocates memory.<br></code></pre><br><p>Let’s check! (<code>9-main.c</code>)</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    write(1, &quot;START\n&quot;, 6);</div><div class="line">    malloc(1);</div><div class="line">    getchar();</div><div class="line">    write(1, &quot;LOOP\n&quot;, 5);</div><div class="line">    for (i = 0; i &lt; 0x25000 / 1024; i++)</div><div class="line">    &#123;</div><div class="line">        malloc(1024);</div><div class="line">    &#125;</div><div class="line">    write(1, &quot;END\n&quot;, 4);</div><div class="line">    getchar();</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>Now let’s confirm this assumption with strace:</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ strace ./9<br>execve(“./9”, [“./9”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “START\n”, 6START<br>)                  = 6<br>brk(0)                                  = 0x1fd8000<br>brk(0x1ff9000)                          = 0x1ff9000<br>…<br>write(1, “LOOP\n”, 5LOOP<br>)                   = 5<br>brk(0x201a000)                          = 0x201a000<br>write(1, “END\n”, 4END<br>)                    = 4<br>…<br>julien@holberton:~/holberton/w/hackthevm3$<br></em></code></pre><br><p>clearly, <code>malloc</code> made only two calls to <code>brk</code> to increase the allocated space on the heap. And the second call is using a higher memory address argument (<code>0x201a000</code> &gt;; <code>0x1ff9000</code>). The second syscall was triggered when the space on the heap was too small to host all the malloc calls.</p><br><p>Let’s double check with <code>/proc</code>.</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 9-main.c -o 9<br>julien@holberton:~/holberton/w/hackthevm3$ ./9<br>START<br><br></code></pre><br><pre><code>julien@holberton:/proc/7855$ ps aux | grep \ ./9$<br>julien     7972  0.0  0.0   4332   684 pts/9    S+   19:08   0:00 ./9<br>julien@holberton:/proc/7855$ cd /proc/7972<br>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>Let’s hit Enter and look at the [heap] again:</p><br><pre><code>LOOP<br>END<br><br></code></pre><br><pre><code>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>The beginning of the heap is still the same, but the size has increased upwards from <code>00922000</code> to <code>00943000</code>.</p><br><h2>The Address Space Layout Randomisation (ASLR)</h2><br><p>You may have noticed something “strange” in the <code>/proc/pid/maps</code> listing above, that we want to study:</p><br><p>The program break is the address of the first location beyond the current end of the data region – so the address of the first location beyond the executable in the virtual memory. As a consequence, the heap should start right after the end of the executable in memory. As you can see in all above listing, it is NOT the case. The only thing that is true is that the heap is always the next memory region after the executable, which makes sense since the heap is actually part of the data segment of the executable itself. Also, if we look even closer, the memory gap size between the executable and the heap is never the same:</p><br><p><em>Format of the following lines: [PID of the above <code>maps</code> listings]: address of the beginning of the [heap] – address of the end of the executable = memory gap size</em></p><br><ul><br><li>[3718]: 01195000 – 00602000 = b93000</li><br><li>[3834]: 024d6000 – 00602000 = 1ed4000</li><br><li>[4014]: 00e70000 – 00602000 = 86e000</li><br><li>[4172]: 01314000 – 00602000 = d12000</li><br><li>[7972]: 00901000 – 00602000 = 2ff000</li><br></ul><br><p>It seems that this gap size is random, and indeed, it is. If we look at the ELF binary loader source code (<code>fs/binfmt_elf.c</code>) we can find this:</p><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">if</span> ((current-&gt;;flags &amp;amp; PF_RANDOMIZE) &amp;amp;&amp;amp; (randomize_va_space &gt;; <span class="number">1</span>)) &#123;</div><div class="line">                current-&gt;;mm-&gt;;brk = current-&gt;;mm-&gt;;start_brk =</div><div class="line">                        arch_randomize_brk(current-&gt;;mm);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> compat_brk_randomized</span></div><div class="line">                current-&gt;;brk_randomized = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div></pre></td></tr></table></figure><br><br><p>where <code>current-&gt;;mm-&gt;;brk</code> is the address of the program break. The <code>arch_randomize_brk</code> function can be found in the <code>arch/x86/kernel/process.c</code> file:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_randomize_brk</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> range_end = mm-&gt;;brk + <span class="number">0x02000000</span>;</div><div class="line">        <span class="keyword">return</span> randomize_range(mm-&gt;;brk, range_end, <span class="number">0</span>) ? : mm-&gt;;brk;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>The <code>randomize_range</code> returns a start address such that:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  [...... &lt;range&gt;; .....]</div><div class="line">start                  end</div></pre></td></tr></table></figure><br><br><p>Source code of the <code>randomize_range</code> function (<code>drivers/char/random.c</code>):</p><br><pre><code class="C">/<br> <em> randomize_range() returns a start address such that
 </em><br> <em>    […… <range>; …..]
 </range></em>  start                  end<br> <em>
 </em> a <range>; with size “len” starting at the return value is inside in the<br> <em> area defined by [start, end], but is otherwise randomized.
 </em>/<br>unsigned long<br>randomize_range(unsigned long start, unsigned long end, unsigned long len)<br>{<br>        unsigned long range = end - len - start;<br><br>        if (end &lt;= start + len)<br>                return 0;<br>        return PAGE_ALIGN(get_random_int() % range + start);<br>}<br></range></code></pre><br><p>As a result, the offset between the data section of the executable and the program break initial position when the process runs can have a size of anywhere between <code>0</code> and <code>0x02000000</code>. This randomization is known as Address Space Layout Randomisation (ASLR). ASLR is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the positions of the heap and the stack.</p><br><h2>The updated VM diagram</h2><br><p>With all the above in mind, we can now update our VM diagram:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/virtual_memory_diagram_v2.png" alt="Virtual memory diagram" scale="0"></p><br><h2><code>malloc(0)</code></h2><br><p>Did you ever wonder what was happening when we call <code>malloc</code> with a size of <code>0</code>? Let’s check! (<code>10-main.c</code>)</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    p = malloc(0);</div><div class="line">    printf(&quot;%p\n&quot;, p);</div><div class="line">    pmem((char *)p - 0x10, 0x10);</div><div class="line">    size_of_the_chunk = *((size_t *)((char *)p - 8));</div><div class="line">    prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">    size_of_the_chunk -= prev_used;</div><div class="line">    printf(&quot;chunk size = %li bytes\n&quot;, size_of_the_chunk);</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 10-main.c -o 10<br>julien@holberton:~/holberton/w/hackthevm3$ ./10<br>0xd08010<br>00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00<br>chunk size = 32 bytes<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>-&gt;; <code>malloc(0)</code> is actually using 32 bytes, including the first <code>0x10</code> bytes.</p><br><p>Again, note that this will not always be the case. From the man page (<code>man malloc</code>):</p><br><pre><code>NULL may also be returned by a successful call to malloc() with a size of zero<br></code></pre><br><h2>Outro</h2><br><p>We have learned a couple of things about malloc and the heap. But there is actually more than <code>brk</code> and <code>sbrk</code>. You can try malloc’ing a big chunk of memory, <code>strace</code> it, and look at <code>/proc</code> to learn more before we cover it in a next chapter <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><p>Also, studying how <code>free</code> works in coordination with <code>malloc</code> is something we haven’t covered yet. If you want to look at it, you will find part of the answer to why the minimum chunk size is <code>32</code> (when we ask <code>malloc</code> for <code>0</code> bytes) vs <code>16</code> (<code>0x10</code> in hexadecimal) or <code>0</code>.</p><br><p>As usual, to be continued! Let me know if you have something you would like me to cover in the next chapter.</p><br><h3>Questions? Feedback?</h3><br><p>If you have questions or feedback don’t hesitate to ping us on Twitter at <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a>.<br><br><em>Haters, please send your comments to <code>/dev/null</code>.</em></p><br><p>Happy Hacking!</p><br><h3>Thank you for reading!</h3><br><p>As always, no-one is perfect (except <a href="http://codesqueeze.com/the-ultimate-top-25-chuck-norris-the-programmer-jokes/" target="_blank" rel="external">Chuck</a> of course), so don’t hesitate to <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc,%20the%20heap%20and%20the%20program%20break/" target="_blank" rel="external">contribute</a> or send me your comments if you find anything I missed.</p><br><h3>Files</h3><br><p><a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/tree/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break" target="_blank" rel="external">This repo</a> contains the source code (<code>naive_malloc.c</code>, <code>version.c</code> &amp; “X-main.c` files) for programs created in this tutorial.</p><br><h3>Read more about the virtual memory</h3><br><p>Follow <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a> on Twitter to get the next chapters!</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br><li>Chapter 3: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank" rel="external">Hack the Virtual Memory: malloc, the heap &amp; the program break</a></li><br></ul><br><p><em>Many thanks to <a href="https://twitter.com/wintermanc3r" target="_blank" rel="external">Tim</a>, <a href="https://twitter.com/1million40" target="_blank" rel="external">Anne</a> and <a href="https://www.linkedin.com/in/iancugniere/" target="_blank" rel="external">Ian</a> for proof-reading!</em> <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><!-- Simple Share Buttons Adder (6.3.4) simplesharebuttons.com --><div class="ssba ssba-wrap"><div style="text-align:left">Sharing is caring<a data-site="reddit" class="ssba_reddit_share" href="http://reddit.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack the Virtual Memory: malloc, the heap &amp; the program break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png" title="Reddit" class="ssba ssba-img" alt="Share on Reddit"></a><a data-site="" class="ssba_twitter_share" href="http://twitter.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;text=Hack+the+Virtual+Memory%3A+malloc%2C+the+heap+%26+the+program+break+" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png" title="Twitter" class="ssba ssba-img" alt="Tweet about this on Twitter"></a><a data-site="" class="ssba_facebook_share" href="http://www.facebook.com/sharer.php?u=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png" title="Facebook" class="ssba ssba-img" alt="Share on Facebook"></a><a data-site="" class="ssba_google_share" href="https://plus.google.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png" title="Google+" class="ssba ssba-img" alt="Share on Google+"></a><a data-site="linkedin" class="ssba_linkedin_share ssba_share_link" href="http://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png" title="LinkedIn" class="ssba ssba-img" alt="Share on LinkedIn"></a><a data-site="digg" class="ssba_diggit_share ssba_share_link" href="http://www.digg.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/diggit.png" title="Digg" class="ssba ssba-img" alt="Digg this"></a><a data-site="stumbleupon" class="ssba_stumbleupon_share ssba_share_link" href="http://www.stumbleupon.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack%20the%20Virtual%20Memory:%20malloc,%20the%20heap%20&amp;%20the%20program%20break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/stumbleupon.png" title="StumbleUpon" class="ssba ssba-img" alt="Share on StumbleUpon"></a></div></div><br>        <div class="clearfix"></div>

<pre><code>&lt;/div&gt;
</code></pre></div>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/内存管理-虚拟内存/" rel="tag"># 内存管理  虚拟内存</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/13/深入理解Linux中内存管理/" rel="next" title="深入理解Linux中内存管理">
                <i class="fa fa-chevron-left"></i> 深入理解Linux中内存管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/28/部署脚本/" rel="prev" title="部署脚本">
                部署脚本 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">易斌</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理转载"><span class="nav-number">1.</span> <span class="nav-text">内存管理转载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">The heap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Prerequisites</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Environment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">No malloc, no [heap]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">malloc(x)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">strace, brk and sbrk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Many mallocs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Naive malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">The 0x10 lost bytes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">RTFSC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Is the heap actually growing upwards?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">The Address Space Layout Randomisation (ASLR)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">The updated VM diagram</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">malloc(0)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number"></span> <span class="nav-text">Outro</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">Questions? Feedback?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">Thank you for reading!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">Files</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">Read more about the virtual memory</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">易斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
