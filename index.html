<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="知而智">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="知而智">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知而智">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>知而智</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <!-- <div class="headband"></div> -->

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">知而智</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>


<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/15/reids/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/15/reids/" itemprop="url">reids</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-15T10:17:40+08:00">
                2017-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源代码学习/" itemprop="url" rel="index">
                    <span itemprop="name">开源代码学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>redis和nginx一直是我认为很优秀的开源项目，也是我看的较多的开源实现。下面从几个方面简单说说redis实现。</p>
<ul>
<li>redis介绍</li>
<li>常用数据类型</li>
<li>io模型</li>
<li>通信协议</li>
<li>疑问解答</li>
</ul>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis是一个基于<strong>内存</strong>的数据库，现有的数据类型满足大部分公司的开发需求，性能也满足一般公司使用。</p>
<p>redis虽然是一个基于<strong>内存</strong>的数据库，但他提供了两种可以持久化的方式。这种持久化的机制避免的redis服务<br>器重启丢失数据的问题，但也不能完全避免数据不会丢失(这里讨论的是非集群模式)。</p>
<p>redis提供的内存持久有<code>rdb</code>快照和基于<code>aof</code>的文件方式，默认是rdb快照，可以通过配置修改快照更新的方式，<br>这两种方式都是<code>fork</code>进程执行<code>backup</code>的。下面我们讨论redis里面的数据类型</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>我们先来看下redis源码说明。redis里的值有5种基础的类型，任何一个值都是以<code>redisObject</code>存在，并以下面不<br>同的编码方式编码成一个<code>redisObject</code>。</p>
<p><code>server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></div><div class="line"> * Data types</div><div class="line"> *----------------------------------------------------------------------------*/</div><div class="line"></div><div class="line"><span class="comment">/* A redis object, that is a type able to hold a string / list / set */</span></div><div class="line"></div><div class="line"><span class="comment">/* The actual Redis Object */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ... </span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></div><div class="line"> * internally represented in multiple ways. The 'encoding' field of the object</div><div class="line"> * is set to one of this fields for this object. */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;</span>lru */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</div><div class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to server.lruclock) or</span></div><div class="line">                            * LFU data (least significant 8 bits frequency</div><div class="line">                            * and most significant 16 bits decreas time). */</div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串类型是redis里最基础的值。字符串是二进制安全的，也就是说这样的字符串可以包含任意的数据，比如一张<code>JPEG</code>的图片或一个序列化的<code>Ruby</code>对象。字符串值最大的长度是<code>512MB</code>。</p>
<p>在redis里面，你可以用字符串做一些有趣的事情。比如:</p>
<ul>
<li>字符串可以使用类似<code>INCR</code>的命令(<code>INCR</code> <code>DECR</code> <code>INCRBY</code>)作为原子计数</li>
<li>用<code>APPEND</code>命令向字符串的值里追加一些字符串</li>
<li>可以用<code>GETRANGE</code>和<code>SETRANGE</code>像随机访问数组一样获取或改变字符串里面的内容</li>
<li>少量的空间可以编码大量的数据或者可以使用<code>GETBIT</code>和<code>SETBIT</code>来创建一个<code>Redis backed Bloom Filter</code></li>
</ul>
<p>常用的命令如下:</p>
<p><code>INCR</code> <code>GET</code> <code>SET</code> <code>STRLEN</code>等命令</p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>列表是一个简单的字符串列表，按插入的顺序排序。往列表增加一个元素可能从列表的头部或者从列表的尾部添加。</p>
<p><code>LPUSH</code>命令在列表的头部插入一个新的元素，<code>RPUSH</code>则是往列表尾部插入一个新的元素。当在一个不存的在key上<br>执行以上操作后会生成一个新的列表。同样的，执行对应的操作key所对应的空间会被删除。</p>
<p>这些命令都是非常方便的语义，因此，如果命令带有一个不存的key时，所有的列表相关的命令在空列表里面会执行和他们名称相同的操作，<br>一些列表相关的命令使用例子以及结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LPUSH mylist a   # now the list is &quot;a&quot;</div><div class="line">LPUSH mylist b   # now the list is &quot;b&quot;,&quot;a&quot;</div><div class="line">RPUSH mylist c   # now the list is &quot;b&quot;,&quot;a&quot;,&quot;c&quot; (RPUSH was used this time)</div></pre></td></tr></table></figure>
<p>开表最大的长度是<strong>2<sup>32</sup>-1</strong>(4294967295,超过40亿).</p>
<p>从时间复杂角度来看列表的主要特征是他在列表的首尾进行插入和删除的时间常数。即使列表里面有数亿个元素，访问里边的元素是非常快的，<br>但访问一个非常巨大的列表来说，越访问后面的速度会变得越慢，它的时间复杂度为O(N)</p>
<p>你可以用列表做一些有趣的事情，比如:</p>
<ul>
<li><p>在社交网络中建立一个时间线，基于用户的时间线使用<code>LPUSH</code>增加新的元素，使用<code>LRANGE</code>来获取最近插入的元素。 </p>
</li>
<li><p><code>LPUSH</code>结合<code>LTRIM</code>可以创建一个不会超过指定元素的列表，只记录最近N个元素</p>
</li>
<li><p>列表可以作为一个消息传递原语，例如著名的<code>Resque Ruby</code>图书馆创建后台作业</p>
</li>
<li><p>你可以做更多关于列表相关的事，这种数据类型支持许多命令，包含阻塞的命令,如:<code>BLPOP</code></p>
</li>
</ul>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>Set是一个没有排序的字符串的一个集合。新增、删除以及判断是成员是否成在的时间复杂度可以是<code>O(1)</code>(这个时间常量不管集合里面的无数个数)。</p>
<p>集合拥有不允许重复元素的特性。同一个元素增加多次的结果只会有一个元素存在集合里面，从实践的角度来说往集合里面增加一个元素的时候不需要主动判断元素是否已经存在。</p>
<p>一个关于集合非常有趣的事情是，它支持一些服务器用来计算已经存在的集合的命令，这样你可以在短的时间内完成集合的合并、交集，差异。</p>
<p>集合中最大的元素个数是<strong>2<sup>32</sup>-1</strong>(4294967295,超过40亿).</p>
<p>你可以用集合做许多有趣的事情，例如:</p>
<ul>
<li><p>可以用集合记录唯一的东西。想要知道访问一篇博客的所有唯一的IP地址？ 每次一个页面查看的时候简单的使用<code>SADD</code>加入IP。你确定重复的IP将不会被插入。</p>
</li>
<li><p>集合对代表关系有好处。你可以用集合代表每个一标签创建一个标签系统。<br>然后你可以用<code>SADD</code>命令给所有拥有一个标签的对象的所有ID加到一个集合里面代表这特殊的标签。如果你想所有对象的所有ID在同一时间拥有三个不同的标签，那就使用<code>SINTER</code></p>
</li>
<li><p>你可以使用<code>SPOP</code>或<code>SRANDMEMBER</code>命令随机获取集合里面的元素。</p>
</li>
</ul>
<h4 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h4><p>Hash是字符串字段和字符串的值的一个映射，因此Hash用来代表对象类型是完美的数据类型(举例:一个拥有多个字段的用户,如名字、姓氏、年龄以及更多)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@cli</div><div class="line">HMSET user:1000 username antirez password P1pp0 age 34</div><div class="line">HGETALL user:1000</div><div class="line">HSET user:1000 password 12345</div><div class="line">HGETALL user:1000</div></pre></td></tr></table></figure>
<p>拥有一些字段的hash以花费非常少的空间方式存储，所以你可以在一个小的Redis实例里面存储数以百万计的对象。</p>
<p>然而hash主要被用来当作对象存储，它们拥有存储多个元素的能力，所以你同样可以为其它更多任务使用<code>hash</code></p>
<p>每一个<code>hash</code>最多可以存储2<sup>32</sup>-1个field-value组(超过40亿).</p>
<h4 id="Sorted-sets"><a href="#Sorted-sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h4><p>有序集合和没有重复的字符串集合非常相似。区别是有序集合的每个一个成员都关联一个分值，这个分值被用来使有序集合保持从小到大的顺序。因此成员是唯一的，但分值可能重复。</p>
<p>通过有序集合，你可以非常快的方式新增、删除或更新一个元素(在时间上与集合里面的元素个数成对比).</p>
<p>因为元素在集合里面是有序的，并非后续才有序，你同样可以根据分数或排名很快速的获取范围。访问有序集合中间元素也非常快，所以你可以使用有序集合作为一个没有重复无素的智能列表，在这里你可以快速访问你想要访问的任何东西: 有序的元素、快速存在检测，快速访问中间元素!</p>
<p>简而言之，使用有序集合你可以完成许多任务，并拥有在其它种类的数据库里面不能达到的好的性能。</p>
<p>你可以用有序集合做如下事情:</p>
<ul>
<li><p>在大型在线游戏中做一个排行榜，在这里每一次一个新的分数提交时，你用<code>ZADD</code>更新它。使用<code>ZRANGE</code>可以容易的获取排名靠前的玩家，你同样可以使用<code>ZRANK</code>获取一个玩家自己的排名。结合<code>ZRANK</code>和<code>ZRANGE</code>你可以显示玩家以及对应的分数。所有操作都非常快。</p>
</li>
<li><p>有序集合经常被用来查找存在<code>redis</code>里面的数据。比如你有许多<code>hash</code>代表玩家,可以使用以玩家年龄作为分数，玩家<code>id</code>作为值的元素的一个集合。这样使用<code>ZRANGEBYSCORE</code>将会变得平常并可以根据给的年龄段很快的获取所有的玩家</p>
</li>
</ul>
<h3 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h3><p>服务器是基于epoll的io模型，<code>redis</code>是单进程的事件模型驱动的架构设计。处理两类事件</p>
<ul>
<li>时间事件</li>
<li>网络IO事件</li>
</ul>
<blockquote>
<p>对于<code>redis</code>里面IO事件它支持<code>select</code>、<code>eploo</code>、<code>kqueue</code>、<code>evport</code>多种io监听机制。并封装了一套IO的接口</p>
</blockquote>
<p><code>ae.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* A simple event-driven programming library. Originally I wrote this code</span></div><div class="line"> * for the Jim's event-loop (Jim is a Tcl interpreter) but later translated</div><div class="line"> * it in form of a library for easy reuse.</div><div class="line"> *</div><div class="line"> * Copyright (c) 2006-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</div><div class="line"> * All rights reserved.</div><div class="line"> *</div><div class="line"> * Redistribution and use in source and binary forms, with or without</div><div class="line"> * modification, are permitted provided that the following conditions are met:</div><div class="line"> *</div><div class="line"> *   * Redistributions of source code must retain the above copyright notice,</div><div class="line"> *     this list of conditions and the following disclaimer.</div><div class="line"> *   * Redistributions in binary form must reproduce the above copyright</div><div class="line"> *     notice, this list of conditions and the following disclaimer in the</div><div class="line"> *     documentation and/or other materials provided with the distribution.</div><div class="line"> *   * Neither the name of Redis nor the names of its contributors may be used</div><div class="line"> *     to endorse or promote products derived from this software without</div><div class="line"> *     specific prior written permission.</div><div class="line"> *</div><div class="line"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</div><div class="line"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class="line"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</div><div class="line"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</div><div class="line"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</div><div class="line"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</div><div class="line"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</div><div class="line"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</div><div class="line"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</div><div class="line"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</div><div class="line"> * POSSIBILITY OF SUCH DAMAGE.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __AE_H__</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __AE_H__</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_OK 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_ERR -1</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_NONE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_READABLE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_WRITABLE 2</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_FILE_EVENTS 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_TIME_EVENTS 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_DONT_WAIT 4</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_NOMORE -1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_DELETED_EVENT_ID -1</span></div><div class="line"></div><div class="line"><span class="comment">/* Macros */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AE_NOTUSED(V) ((void) V)</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> aeEventLoop;</div><div class="line"></div><div class="line"><span class="comment">/* Types and data structures */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">aeFileProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">void</span> *clientData, <span class="keyword">int</span> mask)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">aeTimeProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">aeEventFinalizerProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">void</span> *clientData)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">aeBeforeSleepProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* File event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</div><div class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></div><div class="line">    aeFileProc *rfileProc;   <span class="comment">/* io读的回调 */</span></div><div class="line">    aeFileProc *wfileProc;   <span class="comment">/* io写的回调 */</span></div><div class="line">    <span class="keyword">void</span> *clientData;</div><div class="line">&#125; aeFileEvent;</div><div class="line"></div><div class="line"><span class="comment">/* Time event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeTimeEvent &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></div><div class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></div><div class="line">    aeTimeProc *timeProc;</div><div class="line">    aeEventFinalizerProc *finalizerProc;</div><div class="line">    <span class="keyword">void</span> *clientData;</div><div class="line">    <span class="keyword">struct</span> aeTimeEvent *next;</div><div class="line">&#125; aeTimeEvent;</div><div class="line"></div><div class="line"><span class="comment">/* A fired event */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">int</span> mask;</div><div class="line">&#125; aeFiredEvent;</div><div class="line"></div><div class="line"><span class="comment">/* State of an event based program */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></div><div class="line">    aeFileEvent *events; <span class="comment">/* Registered events 所有已经建立tcp连接的fd */</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events  有io事件需要处理的fd*/</span></div><div class="line">    aeTimeEvent *timeEventHead; <span class="comment">/*  定时任务的列表 */</span></div><div class="line">    <span class="keyword">int</span> stop;</div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data 存储epool_fd 以及从内核获取所有就绪io事件的fd */</span></div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line">&#125; aeEventLoop;</div><div class="line"></div><div class="line"><span class="comment">/* Prototypes */</span></div><div class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeStop</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></div><div class="line">        aeFileProc *proc, <span class="keyword">void</span> *clientData);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd)</span></span>;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</span></span></div><div class="line">        aeTimeProc *proc, <span class="keyword">void</span> *clientData,</div><div class="line">        aeEventFinalizerProc *finalizerProc);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeWait</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> mask, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">aeGetApiName</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeSetBeforeSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetSetSize</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeResizeSetSize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p><code>redis</code>服务器处理事件的主入口在这里，每次进入事件循环之前先执行了一个函数(持入化的相关的流程，以及回复需要回复的client等)，然后再去执行定时事件和客户端发过来的命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Process every pending time event, then every pending file event</span></div><div class="line"> * (that may be registered by time event callbacks just processed).</div><div class="line"> * Without special flags the function sleeps until some file event</div><div class="line"> * fires, or when the next time event occurs (if any).</div><div class="line"> *</div><div class="line"> * If flags is 0, the function does nothing and returns.</div><div class="line"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</div><div class="line"> * if flags has AE_FILE_EVENTS set, file events are processed.</div><div class="line"> * if flags has AE_TIME_EVENTS set, time events are processed.</div><div class="line"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</div><div class="line"> * the events that's possible to process without to wait are processed.</div><div class="line"> *</div><div class="line"> * The function returns the number of events processed. */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</div><div class="line"></div><div class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></div><div class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></div><div class="line">     * file events to process as long as we want to process time</div><div class="line">     * events, in order to sleep until the next time event is ready</div><div class="line">     * to fire. */</div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> timeval tv, *tvp;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        <span class="keyword">if</span> (shortest) &#123;</div><div class="line">            <span class="keyword">long</span> now_sec, now_ms;</div><div class="line"></div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line"></div><div class="line">            <span class="comment">/* How many milliseconds we need to wait for the next</span></div><div class="line">             * time event to fire? */</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms =</div><div class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</div><div class="line">                shortest-&gt;when_ms - now_ms;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</div><div class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</div><div class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</div><div class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* If we have to check for events but need to return</span></div><div class="line">             * ASAP because of AE_DONT_WAIT we need to set the timeout</div><div class="line">             * to zero */</div><div class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* Otherwise we can block */</span></div><div class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</div><div class="line"></div><div class="line">	    <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></div><div class="line">             * event removed an element that fired and we still didn't</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                rfired = <span class="number">1</span>;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Check time events */</span></div><div class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>aeProcessEvents</code>函数主要是处理定时任务的事件和网络IO事件，先找时间最近的一个定时任务，如果时间到了<code>aePoll</code>的时间参数为0，表示立即返回，说明优先执行定时任务然后再等下次循环进入。</p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>redis的协议很简单，就基本的raw字符串，然后有自己的固定格式，按这格式读写就可以和<code>redis</code>服务器完成通信和后续的任务。</p>
<p>只要和<code>redis</code>服务器建立tcp连接后，知道他消息格式的话，直接写入raw字符串就可以执行对应的命令。我们也可以通过解析这<br>样的消息格式就可以实现和服务器通信的目的。</p>
<p>redis里面用的协议名称叫<strong>RESP</strong><code>(REdis Serialization Protocol)</code>，它支持以下几种数据类型:</p>
<ul>
<li><strong>Strings</strong> 协议里的第一字符为 <strong>“+”</strong></li>
<li><strong>Errors</strong> 协议里的第一字符为 <strong>“-“</strong></li>
<li><strong>Integers</strong> 协议里的第一字符为 <strong>“:”</strong></li>
<li><strong>Bulk Strings</strong> 协议里的第一字符为 <strong>“$”</strong></li>
<li><strong>Arrays</strong> 协议里的第一字符为 <strong>“*”</strong></li>
</ul>
<blockquote>
<p>客户端发给服务器的命令是一个<code>Bulk String</code>的数组，服务器回的包含以上所例举的。</p>
</blockquote>
<h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p>字符串类型被编码成下面的方式:”+”后面跟具体的字符串内容，中间不包含<code>CR</code>或者<code>LF</code>字符(没有新的行才是允许的)，最后台<code>CRLF</code>(\r\n)结尾.</p>
<p>字符串类型用最小的开销来传输非二进安全的字符串。比如许多<code>redis</code>命令执行成功时仅回复”OK”，这样的字符串类型被编码成以下5个字节:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;+OK\r\n&quot;</div></pre></td></tr></table></figure>
<p>为了发送二进制安全的字符串，<code>Bulk Strings</code>用来替代<code>Strings</code>的功能。</p>
<p>当<code>redis</code>服务器回复一个字符串类型时，一个<code>redis</code>客户端的库应该返回<code>+</code>后边的字符串，不包括<code>CRLF</code>。</p>
<h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h4><p>RESP对于错误有一个特定的数据类型。实际上<code>errors</code>非常像字符串类型，只是用<code>-</code>替代了<code>+</code>.两者的区别在于<code>errors</code>被客户端用作异常处理，错误的数据类型里面的字符串就是它的错误消息.</p>
<p>错误消息的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;-Error message\r\n&quot;</div></pre></td></tr></table></figure>
<p>只有在发生一些错误的时候才会回复错误消息，比方说，如果执行的操作与你对应的数据类型不同时，或者你执行的命令不存在以及其它情况。当收到一个错误回复的时候<code>redis</code>客户端应该抛出一个异常。</p>
<p>下面是一个错误回包的一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-ERR unknown command &apos;foobar&apos;</div><div class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</div></pre></td></tr></table></figure>
<p>从第一个字符<code>-</code>到第一个空格或新的行，代表了返回的错误类型。这是<code>redis</code>常用的惯例，但并不是所有协议里面的错误格式。</p>
<p>举例说明，<code>ERR</code>是常用的错误类型，而<code>WRONGTYPE</code>是更具体的错误，这种错误应用在当客户端执行一个操作对于错误的数据类型时候。这种错误类型叫错误前缀，它是一种允许客户端理解服务器回复的错误类型的方式，而不依赖服务器回复的具体内容，这可能会随着时间改变。</p>
<p>对于不同的错误类型，一个客户端的实现可能会返回不同的异常，也可能会通过直接返回错误的字符串描述内容给调用者提供一个常用的方式来定位错误</p>
<p>然而，像这样一个特征不应该考虑至关重要因为它很少有用，一个有限的客户端实现可能简单的返回常用的错误条件，比如false.</p>
<h4 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h4><p>这种类型是以<code>CRLF</code>结尾的字符串代表一个<code>interger</code>，以一个<code>:</code>字节做为前缀。比如”:0\r\n”,或者”:1000\r\n”都是回复的整型类型.</p>
<p>许多<code>redis</code>命令都回复<code>Intergers</code>，比如<code>INCR</code>，<code>LLEN</code>以及<code>LASTSAVE</code>.</p>
<p>返回整形没有什么特殊的意义，对于<code>INCR</code>是一个增量值，对<code>LASTSAVE</code>是一个<code>Unix time</code>等等。然而，返回的整数确定是在有符号的64位整型的范围.</p>
<p>回复整形在回得<code>true</code>或<code>false</code>的时候使用也广泛。像<code>EXISTS</code>或<code>SISMEMBER</code>命令将会返回1代表true，0代表false.</p>
<p>像其它<code>SADD</code>,<code>SREM</code>以及<code>SETNX</code>，如果命令实际执行成功会返回1，否则返回0.</p>
<p>下面命令会回复一个整型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SETNX  DEL EXISTS INCR INCRBY DECR DECRBY DBSIZE LASTSAVE</div><div class="line">RENAMEX MOVE LLEN SADD SREM SISMEMBER SCARD</div></pre></td></tr></table></figure></p>
<h3 id="Bulk-Strings"><a href="#Bulk-Strings" class="headerlink" title="Bulk Strings"></a>Bulk Strings</h3><p><code>Bulk Strings</code>被用来代表一个独立的二进制安全的最大长度为512M的字符串</p>
<p><code>Bulk Strings</code>被编码成下面的方式:</p>
<ul>
<li><code>$</code>后面跟随组成字符串内容的字节个数，以<code>CRLF</code>结尾</li>
<li>实际的字符串内容</li>
<li>最后一个<code>CRLF</code></li>
</ul>
<p>所以字符串”foobar”被编码成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;$6\r\nfoobar\r\n&quot;</div></pre></td></tr></table></figure>
<p>空字符串如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;$0\r\n\r\n&quot;</div></pre></td></tr></table></figure>
<p><code>Bulk Strings</code>可以用来特殊的格式来表示一个不存在的值，这样的值代表了一个<code>Null</code>值。这种特殊的格式的长度为-1，后边没有数据，所以一个<code>Null</code>值如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;$-1\r\n&quot;</div></pre></td></tr></table></figure>
<p>这叫做<code>Null Bulk String</code>.</p>
<p>当服务器回复一个<code>Null Bulk String</code>，客户端的API不应该返回一个空字符串，而是一个空对象。<br>比如一个Ruby的客户端应该返回一个<code>nil</code>值，而C实现的客户端应该返回<code>NULL</code>(或者在回复的对象里设置一个特殊的标志)，以及等等</p>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>客户端使用的是<code>Arrays</code>协议向服务器发送命令。相似的<code>Redis</code>命令使用<code>Arrays</code>协议返回元素的一个合集给客户端。一个<code>LRANGE</code>命令返回列表的例子.<br>Clients send commands to the Redis server using RESP Arrays. Similarly certain Redis commands returning collections of elements to the client use RESP Arrays are reply type. An example is the LRANGE command that returns elements of a list.</p>
<p>使用下面的格式返回一个<code>Arrays</code>:</p>
<ul>
<li>前面一个<code>*</code>，后面跟随数组里面元素个数的十进制数值，再接着一个<code>CRLF</code></li>
<li>数组里面的元素是其它数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;*0\r\n&quot;</div></pre></td></tr></table></figure>
<p>当一个包含”foo”和”bar”两个元素的数组被编码成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n&quot;</div></pre></td></tr></table></figure>
<p>你可以看到数组里面在<code>*&lt;count&gt;CRLF</code>的部分是由其它的数据类型连续组成的。比如一个包含三个<code>integer</code>的数组被编码成如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;*3\r\n:1\r\n:2\r\n:3\r\n&quot;</div></pre></td></tr></table></figure>
<p>数组类型同样可以包含不同的其它类型，没有要求数组里面的元素都是相同的类型。比如，一个包含四个<code>integer</code>的列表和一个<code>bulk string</code>被编码成如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">*5\r\n</div><div class="line">:1\r\n</div><div class="line">:2\r\n</div><div class="line">:3\r\n</div><div class="line">:4\r\n</div><div class="line">$6\r\n</div><div class="line">foobar\r\n</div></pre></td></tr></table></figure>
<blockquote>
<p>换成多行是为了方便阅读</p>
</blockquote>
<p>第一行内容<code>*5\r\n</code>说明后面接着有5个元素。每一个回复构成了<code>Multi Bulk</code>用作传播。</p>
<p><code>Null Array</code>的概念同样存在，指定一个空值是可选的(通常使用一个<code>Null Bulk String</code>，由于历史原因我们有两种格式).</p>
<p>比如执行<code>BLPOP</code>命令超时后，服务器返回一个count为-1的空数据,格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;*-1\r\n&quot;</div></pre></td></tr></table></figure>
<p>redis服务器回服一个空数组里，redis客户端应该返回一个空对象而不是一个空数组。很有必要来区分空列表和不同的条件(比如<code>BLPOP</code>命令超时)。</p>
<p>在<code>RESP</code>协议里面数组是可以嵌套使用的。比如一个包含两个数组的数组被编码成如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">*2\r\n</div><div class="line">*3\r\n</div><div class="line">:1\r\n</div><div class="line">:2\r\n</div><div class="line">:3\r\n</div><div class="line">*2\r\n</div><div class="line">+Foo\r\n</div><div class="line">-Bar\r\n</div></pre></td></tr></table></figure>
<p>这个说明，一个数组里面包含一个有三个整型的数组以及一个两个字条串类型的数组。</p>
<h4 id="Null-elements-in-Arrays"><a href="#Null-elements-in-Arrays" class="headerlink" title="Null elements in Arrays"></a>Null elements in Arrays</h4><p>数组里面的单个元素可能为空。在redis回复的包里用来说明这个元素被丢失且不为空字符串。这个可能会发生在<code>sort</code>对<code>get</code>模糊匹配时指定的key不存在时进行排序时。回复一个包含空元素数组的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">*3\r\n</div><div class="line">$3\r\n</div><div class="line">foo\r\n</div><div class="line">$-1\r\n</div><div class="line">$3\r\n</div><div class="line">bar\r\n</div></pre></td></tr></table></figure>
<p>数组中第二个元素是空的。redis客户端应该返回类似下面的东西:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&quot;foo&quot;,nil,&quot;bar&quot;]</div></pre></td></tr></table></figure>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>一次client最大能发送多大的数据</li>
<li>服务器最大回复的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Protocol and I/O related defines */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) <span class="comment">/* 1GB max query buffer. */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_IOBUF_LEN         (1024*16)  <span class="comment">/* Generic I/O buffer size */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_REPLY_CHUNK_BYTES (16*1024) <span class="comment">/* 16k output buffer */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_INLINE_MAX_SIZE   (1024*64) <span class="comment">/* Max size of inline reads */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTO_MBULK_BIG_ARG     (1024*32)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LONG_STR_SIZE      21          <span class="comment">/* Bytes needed for long -&gt; str + '\0' */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_AUTOSYNC_BYTES (1024*1024*32) <span class="comment">/* fdatasync every 32MB */</span></span></div></pre></td></tr></table></figure>
<p>一个redis client向服务器发送命令最大的长度为<code>PROTO_MAX_QUERYBUF_LEN</code>。<br>服务器一次回复最大的消息长度为<code>PROTO_REPLY_CHUNK_BYTES</code>,比方说<code>hgetall</code>比较大的时候就分多次发送</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/启停脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/13/启停脚本/" itemprop="url">启停脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T11:42:35+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/脚本/" itemprop="url" rel="index">
                    <span itemprop="name">脚本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我一直忍受不了没有效率的事情，公司同时负责服务器部署和发布的同事老久都没整一套好的脚本。<br>所以自己负责新项目的时候整了一套服务启停的脚本，经实践，个人觉得非常好用。所以在这里记录下。</p>
<p>需要依赖daemonize的一个程序<br><code>sudo yum install -y daemonize</code></p>
<blockquote>
<p><code>/etc/init.d/functions</code> 这里面还是有好多好东西的。</p>
</blockquote>
<p><code>start-stop.sh</code></p>
<blockquote>
<p>用来选择是启动还是停止某个进程还是所有的进程</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># 启停脚本</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line">COLOR_RED=<span class="string">'\033[0;31m'</span></div><div class="line">COLOR_GREEN=<span class="string">'\033[0;32m'</span></div><div class="line">COLOR_RESET=<span class="string">'\033[0m'</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">usage</span></span>() &#123;</div><div class="line">  <span class="built_in">echo</span> <span class="string">"Usage: `basename <span class="variable">$0</span>`  &#123;start|stop|restart|force-stop|force-restart|status&#125;"</span> &gt;&amp;2</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># At least three arguments are required.</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> <span class="_">-lt</span> 1 ]; <span class="keyword">then</span></div><div class="line">    usage</div><div class="line">    <span class="built_in">exit</span> 5</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># 引入参数</span></div><div class="line">. ./parameters.sh</div><div class="line"></div><div class="line">server_len=$((<span class="variable">$&#123;#SERVERS[@]&#125;</span>))</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">choose_server</span></span>() &#123;</div><div class="line">    <span class="built_in">printf</span> <span class="string">"\n========================================\n"</span></div><div class="line">    <span class="built_in">printf</span> <span class="string">"             Server Name List\n"</span></div><div class="line">    <span class="keyword">for</span> ((i=0; i&lt;server_len; i=i+1)); <span class="keyword">do</span></div><div class="line">        <span class="built_in">printf</span> <span class="string">"%-10d %-20s\n"</span> <span class="variable">$i</span> <span class="variable">$&#123;SERVERS[$(($i))]&#125;</span></div><div class="line">    <span class="keyword">done</span></div><div class="line">    <span class="built_in">printf</span> <span class="string">"========================================\n"</span></div><div class="line">    <span class="built_in">printf</span> <span class="string">"             Server Name List\n"</span></div><div class="line"></div><div class="line">    <span class="built_in">read</span> -p <span class="string">"Please Enter server index[0-<span class="variable">$(($server_len -1)</span>)](greater than <span class="variable">$server_len</span> instend of all): "</span> server_index</div><div class="line"></div><div class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$server_index</span>"</span> =~ ^[0-9]?$ &amp;&amp; <span class="variable">$server_index</span> -ge 0 ]]; <span class="keyword">then</span></div><div class="line">        <span class="built_in">return</span> <span class="variable">$server_index</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"<span class="variable">$&#123;COLOR_RED&#125;</span>invalidate input <span class="variable">$&#123;COLOR_RESET&#125;</span> : <span class="variable">$COLOR_GREEN</span> <span class="variable">$server_index</span> <span class="variable">$COLOR_RESET</span>"</span>;</div><div class="line">        <span class="built_in">exit</span> 4;</div><div class="line">    <span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 单个服还是所有,大于长度代表所有</span></div><div class="line">choose_server</div><div class="line">server_id=$?</div><div class="line"></div><div class="line"></div><div class="line">PROG_NAME=<span class="string">''</span></div><div class="line">PROG_ARGS=<span class="string">''</span></div><div class="line">ACTION=<span class="variable">$1</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"will <span class="variable">$ACTION</span> server follow.."</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$server_id</span> <span class="_">-lt</span> <span class="variable">$server_len</span> ]; <span class="keyword">then</span></div><div class="line">    PROG_NAME=<span class="variable">$&#123;SERVERS[$server_id]&#125;</span></div><div class="line">    PROG_ARGS=<span class="variable">$&#123;SERVER_PARAM[$PROG_NAME]&#125;</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;PROG_NAME&#125;</span>   -----&gt; <span class="variable">$&#123;PROG_ARGS&#125;</span>"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;SERVERS[@]&#125;</span>;<span class="keyword">do</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;key&#125;</span>   -----&gt; <span class="variable">$&#123;SERVER_PARAM[$key]&#125;</span>"</span></div><div class="line">    <span class="keyword">done</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">read</span> -n1 -p <span class="string">"Press insure. [y/n]"</span> sure</div><div class="line"><span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"\nYour inputs: <span class="variable">$sure</span>"</span></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$sure</span>"</span> == <span class="string">"y"</span> ]; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$server_id</span> <span class="variable">$server_len</span>"</span></div><div class="line">    <span class="keyword">if</span> [ <span class="variable">$server_id</span> <span class="_">-lt</span> <span class="variable">$server_len</span> ]; <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$PROG_NAME</span> <span class="variable">$ACTION</span> <span class="variable">$PROG_ARGS</span>"</span></div><div class="line">        <span class="comment">#bash single.sh $PROG_NAME $ACTION $PROG_ARGS</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;SERVERS[@]&#125;</span>;<span class="keyword">do</span></div><div class="line">            PROG_NAME=<span class="variable">$&#123;key&#125;</span></div><div class="line">            PROG_ARGS=<span class="variable">$&#123;SERVER_PARAM[$key]&#125;</span></div><div class="line">            <span class="built_in">echo</span> <span class="string">"<span class="variable">$PROG_NAME</span> <span class="variable">$ACTION</span> <span class="variable">$PROG_ARGS</span>"</span></div><div class="line">            <span class="comment">#bash single.sh $PROG_NAME $ACTION $PROG_ARGS</span></div><div class="line">        <span class="keyword">done</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p><code>single.sh</code></p>
<blockquote>
<p>用来操作单个进程的脚本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># 启停脚本</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">usage</span></span>() &#123;</div><div class="line">  <span class="built_in">echo</span> <span class="string">"Usage: `basename <span class="variable">$0</span>` PROGRAM_NAME &#123;start|stop|restart|status&#125; PROGRAM_NAME"</span> &gt;&amp;2</div><div class="line">  <span class="built_in">echo</span> <span class="string">"Where: PROGRAM_NAME is alias for this process."</span> &gt;&amp;2</div><div class="line">  <span class="built_in">echo</span> <span class="string">"       PROGRAM_ARG contain the executable file and command lind params."</span> &gt;&amp;2</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">array=( <span class="variable">$@</span> )</div><div class="line">len=<span class="variable">$&#123;#array[@]&#125;</span></div><div class="line"></div><div class="line"><span class="comment"># At least three arguments are required.</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$len</span> <span class="_">-lt</span> 3 ]; <span class="keyword">then</span></div><div class="line">    usage</div><div class="line">    <span class="built_in">exit</span> 5</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">source</span> /etc/init.d/<span class="built_in">functions</span></div><div class="line"></div><div class="line">CUR_DIR=$(dirname $(realpath <span class="variable">$0</span>))</div><div class="line">PROGRAM_NAME=<span class="variable">$&#123;array[0]&#125;</span></div><div class="line">ACTION=<span class="variable">$&#123;array[1]&#125;</span></div><div class="line">PROGRAM_ARGS=<span class="variable">$&#123;array[@]:2:$len-1&#125;</span></div><div class="line">RETVAL=0</div><div class="line"></div><div class="line">PID_FILE=<span class="string">".<span class="variable">$PROGRAM_NAME</span>.pid"</span></div><div class="line">LOCK_FILE=<span class="string">".<span class="variable">$PROGRAM_NAME</span>.pid.lock"</span></div><div class="line">LOG_FILE=<span class="string">"<span class="variable">$PROGRAM_NAME</span>.log"</span> <span class="comment">#标准输出和错误输出</span></div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">start</span></span>() &#123;</div><div class="line">    daemonize -c <span class="variable">$CUR_DIR</span> -p <span class="variable">$PID_FILE</span> <span class="_">-l</span> <span class="variable">$LOCK_FILE</span> -o <span class="variable">$LOG_FILE</span> <span class="_">-e</span> <span class="variable">$LOG_FILE</span> -v <span class="variable">$PROGRAM_ARGS</span></div><div class="line">    RETVAL=$?</div><div class="line">    [ <span class="variable">$RETVAL</span> = 0 ] &amp;&amp; success || failure</div><div class="line">    <span class="built_in">echo</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">stop</span></span>()&#123;</div><div class="line">    killproc -p <span class="variable">$PID_FILE</span></div><div class="line">    RETVAL=$?</div><div class="line">    <span class="built_in">echo</span></div><div class="line">    rm <span class="_">-f</span> <span class="variable">$LOCK_FILE</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">status_</span></span>()&#123;</div><div class="line">    status -p <span class="variable">$PID_FILE</span></div><div class="line">    RETVAL=$?</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$ACTION</span>"</span> <span class="keyword">in</span></div><div class="line">  start)</div><div class="line">        start;</div><div class="line">        ;;</div><div class="line">  restart)</div><div class="line">        stop; sleep 1; start;</div><div class="line">        ;;</div><div class="line">  stop)</div><div class="line">        stop</div><div class="line">        ;;</div><div class="line">  status)</div><div class="line">        status_</div><div class="line">        ;;</div><div class="line">  *)</div><div class="line">        usage</div><div class="line">        <span class="built_in">exit</span> 4</div><div class="line">        ;;</div><div class="line"><span class="keyword">esac</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> <span class="variable">$RETVAL</span></div></pre></td></tr></table></figure>
<p><code>parameters.sh</code></p>
<blockquote>
<p>用来配置哪些进程需要启动，以及进程启动的参数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># 需要启动的服对应的名称和参数</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line">CUR_DIR=$(dirname $(realpath <span class="variable">$0</span>))</div><div class="line"></div><div class="line">LOGIN=<span class="string">"login"</span></div><div class="line">HALL=<span class="string">"hall"</span></div><div class="line">COUNT=<span class="string">"count"</span></div><div class="line">GAME10206=<span class="string">"game10206"</span></div><div class="line"></div><div class="line"><span class="comment"># 定义哪些服需要启动</span></div><div class="line">SERVERS=( \</div><div class="line">    <span class="variable">$&#123;LOGIN&#125;</span> \</div><div class="line">    <span class="variable">$&#123;HALL&#125;</span>  \</div><div class="line">    <span class="variable">$&#123;COUNT&#125;</span> \</div><div class="line">    <span class="variable">$&#123;GAME10206&#125;</span>)</div><div class="line"></div><div class="line"><span class="built_in">declare</span> -A SERVER_PARAM</div><div class="line">SERVER_PARAM=([<span class="variable">$&#123;LOGIN&#125;</span>]=<span class="string">"<span class="variable">$CUR_DIR</span>/login --log_dir=log/login"</span> \</div><div class="line">              [<span class="variable">$&#123;HALL&#125;</span>]=<span class="string">"<span class="variable">$CUR_DIR</span>/hall --log_dir=log/hall"</span> \</div><div class="line">              [<span class="variable">$&#123;COUNT&#125;</span>]=<span class="string">"<span class="variable">$CUR_DIR</span>/count --log_dir=log/count"</span> \</div><div class="line">              [<span class="variable">$&#123;GAME10206&#125;</span>]=<span class="string">"<span class="variable">$CUR_DIR</span>/game --log_dir=log/game10206"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;SERVERS[@]&#125;</span>;<span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;key&#125;</span>   -----&gt; <span class="variable">$&#123;SERVER_PARAM[$key]&#125;</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/linux-concurrency-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/11/linux-concurrency-lock/" itemprop="url">linux-concurrency</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T13:14:59+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.linux-mag.com/id/2316/" alt="翻译"></p>
<blockquote>
<p>英语水平有限，工作空闲时间翻译。同时也学习了并发控制的一些知识</p>
</blockquote>
<h3 id="Concurrency-in-the-Kernel-内核里面的并发控制"><a href="#Concurrency-in-the-Kernel-内核里面的并发控制" class="headerlink" title="Concurrency in the Kernel (内核里面的并发控制)"></a>Concurrency in the Kernel (内核里面的并发控制)</h3><p>Multiple threads of execution need to be synchronized to avoid data corruption and even system freezes.</p>
<p>对于有多线程的程序来说，如果有访问共享的东西的话会导致数据的错乱甚至会导致系统的冻结</p>
<p>As the Linux kernel has grown in complexity to support Symmetric Multi-Processing (SMP) and kernel preemption, more and more scenarios generate multiple threads of execution. Because threads can simultaneously operate on shared kernel data structures, access to such data structures has to be serialized. In this column, let’s learn the basics of protecting shared kernel resources from concurrent access, starting with a simple example and slowly introducing complexities like interrupts, kernel preemption, and SMP.</p>
<p>随着linux内核支持对称多处理系统，简称SMP(Symmetric Multi-Processing)以及内核抢占，使得内核变得更加的复杂，越来越多的地方会有多线程的出现，所以线程可以同时操作内核共享的数据结构，访问这些数据必须得串行。在这里，让我们从一个简单的示例来学习并发访问时内核共享资源的基本保护并慢慢的介绍更复杂的情况。比如:中断，内核抢占以及SMP.</p>
<h4 id="Spinlocks-and-Semaphores-自旋锁和信息量"><a href="#Spinlocks-and-Semaphores-自旋锁和信息量" class="headerlink" title="Spinlocks and Semaphores (自旋锁和信息量)"></a>Spinlocks and Semaphores (自旋锁和信息量)</h4><p>A code area that accesses shared resources is called a critical section. Spinlocks and semaphores are the two mechanisms used to protect critical sections in the kernel.</p>
<p>一段访问共享资源的代码叫做临界区。在内核里面，自旋锁和信号量是用来保护临界区的两种机制。</p>
<p>A spinlock ensures that only a single thread enters a critical section at any time. Any other thread that wants to enter the critical section must wait “spinning its wheels” until the first thread exits. Listing One shows a basic use of a spinlock.</p>
<p>在任何时候，只会有一个获取自旋锁的线程进入临界区。其它线程想要进入临界区必须”自旋”等待，直到第之前获取到锁的线程释放。</p>
<p><strong>Listing One: Basic spinlock usage</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Initialize */</span></div><div class="line"><span class="keyword">spinlock_t</span> mylock = SPIN_LOCK_UNLOCKED; </div><div class="line"></div><div class="line"><span class="comment">/* Try to acquire the spinlock. This is inexpensive if there </span></div><div class="line">* is no one inside the critical section. In the face of contention,</div><div class="line">* spinlock() busy waits.</div><div class="line">*/</div><div class="line">spin_lock (&amp;mylock); </div><div class="line"></div><div class="line"><span class="comment">/* … Critical Section … */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release the lock */</span></div><div class="line">spin_unlock (&amp;mylock);</div></pre></td></tr></table></figure>
<p>In contrast to spinlocks, which put threads into a spin if they attempt to enter a busy critical section, a semaphore puts each contending thread to sleep until its turn arrives to occupy the critical section.</p>
<p>如果线程尝试进入已经被自旋锁锁住的临界区，那么自旋锁会导致线程自旋。与自旋锁相比，信号量会让每个相互竞争锁的线程休眠直到他占有这<br>临界区</p>
<p>Because it’s bad to consume processor cycles to spin, semaphores are more suitable than spinlocks to protect critical sections when the estimated wait time is long. In semaphore terms, anything more than two context switches can be considered long, since semaphores have to switch out the contending thread to sleep, and switch it back in when it’s time to wake it up.</p>
<p>由于自旋占用cpu，当执行临界区的代码需要比较长时间时，信号量来保护临界区要比自旋锁更合适。在信号量的情况下，需要考虑超过两次上下文从信号量把竞争锁的线程成休眠到唤醒休眠的切换的时间。</p>
<p>Thus, in many cases, it’s easy to make a decision on whether to use a spinlock or a semaphore:</p>
<p>因此，在各种情况下，很容易作出决定用信号量还是用自旋锁来保护临界区:</p>
<ul>
<li>If your critical section needs to sleep, you have no choice but to use a semaphore. It’s a deadly sin to schedule, preempt, or sleep on a wait queue after acquiring a spinlock.</li>
<li><p>如果你的临界区需要休眠，除了用信号量别无选择。在获取自旋锁后如果在等待队列里被重新调度、抢占或休眠是致命的错误。</p>
</li>
<li><p>Since semaphores put the calling thread to sleep in the face of contention, you have no choice but to use spinlocks inside interrupt handlers.</p>
</li>
<li>因为信号量在获取临界区是会导致调用线程休眠的，所以在中断处理程序里除了用自旋锁别无选择</li>
</ul>
<p>Unlike spinlocks, which allow only a single thread inside a critical section at a time, semaphores can be configured to allow a predetermined number of threads into the critical section simultaneously. (However, semaphores that permit only a single thread at a time are more common in the kernel.) A semaphore that permits only a single thread at a time is called a mutex. Listing Two shows basic mutex usage.</p>
<p>每个时间点自旋锁只允许一个线程处于临界区，信号量是允许配置预先定义好的线程个数同时进入临界区(然而，在内核里面，每次只允许一个线程在临界区)。每个时间点只允许一个线程进入临界区的叫互斥量。</p>
<p><strong>Listing Two: Basic Mutex Usage</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">* Architecture dependent */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/semaphore.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Statically declare a mutex. To dynamically create</span></div><div class="line">* a mutex, use init_MUTEX().</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span> <span class="params">(mysem)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* Try to acquire the semaphore. This is inexpensive if there </span></div><div class="line">* is no one inside the critical section. In the face of contention,</div><div class="line">* down() puts the calling thread to sleep.</div><div class="line">*/</div><div class="line">down (&amp;mysem);</div><div class="line"></div><div class="line"><span class="comment">/* … Critical Section … */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release the semaphore */</span></div><div class="line">up (&amp;mysem);</div></pre></td></tr></table></figure>
<p>To illustrate the use of locks, let’s start with a critical section that is present only in process context and gradually introduce complexities in the following order:</p>
<p>为了说明锁的使用，我们从一个进程上下文的临界区开始然后逐渐讨论以下复杂的情况:</p>
<ul>
<li><p>Critical section present only in process context on a uniprocessor box running a non-preemptible kernel (P-UP-N). This is the simplest case and needs no locking.</p>
</li>
<li><p>临界区只存在不可抢占的单核(P-UP-N)的进程上下文时，这种简单的情况下是不需要锁的。</p>
</li>
<li><p>Critical section present in process and interrupt contexts on a uniprocessor machine running a non-preemptible kernel (PI-UP-N).</p>
</li>
<li><p>临界区存在不可抢占单核(PI-UP-N)的进程和中断上下文</p>
</li>
<li><p>Critical section present in process and interrupt contexts on a uniprocessor machine running a preemptible kernel (PI-UP-P).</p>
</li>
<li><p>临界区存在可抢占单核(PI-UP-P)的进程和中断上下文</p>
</li>
<li><p>Critical section present in process and interrupt contexts on an SMP machine running a preemptible kernel (PI-SMP-P).</p>
</li>
<li><p>临界区存在可抢占的多核(PI-SMP-P)的进程和中断上下文</p>
</li>
</ul>
<blockquote>
<p>除了第一种情况，其它三种是需要对临界区做保护的</p>
</blockquote>
<h4 id="Case-Two-PI-UP-N"><a href="#Case-Two-PI-UP-N" class="headerlink" title="Case Two: PI-UP-N"></a>Case Two: PI-UP-N</h4><p>In the case of a critical section present only in process context on a uniprocessor box running a non-preemptible kernel case, you only need to disable interrupts to protect the critical region:</p>
<p>在临界区存在中断上下文的时候，你需要把中断禁止来保护这个临界区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cli ();  <span class="comment">/* Disable Interrupts */</span></div><div class="line"><span class="comment">/* ... Critical Region ...  */</span></div><div class="line">sti ();  <span class="comment">/* Enable Interrupts */</span></div></pre></td></tr></table></figure>
<p>However, if interrupts are already disabled when execution reaches cli(), sti() has the unpleasant side effect of re-enabling interrupts, rather than restoring interrupt state. This can be fixed with:</p>
<p>然而，如果执行到cli()这里里中断已经被禁止了，sti()恢复中断后会有意想不到的影响会出现，这个可以通过恢复中断状态修改:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line"><span class="comment">/* Point A: Disable Interrupts */</span></div><div class="line">save_flags (flags); </div><div class="line">cli ();  </div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/* Restore state to what it was at Point A above */</span>	</div><div class="line">restore_flags (flags);</div></pre></td></tr></table></figure>
<p>This latter code works correctly, regardless of the interrupt state when<br>execution reaches cli().</p>
<p>这个代码正确工作，当执行到cli()时忽略中断的状态.</p>
<h4 id="Case-Three-PI-UP-P"><a href="#Case-Three-PI-UP-P" class="headerlink" title="Case Three: PI-UP-P"></a>Case Three: PI-UP-P</h4><p>If preemption is enabled, mere disabling of interrupts won’t protect your critical region from being trampled. There is the possibility of multiple threads simultaneously using the critical section in process context. The solution, apparently, is to disable kernel preemption before the start of the critical section and re-enable it at the end. Spinlocks do that internally if CONFIG_PREEMPT is enabled:</p>
<p>如果内核是可以抢占的，仅仅只禁掉中断是不能保护你的临界区的，有可能多个线程在同一个进程上下文进入到同一临界区。很显然，解决方案是在进入临界区前禁用内核抢占然后在最后重新开启内核抢占。在可抢占的内核里面，自旋锁就是这样实现的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Marker to turn OFF preemption */</span></div><div class="line">spin_lock (&amp;mylock);    </div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/* Marker to turn ON preemption */</span></div><div class="line">spin_unlock (&amp;mylock);</div></pre></td></tr></table></figure>
<p>However, this still doesn’t prevent interrupt handlers from stomping through your critical section. Instead, use the IRQ variant of spinlocks:</p>
<p>然而，这仍然还是不能避免在临界区发生的中思。取而代之的是使用自旋锁的另一种实现IRQ:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Point A:</div><div class="line"> * Save interrupt state.</div><div class="line"> * Disable interrupts and preemption.</div><div class="line"> */	</div><div class="line">spin_lock_irqsave (&amp;mylock, flags);</div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Enable preemption. Restore interrupt state to that </div><div class="line"> * at Point A.</div><div class="line"> */</div><div class="line">spin_unlock_irqrestore (&amp;mylock, flags);</div></pre></td></tr></table></figure>
<p>Preemption state need not be restored to what it was at Point A, since the kernel does that for you via a variable called the preemption counter. The counter gets incremented whenever preemption is disabled (using the preempt_disable() function), and gets decremented whenever preemption is enabled (using the preempt_enable() function). Preemption kicks in only if the counter value is zero.</p>
<p>自从内核通过一个叫可抢占计数后，在Point A不需要保存抢占的状态。这个计数在抢占禁用(preempt_disable)时会增加,在启用(preempt_enable())时会减少计数。只有当这个计数为0的时候才是可以抢占的。</p>
<h4 id="Case-Three-PI-SMP-P"><a href="#Case-Three-PI-SMP-P" class="headerlink" title="Case Three: PI-SMP-P"></a>Case Three: PI-SMP-P</h4><p>Now assume that the critical section executes on an SMP machine and that your kernel has been configured with CONFIG_SMP and CONFIG_PREEMPT turned on.</p>
<p>假设我们的临界区在一个内核已经开启SMP和可抢占的SMP机器上</p>
<p>In the scenarios discussed so far, the spinlock primitives have done little other than enable and disable preemption and interrupts. The actual lock features have been compiled away.</p>
<p>到目前为止讨论的场景中, 自旋锁原语除了启用和禁用抢占和中断之外, 没有做什么。实际上锁的功能已被编译成汇编了。</p>
<p>In the presence of SMP, the actual locking logic gets compiled in, and the spinlock primitives are rendered SMP-safe. The SMP-enabled semantics is:</p>
<p>在SMP的机器上，锁的实现逻辑是通过编译器实现的，自旋锁原语提供了SMP安全，启用SMP的语义是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Point A:</div><div class="line"> * Save interrupt state on the local CPU</div><div class="line"> * Disable interrupts on the local CPU</div><div class="line"> * Disable preemption</div><div class="line"> * Lock the section to regulate access by other CPUs</div><div class="line"> */	</div><div class="line">spin_lock_irqsave (&amp;mylock, flags);</div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Enable preemption. Restore interrupt state to what </div><div class="line"> * it was at Point A for the local CPU.</div><div class="line"> * Release the lock.</div><div class="line"> */</div><div class="line">spin_unlock_irqrestore (&amp;mylock, flags);</div></pre></td></tr></table></figure>
<p>In the SMP case, only interrupts in the local CPU are disabled when the lock is acquired. If interrupts are not disabled in the local CPU, a deadlock might arise if an interrupt is generated while execution is in the middle of a critical section. (The interrupt handler sits in a tight spin, waiting for the lock to become available, but the critical section cannot complete until the interrupt handler itself finishes execution.) However, this danger of deadlock does not arise for interrupts generated on other CPUs, since an interrupt handler executing on processor A doesn’t prevent process context code on processor B from executing. The interrupt handler on processor A spins, waiting until processor B exits the critical section.</p>
<p>在SMP的情况下，当锁获取后只有当前CPU的中断会被禁用。如果当前CPU的中断没有被禁用，在执行临界区时产生另一个中断可能会产生一个死锁。(中断处理程序会处于紧急旋转状态，一直等待之前的锁被释，但是之前的临界区一直等着现有的中断程序处理的返回)。然而，在其它CPU上产生的中断不会出现死锁的危险，当一个中断程序在processor A上执行时不会阻止进程上下文的代码在processor B上的执行。中断处理程序在processor A一直旋转直到processor B离开临界区。</p>
<p>The kernel has specialized locking primitives in its repertoire that help improve performance under specific conditions. Using a mutual exclusion scheme tailored to your needs will make your code more powerful. Let’s take a look at some of the specialized exclusion mechanisms.</p>
<p>内核指令里有专门的锁定原语，在特定的条件下帮你提升性能。根据你的需要来使用一个互斥方案会使你的代码更加强大。让我们来看一些互斥机制。</p>
<h5 id="Atomic-Operators"><a href="#Atomic-Operators" class="headerlink" title="Atomic Operators"></a>Atomic Operators</h5><p>Atomic operators are used to perform lightweight operations like bumping counters, conditional increments, and setting bit positions, in one shot. Atomic operations are guaranteed to be serialized and do not need locks for protection against concurrent access. The implementation of atomic operators is architecture-dependent.</p>
<p>原子操作被用作执行一些轻微的动作，比如:碰撞计数、条件增量和设置bit位的位置.简而言之，原子操作确保有序并且不需要锁来保护并发访问。原子操作的实现是基于系统架构的。</p>
<p>For example, to check whether there are any remaining data references before freeing a kernel network buffer (called an skbuff), the skb_release_data() routine defined in net/core/skbuff.c does the following:</p>
<p>举个例子，用来检查是否有剩余的数据引用在内核释放网络缓冲(被称为<code>skbuff</code>)的数据,skb_release_data()函数的实现在<code>net/core/skbuff.c</code>里，内容如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!skb-&gt;cloned ||</div><div class="line">    <span class="comment">/* Atomically decrement and check the reference value */</span></div><div class="line">    atomic_dec_and_test(&amp;(skb_shinfo(skb)-&gt;dataref))) &#123;</div><div class="line">    <span class="comment">/* ... */</span>    </div><div class="line">    kfree(skb-&gt;head);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While skb_release_data() is thus executing, another thread using the skbuff_clone() function (defined in the same file), might be simultaneously incrementing the data reference counter:</p>
<p>当<code>skb_release_data()</code>执行时，另一个线程可能同时增加这数据的引用计数通过使用<code>skbuff_clone</code>(在同一个文件中)函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* .. */</span></div><div class="line"></div><div class="line"><span class="comment">/* Atomically bump the reference count */</span></div><div class="line">atomic_inc(&amp;(skb_shinfo(skb)-&gt;dataref));</div><div class="line"></div><div class="line"><span class="comment">/* .. */</span></div></pre></td></tr></table></figure>
<p>The use of atomic operators protects the data reference counter from being trampled by these two threads. It also eliminates the hassle of using locks to protect a single integer variable from concurrent access.<br>The kernel also supports operators like set_bit(), clear_bit(), and test_and_set_bit(), to atomically manipulate a single bit.</p>
<p>使用原子操作保护数据的引用计数被多个线程碰撞。它还消除了使用来锁保护对单个整型变量的并发方问。<br>内核同样支持如:<code>set_bit()、clear_bit()和test_and_set_bit()</code>在一个bit位上执行原子操作</p>
<h5 id="Reader-Write-Locks"><a href="#Reader-Write-Locks" class="headerlink" title="Reader-Write Locks"></a>Reader-Write Locks</h5><p>The reader-writer variant of a spinlock is another specialized concurrency regulation mechanism. If the usage of a critical section is such that separate threads either read or write, but don’t do both, a reader-writer lock is a natural fit.<br>Multiple reader threads are allowed inside a critical region simultaneously. Reader spinlocks are defined as:</p>
<p>自旋锁的一个变种——读写锁是是另外一个特定的并发机制。临界区的使用被分离出读和写的线程，读和写不能同时获得，读写锁是设计巧秒的。<br>多个读线程可以同时在一个临界区。读的自旋锁定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">rwlock_t</span> myrwlock = RW_LOCK_UNLOCKED;</div><div class="line"></div><div class="line"> <span class="comment">/* Acquire reader lock */</span></div><div class="line">read_lock (&amp;myrwlock);   </div><div class="line"></div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release lock */</span></div><div class="line">read_unlock (&amp;myrwlock);</div></pre></td></tr></table></figure>
<p>However, if a writer thread enters a critical section, other reader or writer threads are not allowed inside. To use writer spinlocks, you’d write:</p>
<p>然而，当一个写的线程进入临界区时，其它尝试进入临界区的读或写的线程是不成功的。对写自旋锁的使用，你可能会这样使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">rwlock_t</span> myrwlock = RW_LOCK_UNLOCKED;</div><div class="line"></div><div class="line"><span class="comment">/* Acquire writer lock */</span></div><div class="line">write_lock (&amp;myrwlock);</div><div class="line"></div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release lock */</span></div><div class="line">write_unlock (&amp;myrwlock);</div></pre></td></tr></table></figure>
<p>Look at the Internetwork Packet Exchange (IPX) routing code in net/ipx/ipx_route.c for a real life example of reader-writer spinlock usage. A reader-writer lock called ipx_routes_lock protects the IPX routing table from simultaneous access. Threads that need to look-up the routing table to forward packets don’t have to write to the table and can request reader locks. However, threads that need to add or delete entries from the routing table have to acquire writer locks. This improves performance since there will usually be far more instances of routing table look-ups than routing table updates.<br>Like regular spinlocks, reader-writer locks also have corresponding irq versions, namely, read_lock_irqsave(), read_lock_irqrestore(), write_lock_irqsave(), and write_lock_irqrestore(). The semantics of these functions are similar to that discussed for regular spinlocks.</p>
<p>通过<code>net/ipx/ipx_route.c</code>里面IPX路由代码的实现来体验下读写自旋锁的使用。一个叫ipx_routes_lock的读写锁用来保护IPX路由表的并发访问。线程需要遍历路由表来发送网络包，因为不需要对这路由表写，所以可以请求的是读锁。然而需要新增或删除路由表里面的数据需要获取写锁。这样将对性能有很大的提升，因为会查询路由表的次数会比写的次数多。<br>像常规的自旋锁一样，读写锁一样有相对应的irq版本，叫做<code>read_lock_irqsave(),read_lock_irqrestor(),write_lock_irqsave()和 write_lock_irqrestore()</code>。这些函数的语义和之前讨论的自旋锁用法一样。</p>
<p>Corresponding reader-writer flavors of semaphores are, down_read(), down_write(), up_read(), and up_write().<br>Sequence locks or seqlocks, introduced in the 2.6 kernel, are reader-writer locks where writers are favored over readers. Writer threads do not wait for readers who may be inside a critical section. Because of this, reader threads may discover that their critical section operation has failed, and may need to retry:</p>
<p>相对应的信息量的读写的方式有<code>down_read(),down_write(),up_read()和up_write()</code>。在2.6内核里面介绍的序号锁是写锁比读锁更受欢迎的读写锁。写的线程不需要等待在临界区的读线程。因此，读的线程可以发现他们的临界区操作失败然后可能需要重新获取:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    seq = read_seqbegin (&amp;mylock);</div><div class="line">    <span class="comment">/* ... Critical Section */</span></div><div class="line">&#125; <span class="keyword">while</span> (read_seqtry (&amp;mylock, seq));</div></pre></td></tr></table></figure>
<p>Writers protect critical regions using write_seqlock() and write_sequnlock().<br>The 2.6 kernel introduced another mechanism called Read-Copy Update (RCU) that can yield improved performance in cases where readers far outnumber writers. The basic idea is that reader threads can execute without locking. Writer threads are more complex: each performs update operations on a copy of the data structure and replaces the pointer that readers will see. The original copy is maintained until the next context switch to ensure completion of all ongoing read operations. (Be aware that using RCU is more involved than using the primitives discussed thus far, and should be used only if you are sure that it’s the right tool for the job. There’s ample documentation in the kernel tree in Documentation/RCU/*.)<br>For an example on using RCU, look at fs/dcache.c. In Linux, each file is associated with directory entry information (stored in a structure called dentry), meta data information (stored in an inode), and actual data (stored in data blocks). Each time you operate on a file, the components in the file path are traversed and corresponding dentries are created. The dentries are kept cached in a data structure called the dcache to speed up future operations. At any time, the number of dcache lookups will be much more than dcache updates, so references to the dcache are protected using RCU primitives.</p>
<p>写的线程使用 write_seqlock () 和 write_sequnlock () 保护关键区域。<br>2.6 内核引入了另一个称为读拷贝更新的机制, 在读者远远超过作者的情况下, 可以提高性能。基本思想是, 读取器线程无需锁定即可执行。写线程更为复杂: 每一个都对数据结构的副本执行更新操作, 并替换读者将看到的指针。原始副本一直保持到下一上下文切换, 以确保所有正在进行的读取操作完成。(请注意, 使用RCU比使用上面讨论过的原语更复杂难懂, 只有当您确信它对你正在进行的任务是正确的工具才使用。内核在Documentation/RCU/*中有足够的文件对其说明。<br>举一个使用RCU的例子, 请查看 fs/dcache。在 Linux 中, 每个文件都与目录条目信息 (存储在称为 dentry 的结构中)、元数据信息 (存储在 inode 中) 和实际数据 (存储在数据块中) 相关联。每次对文件进行操作时, 都会遍历文件路径中的组件, 并创建相应的 dentries。dentries 被保存在一个称为 dcache 的数据结构中, 以加速未来的操作。在任何时候, dcache 查找的数量将远远超过 dcache 的更新, 因此对 dcache 的引用是使用协调单位原语进行保护的。</p>
<h5 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h5><p>Concurrency-related problems are generally hard to debug since they are usually difficult to reproduce. It’s a good idea to enable SMP (CONFIG_SMP) and preemption (CONFIG_PREEMPT) while compiling and testing your code, even if your production kernel is going to run on a UP machine with preemption disabled. There is a configuration option under Kernel Hacking called Spinlock Debugging (CONFIG_DEBUG_SPINLOCK) that can help you catch some common spinlock errors. Also, tools like lockmeter (<a href="http://oss.sgi.com/projects/lockmeter/" target="_blank" rel="external">http://oss.sgi.com/projects/lockmeter/</a>) can be used to collect lock-related statistics.<br>The most common concurrency problem occurs when you forget to lock an access to a shared resource. This results in different threads “racing” through that access in an unregulated manner. The problem (called a race condition) may appear in the form of occasional strange code behavior.<br>Another potential problem arises when you miss releasing held locks in certain code paths, resulting in deadlocks. To get a hang of this, consider the following example:</p>
<p>并发相关的问题通常很难调试,因为它们通常很难重现。在编译和测试代码时启用 SMP (CONFIG_SMP) 和抢占 (CONFIG_PREEMPT) 是个好主意，即使你的生产环境内核运行在一个不可中断的单核机器。在内核里面有个叫Spinlock Debugging(CONFIG_DEBUG_SPINLOCK)的配置选项，这个可以帮助你发现一些常见的自旋锁的错误。当然，类似<code>lockmeter</code>(<a href="http://oss.sgi.com/projects/lockmeter/)的工具同样可以用来收集锁信息的信息。" target="_blank" rel="external">http://oss.sgi.com/projects/lockmeter/)的工具同样可以用来收集锁信息的信息。</a></p>
<p>当您忘记锁定对共享资源的访问时, 会发生最常见的并发问题。这种不常规的访问方式会导致不同的线程同步问题。这个问题(数据竞争情况)可能偶尔出现奇奇怪怪的代码行为</p>
<p>另一个潜在的问题是，当你忘记代码中忘记对获得的锁进行释放时，就会导致死锁的问题。为了理解这个，考虑下下面的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Acquire lock */</span></div><div class="line">spin_lock (&amp;mylock);    </div><div class="line"></div><div class="line"><span class="comment">/* ... Critical Section ... */</span></div><div class="line"></div><div class="line"><span class="comment">/* Assume that error is very rare </span></div><div class="line"> *</div><div class="line"> * I forgot to release the lock! </div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (error) &#123;    </div><div class="line">   <span class="keyword">return</span> -EIO; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Release lock */</span></div><div class="line">spin_unlock (&amp;mylock);</div></pre></td></tr></table></figure>
<p>After the occurrence of the error condition, any thread trying to acquire mylock gets deadlocked, and the kernel may freeze.<br>If the problem first manifests months or years after you write the code, it’s that much harder to go back and debug it. To avoid such unpleasant encounters, concurrency logic should be designed systematically at the beginning, when you architect your software.</p>
<p>在error条件判断出现的后面，任一尝试获取锁的线程都会死锁，系统可能会冻结住(死循环了)。如果问题首先体现在编写代码后的几个月或数年, 那么返回并调试它会更加困难。为了避免这种不愉快的遭遇, 在构建软件时, 应该在开始时系统地设计并发逻辑。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/linux-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/linux-thread/" itemprop="url">linux-thread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T14:40:06+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你是否知道进程和线程的关系？是否知道(user/kernel) space thread以及LWP之间的区别和关系。<br>以及操作系统如何调度它们的？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/linux-cpu-core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/linux-cpu-core/" itemprop="url">linux-cpu-core</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T11:44:59+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计算机从单任务到多任务的发展也是对应的CPU的处理能力。现在的系统基本都是多核的系统并有着更高的系统吞吐能力。</p>
<p>平常只是脑海中有这些概念，并没有通过某些方法去论证这些东西。</p>
<p>在linux上面我们所有CPU相关的信息可以在<code>/proc/cpuinfo</code>文件里面可以看到，我们可以看到以下信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查看CPU信息（型号）</span></div><div class="line">[root@<span class="built_in">local</span> ~]<span class="comment"># cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span></div><div class="line">     24         Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</div><div class="line"></div><div class="line"><span class="comment"># 查看物理CPU个数</span></div><div class="line">[root@<span class="built_in">local</span> ~]<span class="comment"># cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l</span></div><div class="line">2</div><div class="line"></div><div class="line"><span class="comment"># 查看每个物理CPU中core的个数(即核数)</span></div><div class="line">[root@<span class="built_in">local</span> ~]<span class="comment"># cat /proc/cpuinfo| grep "cpu cores"| uniq</span></div><div class="line">cpu cores    : 6</div><div class="line"></div><div class="line"><span class="comment"># 查看逻辑CPU的个数</span></div><div class="line">[root@<span class="built_in">local</span> ~]<span class="comment"># cat /proc/cpuinfo| grep "processor"| wc -l</span></div><div class="line">24</div></pre></td></tr></table></figure>
<p><strong>以上各信息有如下关系:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数 </div><div class="line">总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</div></pre></td></tr></table></figure>
<p><span style="color:blue;"><strong>从上面执行的结果来看，证明我使用的cpu有2 * 6 = 12核，每个核有2个超线程，所以有24个逻辑cpu。</strong></span></p>
<p>我们来看各CPU的架构</p>
<p><strong>多个物理CPU，CPU通过总线进行通信，效率比较低，如下：</strong></p>
<p><img src="../../../../images/cpu_single_core.jpg" alt=""></p>
<p><em>多核CPU，不同的核通过L2 cache进行通信，存储和外设通过总线与CPU通信，如下：*</em></p>
<p><img src="../../../../images/cpu_multi_core.jpg" alt=""></p>
<p><strong>多核超线程,每个核有两个逻辑的处理单元，两个核共同分享一个核的资源，如下：</strong></p>
<p><img src="../../../../images/cpu_multi_core_super.jpg" alt=""></p>
<p><a href="http://www.cnblogs.com/bugutian/p/6138880.html" target="_blank" rel="external">参数</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/30/linux-tcp-ip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/30/linux-tcp-ip/" itemprop="url">tcp/ip</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T10:53:32+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于之前所学没有系统性的对网络这块的知识也没个详细学习过程，对于<code>http</code>、<code>tcp/ip</code>这些东西还只是停留在使用层面，但具体对系统是如何实现的原理无所适从。一个东西只要<br>弄清楚原理后，对这东西的使用就如刨丁解牛。</p>
<blockquote>
<p>对一个东西的理解不能停留在表面，也不要感性的理解一个东西，我们需要看到一个东西<br>本质</p>
</blockquote>
<p>我们平常生活中用电脑、手机很方便的上网或和它人聊天，这里就用到一些类似http、tcp等<br>技术实现，不同电脑或手机能识别其它设备发过来的东西要利益于互联网以及很早以前制订的<br>OSI模型。</p>
<blockquote>
<p>国际标准化组织ISO在1979年建立了一个分委员会来专门研究一种用于开放系统的体系结构，<br>提出了开放系统互连OSI模型，这是一个定义连接异种计算机的标准主体结构。</p>
</blockquote>
<p><img src="../../../../images/osi_layer.png" alt="flow"></p>
<p><img src="../../../../images/osi_protocol.png" alt="flow"></p>
<p>下面是自己根据现实实际情况非官方的语言版的理解:</p>
<ul>
<li><p>物理层<br>相对于接收数据而言，是把发过来的信号转成机器识别的数据<br>相对于发送数据来说，是把数据转化成信号在线路上传递。<br><strong>也就是说设备之间沟通的第一个媒介及其连接</strong></p>
</li>
<li><p>数据链路层</p>
</li>
</ul>
<p>相对于维护网络中需要通信的一条路，用来传递数据，只是这个数据是以帧来定义</p>
<ul>
<li>网络层</li>
</ul>
<p>这层标识了网络中两个实体的数据用的什么协议从哪里到哪里。</p>
<ul>
<li>传输层</li>
</ul>
<p>数据的包的传送，保证消息的有序性，你抓包看到的seq ack等.我们平常用read读和写在这层</p>
<ul>
<li>会话层</li>
</ul>
<p>也不知道怎么描述</p>
<ul>
<li>表示层</li>
</ul>
<p>主要定义数据格式以及加密</p>
<ul>
<li>应用层</li>
</ul>
<p>http、telnet等都是实现了应用层</p>
<h3 id="网络数据流向"><a href="#网络数据流向" class="headerlink" title="网络数据流向"></a>网络数据流向</h3><p>一个网络数据包会经过多层路由器转发，所以下图是一个包从一个机器发出到达另外一台机器的示意图</p>
<p><img src="../../../../images/data_flow.jpg" alt="flow"></p>
<h3 id="TCP简述"><a href="#TCP简述" class="headerlink" title="TCP简述"></a>TCP简述</h3><p>大家都知道tcp是一个面向连接的，可靠的，基于字节流的位于传输层的通信协议。</p>
<p><img src="../../../../images/protocol-stack.jpg" alt="flow"></p>
<p><img src="../../../../images/tcp-ip.png" alt="flow"></p>
<p><img src="../../../../images/tcp_header.png" alt="flow"></p>
<p> 其中不携带选项的TCP头如下图所示(其中阴影部分的四个字段表示了相反方向的数据流信息)，其中header length字段由4比特构成，最大为15，单位是32比特(32-bit word)，即头长的最大值为15*32 bits = 60bytes，因此上面说携带选项的TCP头长最长为60bytes。</p>
<p><img src="../../../../images/tcpdump.png" alt="flow"></p>
<p>根据上面的图，tcp_header以及tcpdump日志截图，我们可以知道内部的一些实现</p>
<p>上图中有几个字段需要重点介绍下：<br>  （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>  （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。<br>  （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<br>  （A）URG：紧急指针（urgent pointer）有效。<br>  （B）ACK：确认序号有效。<br>  （C）PSH：接收方应该尽快将这个报文交给应用层。<br>  （D）RST：重置连接。<br>  （E）SYN：发起一个新连接。<br>  （F）FIN：释放一个连接。</p>
<p>通过tcpdump日志的截图我们发现，回包的ACK都是发送方SEQ+1是告诉发送方你下次包的序号是ACK代码的</p>
<p><img src="http://www.cnblogs.com/lshs/p/6038458.html" alt="参考"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/28/部署脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/28/部署脚本/" itemprop="url">部署脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-28T15:55:54+08:00">
                2017-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/脚本/" itemprop="url" rel="index">
                    <span itemprop="name">脚本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发工作做好后，我们经常要发布到其它的服务器上，外网的服务器配置是不一样。<br>所以我们把配置做成模版是有必要的，把需要变更部分用脚本把它替换掉。</p>
<p>有时间也学习<code>python</code>脚本，<code>python</code>脚本现在都成<code>linux</code>标配脚本了，这是一门很<br>强大的脚本语言。</p>
<blockquote>
<p>既然现在用的<code>markdown</code>生成的<code>html</code>都不支持<code>shell</code>高亮，只支持<code>bash</code></p>
</blockquote>
<p><strong>模版变量:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># 这里的变量用于替换模版配置需要替换的值</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line"><span class="comment"># 游戏服ip</span></div><div class="line">GAME_IP=<span class="string">"127.0.0.1"</span></div><div class="line"><span class="comment"># 游戏服端口</span></div><div class="line">GAME_PORT=<span class="string">":7206"</span></div><div class="line"><span class="comment"># 游戏服地址</span></div><div class="line">GAME_HOST=<span class="string">"<span class="variable">$&#123;GAME_IP&#125;</span><span class="variable">$&#123;GAME_PORT&#125;</span>"</span></div><div class="line"><span class="comment"># 大厅IP地址(只有IP)</span></div><div class="line">HALL_IP=<span class="string">"127.0.0.1"</span></div><div class="line"><span class="comment"># 网关地址</span></div><div class="line"></div><div class="line">GATEWAY_HOST=<span class="string">"127.0.0.1:7208"</span></div><div class="line"></div><div class="line"><span class="comment"># 数据库连接</span></div><div class="line">DB_HOST=<span class="string">"postgres://postgres:qingyuan,123@192.168.1.1.123:5432/platform_test?sslmode=disable"</span></div><div class="line"><span class="comment"># redis服务器</span></div><div class="line">REDIS_HOST=<span class="string">"39.108.10.12:26310"</span></div><div class="line"><span class="comment"># redis密码</span></div><div class="line">REDIS_PASSWD=<span class="string">"af623spo"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 七牛回放文件的存放目录</span></div><div class="line">QINIU_DIR=<span class="string">"playback_dev"</span></div><div class="line"></div><div class="line"><span class="comment"># 微信订单回调配置</span></div><div class="line">NOTIFYURL=<span class="string">"http://127.0.0.1:8090/paynotify"</span></div><div class="line"></div><div class="line"><span class="comment"># 统计服地址</span></div><div class="line">ROUNDPATH=<span class="string">"rank/rankRoundDev"</span>       <span class="comment">#局数榜的7牛地址  默认为rank/rankRound</span></div><div class="line">CHARGEPATH=<span class="string">"rank/rankChargeDev"</span>      <span class="comment">#充值榜的7牛地址  默认为rank/rankCharge</span></div><div class="line"></div><div class="line"><span class="comment"># 声明一个键值对数组</span></div><div class="line"><span class="built_in">declare</span> -A STR_ARR</div><div class="line">STR_ARR=([DB_HOST]=<span class="variable">$&#123;DB_HOST&#125;</span> [REDIS_HOST]=<span class="variable">$&#123;REDIS_HOST&#125;</span> [REDIS_PASSWD]=<span class="variable">$&#123;REDIS_PASSWD&#125;</span> \</div><div class="line">         [HALL_IP]=<span class="variable">$&#123;HALL_IP&#125;</span> [GATEWAY_HOST]=<span class="variable">$&#123;GATEWAY_HOST&#125;</span> [GAME_PORT]=<span class="variable">$&#123;GAME_PORT&#125;</span> \</div><div class="line">          [GAME_HOST]=<span class="variable">$&#123;GAME_HOST&#125;</span>  [QINIU_DIR]=<span class="variable">$&#123;QINIU_DIR&#125;</span> [NOTIFYURL]=<span class="variable">$&#123;NOTIFYURL&#125;</span> \</div><div class="line">           [ROUNDPATH]=<span class="variable">$&#123;ROUNDPATH&#125;</span> [CHARGEPATH]=<span class="variable">$&#123;CHARGEPATH&#125;</span> )</div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!STR_ARR[*]&#125;</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;key&#125;</span>   -----&gt; <span class="variable">$&#123;STR_ARR[$key]&#125;</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p><strong>替换模版的脚本:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">CUR_DIR=$(dirname $(readlink <span class="_">-f</span> <span class="variable">$0</span>))</div><div class="line"></div><div class="line"><span class="comment"># 用模版文件生成FILES里面的配置</span></div><div class="line"></div><div class="line">COLOR_RED=<span class="string">'\033[0;31m'</span></div><div class="line">COLOR_GREEN=<span class="string">'\033[0;32m'</span></div><div class="line">COLOR_RESET=<span class="string">'\033[0m'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="variable">$CUR_DIR</span>/public_conf.sh ]; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"<span class="variable">$COLOR_RED</span>  file <span class="variable">$CUR_DIR</span>/public_conf.sh not exit <span class="variable">$COLOR_RESET</span>"</span></div><div class="line">    <span class="built_in">exit</span> 2</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">source</span> <span class="variable">$CUR_DIR</span>/public_conf.sh</div><div class="line"></div><div class="line"><span class="built_in">read</span> -p <span class="string">"请确认下是否正确，确认输入 yes : "</span> var</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$var</span>"</span> ] || [ <span class="string">"<span class="variable">$var</span>"</span>x != <span class="string">"yes"</span>x ] ; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"<span class="variable">$COLOR_RED</span> 错误的输入:<span class="variable">$var</span> <span class="variable">$COLOR_RESET</span>"</span></div><div class="line">    <span class="built_in">exit</span> 3</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line">FILES=(</div><div class="line">    config.toml \</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">copyFile</span></span>()&#123;</div><div class="line">    file=<span class="variable">$1</span></div><div class="line">    name=<span class="variable">$&#123;file%%.*&#125;</span></div><div class="line">    <span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$file</span>"</span> ]; <span class="keyword">then</span></div><div class="line">        cp <span class="_">-f</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$&#123;name&#125;</span>_template.toml"</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$file</span>"</span></div><div class="line">        <span class="keyword">if</span> [ <span class="variable">$file</span> == <span class="string">"config.toml"</span> ]; <span class="keyword">then</span></div><div class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!STR_ARR[*]&#125;</span></div><div class="line">            <span class="keyword">do</span></div><div class="line">                sed -i <span class="string">"s#<span class="variable">$&#123;key&#125;</span>#<span class="variable">$&#123;STR_ARR[$key]&#125;</span>#g"</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$file</span>"</span></div><div class="line">            <span class="keyword">done</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;FILES[*]&#125;</span> ; <span class="keyword">do</span></div><div class="line">  copyFile <span class="variable">$file</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/malloc/" itemprop="url">malloc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T13:35:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存管理转载"><a href="#内存管理转载" class="headerlink" title="内存管理转载"></a>内存管理转载</h3><p>一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。<br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">原文</a></p>
<div class="entry-content"><br><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/htvm3.png" alt="Hack the VM!" scale="0"></p><br><p>This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.</p><br><p>If you missed the previous chapters, you should probably start there:</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br></ul><br><h2>The heap</h2><br><p>In this chapter we will look at the heap and <code>malloc</code> in order to answer some of the questions we ended with at the end of the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>:</p><br><ul><br><li>Why doesn’t our allocated memory start at the very beginning of the heap (0x2050010 vs 02050000)? What are those first 16 bytes used for?</li><br><li>Is the heap actually growing upwards?</li><br></ul><br><h2>Prerequisites</h2><br><p>In order to fully understand this article, you will need to know:</p><br><ul><br><li>The basics of the C programming language (especially pointers)</li><br><li>The very basics of the Linux filesystem and the shell</li><br><li>We will also use the <code>/proc/[pid]/maps</code> file (see <code>man proc</code> or read our first article <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory, chapter 0: C strings &amp; /proc</a>)</li><br></ul><br><h2>Environment</h2><br><p>All scripts and programs have been tested on the following system:</p><br><ul><br><li>Ubuntu<br><ul><br><li>Linux ubuntu 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</li><br></ul><br></li><br></ul><br><p>Tools used:</p><br><ul><br><li>gcc<br><ul><br><li>gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4</li><br></ul><br></li><br><li>glibc 2.19 (see <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break/version.c" target="_blank" rel="external">version.c</a> if you need to check your glibc version)</li><br><li>strace<br><ul><br><li>strace — version 4.8</li><br></ul><br></li><br></ul><br><p><strong>Everything we will write will be true for this system/environment, but may be different on another system</strong></p><br><p>We will also go through the Linux source code. If you are on Ubuntu, you can download the sources of your current kernel by running this command:</p><br><pre><code>apt-get source linux-image-$(uname -r)<br></code></pre><br><h2><code>malloc</code></h2><br><p><code>malloc</code> is the common function used to dynamically allocate memory. This memory is allocated on the “heap”.<br><br><em>Note: <code>malloc</code> is not a system call.</em></p><br><p>From <code>man malloc</code>:</p><br><pre><code>[…] allocate dynamic memory[…]<br>void <em>malloc(size_t size);<br>[…]<br>The malloc() function allocates size bytes and returns a pointer to the allocated memory.<br></em></code></pre><br><h3>No malloc, no [heap]</h3><br><p>Let’s look at memory regions of a process that does not call <code>malloc</code> (<code>0-main.c</code>).</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <stdio.h>;<br><br>/**
  main - do nothing<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br><br></em></stdio.h></stdlib.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 0-main.c -o 0<br>julien@holberton:~/holberton/w/hackthevm3$ ./0<br><br></code></pre><br><p><em>Quick reminder (1/3): the memory regions of a process are listed in the <code>/proc/[pid]/maps</code> file. As a result, we first need to know the PID of the process. That is done using the <code>ps</code> command; the second column of <code>ps aux</code> output will give us the PID of the process. Please read <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">chapter 0</a> to learn more.</em></p><br><pre><code>julien@holberton:/tmp$ ps aux | grep \ ./0$<br>julien     3638  0.0  0.0   4200   648 pts/9    S+   12:01   0:00 ./0<br></code></pre><br><p><em>Quick reminder (2/3): from the above output, we can see that the PID of the process we want to look at is <code>3638</code>. As a result, the <code>maps</code> file will be found in the directory <code>/proc/3638</code>.</em></p><br><pre><code>julien@holberton:/tmp$ cd /proc/3638<br></code></pre><br><p><em>Quick reminder (3/3): The <code>maps</code> file contains the memory regions of the process. The format of each line in this file is:<br><br>address           perms offset  dev   inode       pathname</em></p><br><pre><code>julien@holberton:/proc/3638$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00600000-00601000 r–p 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00601000-00602000 rw-p 00001000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>7f38f87d7000-7f38f8991000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8991000-7f38f8b91000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b91000-7f38f8b95000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b95000-7f38f8b97000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b97000-7f38f8b9c000 rw-p 00000000 00:00 0<br>7f38f8b9c000-7f38f8bbf000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8da3000-7f38f8da6000 rw-p 00000000 00:00 0<br>7f38f8dbb000-7f38f8dbe000 rw-p 00000000 00:00 0<br>7f38f8dbe000-7f38f8dbf000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dbf000-7f38f8dc0000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dc0000-7f38f8dc1000 rw-p 00000000 00:00 0<br>7ffdd85c5000-7ffdd85e6000 rw-p 00000000 00:00 0                          [stack]<br>7ffdd85f2000-7ffdd85f4000 r–p 00000000 00:00 0                          [vvar]<br>7ffdd85f4000-7ffdd85f6000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/3638$<br></code></pre><br><p><em>Note: <code>hackthevm3</code> is a symbolic link to <code>hack_the_virtual_memory/03. The Heap/</code></em></p><br><p>-&gt;; As we can see from the above maps file, there’s no [heap] region allocated.</p><br><h3><code>malloc(x)</code></h3><br><p>Let’s do the same but with a program that calls <code>malloc</code> (<code>1-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - 1 call to malloc<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    malloc(1);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 1-main.c -o 1<br>julien@holberton:~/holberton/w/hackthevm3$ ./1<br><br></code></pre><br><pre><code>julien@holberton:/proc/3638$ ps aux | grep \ ./1$<br>julien     3718  0.0  0.0   4332   660 pts/9    S+   12:09   0:00 ./1<br>julien@holberton:/proc/3638$ cd /proc/3718<br>julien@holberton:/proc/3718$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00600000-00601000 r–p 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00601000-00602000 rw-p 00001000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>01195000-011b6000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3718$<br></code></pre><br><p>-&gt;; the [heap] is here.</p><br><p>Let’s check the return value of <code>malloc</code> to make sure the returned address is in the heap region (<code>2-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - prints the malloc returned address<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br><br>    p = malloc(1);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 2-main.c -o 2<br>julien@holberton:~/holberton/w/hackthevm3$ ./2<br>0x24d6010<br><br></code></pre><br><pre><code>julien@holberton:/proc/3718$ ps aux | grep \ ./2$<br>julien     3834  0.0  0.0   4336   676 pts/9    S+   12:48   0:00 ./2<br>julien@holberton:/proc/3718$ cd /proc/3834<br>julien@holberton:/proc/3834$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00600000-00601000 r–p 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00601000-00602000 rw-p 00001000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>024d6000-024f7000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3834$<br></code></pre><br><p>-&gt;; <code>024d6000</code> &lt;<code>0x24d6010</code> &lt; <code>024f7000</code></p><br><p>The returned address is inside the heap region. And as we have seen in the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>, the returned address does not start exactly at the beginning of the region; we’ll see why later.</p><br><h2><code>strace</code>, <code>brk</code> and <code>sbrk</code></h2><br><p><code>malloc</code> is a “regular” function (as opposed to a system call), so it must call some kind of syscall in order to manipulate the heap. Let’s use <code>strace</code> to find out.</p><br><p><code>strace</code> is a program used to trace system calls and signals. Any program will always use a few syscalls before your <code>main</code> function is executed. In order to know which syscalls are used by <code>malloc</code>, we will add a <code>write</code> syscall before and after the call to <code>malloc</code>(<code>3-main.c</code>).</p><br><pre><code>#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> main - let’s find out which syscall malloc is using
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC\n”, 14);<br>    p = malloc(1);<br>    write(1, “AFTER MALLOC\n”, 13);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></strong></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 3-main.c -o 3<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./3<br>execve(“./3”, [“./3”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC\n”, 14BEFORE MALLOC<br>)         = 14<br>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br>write(1, “AFTER MALLOC\n”, 13AFTER MALLOC<br>)          = 13<br>…<br>read(0,<br></em></code></pre><br><p>From the above listing we can focus on this:</p><br><pre><code>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br></code></pre><br><p>-&gt;; <code>malloc</code> is using the <code>brk</code> system call in order to manipulate the heap. From <code>brk</code> man page (<code>man brk</code>), we can see what this system call is doing:</p><br><pre><code>…<br>       int brk(void addr);<br>       void *sbrk(intptr_t increment);<br>…<br>DESCRIPTION<br>       brk() and sbrk() change the location of the program  break,  which  defines<br>       the end of the process’s data segment (i.e., the program break is the first<br>       location after the end of the uninitialized data segment).  Increasing  the<br>       program  break has the effect of allocating memory to the process; decreas‐<br>       ing the break deallocates memory.<br><br>       brk() sets the end of the data segment to the value specified by addr, when<br>       that  value  is  reasonable,  the system has enough memory, and the process<br>       does not exceed its maximum data size (see setrlimit(2)).<br><br>       sbrk() increments the program’s data space  by  increment  bytes.   Calling<br>       sbrk()  with  an increment of 0 can be used to find the current location of<br>       the program break.<br></code></pre><br><p>The program break is the address of the first location beyond the current end of the data region of the program in the virual memory.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-before.png" alt="program break before the call to malloc / brk" scale="0"></p><br><p>By increasing the value of the program break, via <code>brk</code> or <code>sbrk</code>, the function <code>malloc</code> creates a new space that can then be used by the process to dynamically allocate memory (using <code>malloc</code>).</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-after.png" alt="program break after the malloc / brk call" scale="0"></p><br><p>So the heap is actually an extension of the data segment of the program.</p><br><p>The first call to <code>brk</code> (<code>brk(0)</code>) returns the current address of the program break to <code>malloc</code>. And the second call is the one that actually creates new memory (since <code>0xe91000</code> &gt;; <code>0xe70000</code>) by increasing the value of the program break. In the above example, the heap is now starting at <code>0xe70000</code> and ends at <code>0xe91000</code>. Let’s double check with the <code>/proc/[PID]/maps</code> file:</p><br><pre><code>julien@holberton:/proc/3855$ ps aux | grep \ ./3$<br>julien     4011  0.0  0.0   4748   708 pts/9    S+   13:04   0:00 strace ./3<br>julien     4014  0.0  0.0   4336   644 pts/9    S+   13:04   0:00 ./3<br>julien@holberton:/proc/3855$ cd /proc/4014<br>julien@holberton:/proc/4014$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00600000-00601000 r–p 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00601000-00602000 rw-p 00001000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/4014$<br></code></pre><br><p>-&gt;; <code>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]</code> matches the pointers returned back to <code>malloc</code> by <code>brk</code>.</p><br><p>That’s great, but wait, why did<code>malloc</code> increment the heap by <code>00e91000</code> – <code>00e70000</code> = <code>0x21000</code> or <code>135168</code> bytes, when we only asked for only 1 byte?</p><br><h2>Many mallocs</h2><br><p>What will happen if we call <code>malloc</code> several times? (<code>4-main.c</code>)</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<br> <em> main - many calls to malloc
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC #0\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #0\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #1\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #1\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #2\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #2\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #3\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #3\n”, 16);<br>    printf(“%p\n”, p);<br><br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 4-main.c -o 4<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./4<br>execve(“./4”, [“./4”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC #0\n”, 17BEFORE MALLOC #0<br>)      = 17<br>brk(0)                                  = 0x1314000<br>brk(0x1335000)                          = 0x1335000<br>write(1, “AFTER MALLOC #0\n”, 16AFTER MALLOC #0<br>)       = 16<br>…<br>write(1, “0x1314010\n”, 100x1314010<br>)             = 10<br>write(1, “BEFORE MALLOC #1\n”, 17BEFORE MALLOC #1<br>)      = 17<br>write(1, “AFTER MALLOC #1\n”, 16AFTER MALLOC #1<br>)       = 16<br>write(1, “0x1314420\n”, 100x1314420<br>)             = 10<br>write(1, “BEFORE MALLOC #2\n”, 17BEFORE MALLOC #2<br>)      = 17<br>write(1, “AFTER MALLOC #2\n”, 16AFTER MALLOC #2<br>)       = 16<br>write(1, “0x1314830\n”, 100x1314830<br>)             = 10<br>write(1, “BEFORE MALLOC #3\n”, 17BEFORE MALLOC #3<br>)      = 17<br>write(1, “AFTER MALLOC #3\n”, 16AFTER MALLOC #3<br>)       = 16<br>write(1, “0x1314c40\n”, 100x1314c40<br>)             = 10<br>…<br>read(0,<br></em></code></pre><br><p>-&gt;; <code>malloc</code> is NOT calling <code>brk</code> each time we call it.</p><br><p>The first time, <code>malloc</code> creates a new space (the heap) for the program (by increasing the program break location). The following times, <code>malloc</code> uses the same space to give our program “new” chunks of memory. Those “new” chunks of memory are part of the memory previously allocated using <code>brk</code>. This way, <code>malloc</code> doesn’t have to use syscalls (<code>brk</code>) every time we call it, and thus it makes <code>malloc</code> – and our programs using <code>malloc</code> – faster. It also allows <code>malloc</code> and <code>free</code> to optimize the usage of the memory.</p><br><p>Let’s double check that we have only one heap, allocated by the first call to <code>brk</code>:</p><br><pre><code>julien@holberton:/proc/4014$ ps aux | grep \ ./4$<br>julien     4169  0.0  0.0   4748   688 pts/9    S+   13:33   0:00 strace ./4<br>julien     4172  0.0  0.0   4336   656 pts/9    S+   13:33   0:00 ./4<br>julien@holberton:/proc/4014$ cd /proc/4172<br>julien@holberton:/proc/4172$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00600000-00601000 r–p 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00601000-00602000 rw-p 00001000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>01314000-01335000 rw-p 00000000 00:00 0                                  [heap]<br>7f4a3f2c4000-7f4a3f47e000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f47e000-7f4a3f67e000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f67e000-7f4a3f682000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f682000-7f4a3f684000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f684000-7f4a3f689000 rw-p 00000000 00:00 0<br>7f4a3f689000-7f4a3f6ac000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f890000-7f4a3f893000 rw-p 00000000 00:00 0<br>7f4a3f8a7000-7f4a3f8ab000 rw-p 00000000 00:00 0<br>7f4a3f8ab000-7f4a3f8ac000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ac000-7f4a3f8ad000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ad000-7f4a3f8ae000 rw-p 00000000 00:00 0<br>7ffd1ba73000-7ffd1ba94000 rw-p 00000000 00:00 0                          [stack]<br>7ffd1bbed000-7ffd1bbef000 r–p 00000000 00:00 0                          [vvar]<br>7ffd1bbef000-7ffd1bbf1000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/4172$<br></code></pre><br><p>-&gt;; We have only one [heap] and the addresses match those returned by <code>sbrk</code>: <code>0x1314000</code> &amp; <code>0x1335000</code></p><br><h2>Naive malloc</h2><br><p>Based on the above, and assuming we won’t ever need to free anything, we can now write our own (naive) version of <code>malloc</code>, that would move the program break each time it is called.</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  malloc - naive version of malloc: dynamically allocates memory on the heap using sbrk<br> <em> @size: number of bytes to allocate                                                          
 </em><br> <em> Return: the memory address newly allocated, or NULL on error                                
 </em><br> <em> Note: don’t do this at home :)                                                              
 </em>/<br>void <em>malloc(size_t size)<br>{<br>    void </em>previous_break;<br><br>    previous_break = sbrk(size);<br>    /<em> check for error </em>/<br>    if (previous_break == (void <em>) -1)<br>    {<br>        /</em> on error malloc returns NULL <em>/<br>        return (NULL);<br>    }<br>    return (previous_break);<br>}<br></em></unistd.h></stdlib.h></code></pre><br><h2>The 0x10 lost bytes</h2><br><p>If we look at the output of the previous program (<code>4-main.c</code>), we can see that the first memory address returned by <code>malloc</code> doesn’t start at the beginning of the heap, but <code>0x10</code> bytes after: <code>0x1314010</code> vs <code>0x1314000</code>. Also, when we call <code>malloc(1024)</code> a second time, the address should be <code>0x1314010</code> (the returned value of the first call to <code>malloc</code>) + <code>1024</code> (or <code>0x400</code> in hexadecimal, since the first call to <code>malloc</code> was asking for <code>1024</code> bytes) = <code>0x1318010</code>. But the return value of the second call to <code>malloc</code> is <code>0x1314420</code>. We have lost <code>0x10</code> bytes again! Same goes for the subsequent calls.</p><br><p>Let’s look at what we can find inside those “lost” <code>0x10</code>-byte memory spaces (<code>5-main.c</code>) and whether the memory loss stays constant:</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  pmem - print mem<br> <em> @p: memory address to start printing from                                                   
 </em> @bytes: number of bytes to print<br> <em>                                                                                             
 </em> Return: nothing<br> <em>/<br>void pmem(void </em>p, unsigned int bytes)<br>{<br>    unsigned char <em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char </em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, <em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/**
 </em> main - the 0x10 lost bytes<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br>    int i;<br><br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1));<br>        printf(“%p\n”, p);<br>        printf(“bytes at %p:\n”, (void </em>)((char <em>)p - 0x10));<br>        pmem((char </em>)p - 0x10, 0x10);<br>    }<br>    return (EXIT_SUCCESS);<br>}<br></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 5-main.c -o 5<br>julien@holberton:~/holberton/w/hackthevm3$ ./5<br>0x1fa8010<br>bytes at 0x1fa8000:<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x1fa8420<br>bytes at 0x1fa8410:<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x1fa8c30<br>bytes at 0x1fa8c20:<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x1fa9840<br>bytes at 0x1fa9830:<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x1faa850<br>bytes at 0x1faa840:<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x1fabc60<br>bytes at 0x1fabc50:<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x1fad470<br>bytes at 0x1fad460:<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x1faf080<br>bytes at 0x1faf070:<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x1fb1090<br>bytes at 0x1fb1080:<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x1fb34a0<br>bytes at 0x1fb3490:<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>There is one clear pattern: the size of the malloc’ed memory chunk is always found in the preceding 0x10 bytes. For instance, the first <code>malloc</code> call is malloc’ing <code>1024</code> (<code>0x0400</code>) bytes and we can find <code>11 04 00 00 00 00 00 00</code> in the preceding <code>0x10</code> bytes. Those last bytes represent the number <code>0x 00 00 00 00 00 00 04 11</code> = <code>0x400</code> (1024) + <code>0x10</code> (the block size preceding those <code>1024</code> bytes + <code>1</code> (we’ll talk about this “+1” later in this chapter). If we look at each <code>0x10</code> bytes preceding the addresses returned by <code>malloc</code>, they all contain the size of the chunk of memory asked to <code>malloc</code> + <code>0x10</code> + <code>1</code>.</p><br><p>At this point, given what we said and saw earlier, we can probably guess that those 0x10 bytes are a sort of data structure used by <code>malloc</code> (and <code>free</code>) to deal with the heap. And indeed, even though we don’t understand everything yet, we can already use this data structure to go from one malloc’ed chunk of memory to the other (<code>6-main.c</code>) as long as we have the address of the beginning of the heap (<em>and as long as we have never called <code>free</code></em>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> pmem - print mem                                                                            
 </em> @p: memory address to start printing from<br> <em> @bytes: number of bytes to print                                                            
 </em><br> <em> Return: nothing                                                                             
 </em>/<br>void pmem(void <em>p, unsigned int bytes)<br>{<br>    unsigned char </em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char <em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, </em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/</strong><br> <em> main - using the 0x10 bytes to jump to next malloc’ed chunks
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br>    int i;<br>    void </em>heap_start;<br>    size_t size_of_the_block;<br><br>    heap_start = sbrk(0);<br>    write(1, “START\n”, 6);<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1)); 
        </em>((int <em>)p) = i;<br>        printf(“%p: [%i]\n”, p, i);<br>    }<br>    p = heap_start;<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        pmem(p, 0x10);<br>        size_of_the_block = </em>((size_t <em>)((char </em>)p + 8)) - 1;<br>        printf(“%p: [%i] - size = %lu\n”,<br>              (void <em>)((char </em>)p + 0x10),<br>              <em>((int </em>)((char <em>)p + 0x10)),<br>              size_of_the_block);<br>        p = (void </em>)((char <em>)p + size_of_the_block);<br>    }<br>    write(1, “END\n”, 4);<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 6-main.c -o 6<br>julien@holberton:~/holberton/w/hackthevm3$ ./6<br>START<br>0x9e6010: [0]<br>0x9e6420: [1]<br>0x9e6c30: [2]<br>0x9e7840: [3]<br>0x9e8850: [4]<br>0x9e9c60: [5]<br>0x9eb470: [6]<br>0x9ed080: [7]<br>0x9ef090: [8]<br>0x9f14a0: [9]<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x9e6010: [0] - size = 1040<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x9e6420: [1] - size = 2064<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x9e6c30: [2] - size = 3088<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x9e7840: [3] - size = 4112<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x9e8850: [4] - size = 5136<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x9e9c60: [5] - size = 6160<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x9eb470: [6] - size = 7184<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x9ed080: [7] - size = 8208<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x9ef090: [8] - size = 9232<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>0x9f14a0: [9] - size = 10256<br>END<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>One of our open questions from the previous chapter is now answered: <code>malloc</code> is using <code>0x10</code> additional bytes for each malloc’ed memory block to store the size of the block.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/0x10-malloc.png" alt="0x10 bytes preceeding malloc" scale="0"></p><br><p>This data will actually be used by <code>free</code> to save it to a list of available blocks for future calls to <code>malloc</code>.</p><br><p>But our study also raises a new question: what are the first 8 bytes of the 16 (<code>0x10</code> in hexadecimal) bytes used for? It seems to always be zero. Is it just padding?</p><br><h3>RTFSC</h3><br><p>At this stage, we probably want to check the source code of <code>malloc</code> to confirm what we just found (<code>malloc.c</code> from the glibc).</p><br><pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">1055 /*</div><div class="line">1056       malloc_chunk details:</div><div class="line">1057    </div><div class="line">1058        (The following includes lightly edited explanations by Colin Plumb.)</div><div class="line">1059    </div><div class="line">1060        Chunks of memory are maintained using a `boundary tag&apos; method as</div><div class="line">1061        described in e.g., Knuth or Standish.  (See the paper by Paul</div><div class="line">1062        Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</div><div class="line">1063        survey of such techniques.)  Sizes of free chunks are stored both</div><div class="line">1064        in the front of each chunk and at the end.  This makes</div><div class="line">1065        consolidating fragmented chunks into bigger chunks very fast.  The</div><div class="line">1066        size fields also hold bits representing whether chunks are free or</div><div class="line">1067        in use.</div><div class="line">1068    </div><div class="line">1069        An allocated chunk looks like this:</div><div class="line">1070    </div><div class="line">1071    </div><div class="line">1072        chunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1073                |             Size of previous chunk, if unallocated (P clear)  |</div><div class="line">1074                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1075                |             Size of chunk, in bytes                     |A|M|P|</div><div class="line">1076          mem-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1077                |             User data starts here...                          .</div><div class="line">1078                .                                                               .</div><div class="line">1079                .             (malloc_usable_size() bytes)                      .</div><div class="line">1080                .                                                               |</div><div class="line">1081    nextchunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1082                |             (size of chunk, but used for application data)    |</div><div class="line">1083                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1084                |             Size of next chunk, in bytes                |A|0|1|</div><div class="line">1085                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1086    </div><div class="line">1087        Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</div><div class="line">1088        the malloc code, but &quot;mem&quot; is the pointer that is returned to the</div><div class="line">1089        user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</div><div class="line">```&lt;/pre&gt;</div><div class="line">&lt;p&gt;-&gt;; We were correct \o/. Right before the address returned by &lt;code&gt;malloc&lt;/code&gt; to the user, we have two variables:&lt;/p&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">&lt;li&gt;Size of previous chunk, if unallocated: we never free’d any chunks so that is why it was always 0&lt;/li&gt;</div><div class="line">&lt;li&gt;Size of chunk, in bytes&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;p&gt;Let’s free some chunks to confirm that the first 8 bytes are used the way the source code describes it (&lt;code&gt;7-main.c&lt;/code&gt;):&lt;/p&gt;</div><div class="line">&lt;pre&gt;</div><div class="line">```C</div><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - confirm the source code</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">        printf(&quot;%p\n&quot;, p);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8)) - 1;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk, size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 7-main.c -o 7<br>julien@holberton:~/holberton/w/hackthevm3$ ./7<br>0x1536010<br>0x1536420<br>0x1536c30<br>0x1537840<br>0x1538850<br>0x1539c60<br>0x153b470<br>0x153d080<br>0x153f090<br>0x15414a0<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1536000, size = 1040, prev = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1536410, size = 2064, prev = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1536c20, size = 3088, prev = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1537830, size = 4112, prev = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1538840, size = 5135, prev = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1539c50, size = 6160, prev = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x153b460, size = 7184, prev = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x153d070, size = 8208, prev = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x153f080, size = 9231, prev = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x1541490, size = 10256, prev = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>As we can see from the above listing, when the previous chunk has been free’d, the malloc chunk’s first 8 bytes contain the size of the previous unallocated chunk. So the correct representation of a malloc chunk is the following:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/malloc-chunk.png" alt="malloc chunk" scale="0"></p><br><p>Also, it seems that the first bit of the next 8 bytes (containing the size of the current chunk) serves as a flag to check if the previous chunk is used (<code>1</code>) or not (<code>0</code>). So the correct updated version of our program should be written this way (<code>8-main.c</code>):</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - updating with correct checks</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8));</div><div class="line">        prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">        size_of_the_chunk -= prev_used;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev (%s) = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk,</div><div class="line">              (prev_used? &quot;allocated&quot;: &quot;unallocated&quot;), size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 8-main.c -o 8<br>julien@holberton:~/holberton/w/hackthevm3$ ./8<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1031000, size = 1040, prev (allocated) = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1031410, size = 2064, prev (allocated) = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1031c20, size = 3088, prev (allocated) = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1032830, size = 4112, prev (allocated) = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1033840, size = 5136, prev (unallocated) = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1034c50, size = 6160, prev (allocated) = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x1036460, size = 7184, prev (allocated) = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x1038070, size = 8208, prev (allocated) = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x103a080, size = 9232, prev (unallocated) = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x103c490, size = 10256, prev (allocated) = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><h2>Is the heap actually growing upwards?</h2><br><p>The last question left unanswered is: “Is the heap actually growing upwards?”. From the <code>brk</code> man page, it seems so:</p><br><pre><code>DESCRIPTION<br>       brk() and sbrk() change the location of the program break, which defines the end  of  the<br>       process’s  data  segment  (i.e., the program break is the first location after the end of<br>       the uninitialized data segment).  Increasing the program break has the effect of allocat‐<br>       ing memory to the process; decreasing the break deallocates memory.<br></code></pre><br><p>Let’s check! (<code>9-main.c</code>)</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    write(1, &quot;START\n&quot;, 6);</div><div class="line">    malloc(1);</div><div class="line">    getchar();</div><div class="line">    write(1, &quot;LOOP\n&quot;, 5);</div><div class="line">    for (i = 0; i &lt; 0x25000 / 1024; i++)</div><div class="line">    &#123;</div><div class="line">        malloc(1024);</div><div class="line">    &#125;</div><div class="line">    write(1, &quot;END\n&quot;, 4);</div><div class="line">    getchar();</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>Now let’s confirm this assumption with strace:</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ strace ./9<br>execve(“./9”, [“./9”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “START\n”, 6START<br>)                  = 6<br>brk(0)                                  = 0x1fd8000<br>brk(0x1ff9000)                          = 0x1ff9000<br>…<br>write(1, “LOOP\n”, 5LOOP<br>)                   = 5<br>brk(0x201a000)                          = 0x201a000<br>write(1, “END\n”, 4END<br>)                    = 4<br>…<br>julien@holberton:~/holberton/w/hackthevm3$<br></em></code></pre><br><p>clearly, <code>malloc</code> made only two calls to <code>brk</code> to increase the allocated space on the heap. And the second call is using a higher memory address argument (<code>0x201a000</code> &gt;; <code>0x1ff9000</code>). The second syscall was triggered when the space on the heap was too small to host all the malloc calls.</p><br><p>Let’s double check with <code>/proc</code>.</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 9-main.c -o 9<br>julien@holberton:~/holberton/w/hackthevm3$ ./9<br>START<br><br></code></pre><br><pre><code>julien@holberton:/proc/7855$ ps aux | grep \ ./9$<br>julien     7972  0.0  0.0   4332   684 pts/9    S+   19:08   0:00 ./9<br>julien@holberton:/proc/7855$ cd /proc/7972<br>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>Let’s hit Enter and look at the [heap] again:</p><br><pre><code>LOOP<br>END<br><br></code></pre><br><pre><code>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>The beginning of the heap is still the same, but the size has increased upwards from <code>00922000</code> to <code>00943000</code>.</p><br><h2>The Address Space Layout Randomisation (ASLR)</h2><br><p>You may have noticed something “strange” in the <code>/proc/pid/maps</code> listing above, that we want to study:</p><br><p>The program break is the address of the first location beyond the current end of the data region – so the address of the first location beyond the executable in the virtual memory. As a consequence, the heap should start right after the end of the executable in memory. As you can see in all above listing, it is NOT the case. The only thing that is true is that the heap is always the next memory region after the executable, which makes sense since the heap is actually part of the data segment of the executable itself. Also, if we look even closer, the memory gap size between the executable and the heap is never the same:</p><br><p><em>Format of the following lines: [PID of the above <code>maps</code> listings]: address of the beginning of the [heap] – address of the end of the executable = memory gap size</em></p><br><ul><br><li>[3718]: 01195000 – 00602000 = b93000</li><br><li>[3834]: 024d6000 – 00602000 = 1ed4000</li><br><li>[4014]: 00e70000 – 00602000 = 86e000</li><br><li>[4172]: 01314000 – 00602000 = d12000</li><br><li>[7972]: 00901000 – 00602000 = 2ff000</li><br></ul><br><p>It seems that this gap size is random, and indeed, it is. If we look at the ELF binary loader source code (<code>fs/binfmt_elf.c</code>) we can find this:</p><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">if</span> ((current-&gt;;flags &amp;amp; PF_RANDOMIZE) &amp;amp;&amp;amp; (randomize_va_space &gt;; <span class="number">1</span>)) &#123;</div><div class="line">                current-&gt;;mm-&gt;;brk = current-&gt;;mm-&gt;;start_brk =</div><div class="line">                        arch_randomize_brk(current-&gt;;mm);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> compat_brk_randomized</span></div><div class="line">                current-&gt;;brk_randomized = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div></pre></td></tr></table></figure><br><br><p>where <code>current-&gt;;mm-&gt;;brk</code> is the address of the program break. The <code>arch_randomize_brk</code> function can be found in the <code>arch/x86/kernel/process.c</code> file:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_randomize_brk</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> range_end = mm-&gt;;brk + <span class="number">0x02000000</span>;</div><div class="line">        <span class="keyword">return</span> randomize_range(mm-&gt;;brk, range_end, <span class="number">0</span>) ? : mm-&gt;;brk;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>The <code>randomize_range</code> returns a start address such that:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  [...... &lt;range&gt;; .....]</div><div class="line">start                  end</div></pre></td></tr></table></figure><br><br><p>Source code of the <code>randomize_range</code> function (<code>drivers/char/random.c</code>):</p><br><pre><code class="C">/<br> <em> randomize_range() returns a start address such that
 </em><br> <em>    […… <range>; …..]
 </range></em>  start                  end<br> <em>
 </em> a <range>; with size “len” starting at the return value is inside in the<br> <em> area defined by [start, end], but is otherwise randomized.
 </em>/<br>unsigned long<br>randomize_range(unsigned long start, unsigned long end, unsigned long len)<br>{<br>        unsigned long range = end - len - start;<br><br>        if (end &lt;= start + len)<br>                return 0;<br>        return PAGE_ALIGN(get_random_int() % range + start);<br>}<br></range></code></pre><br><p>As a result, the offset between the data section of the executable and the program break initial position when the process runs can have a size of anywhere between <code>0</code> and <code>0x02000000</code>. This randomization is known as Address Space Layout Randomisation (ASLR). ASLR is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the positions of the heap and the stack.</p><br><h2>The updated VM diagram</h2><br><p>With all the above in mind, we can now update our VM diagram:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/virtual_memory_diagram_v2.png" alt="Virtual memory diagram" scale="0"></p><br><h2><code>malloc(0)</code></h2><br><p>Did you ever wonder what was happening when we call <code>malloc</code> with a size of <code>0</code>? Let’s check! (<code>10-main.c</code>)</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    p = malloc(0);</div><div class="line">    printf(&quot;%p\n&quot;, p);</div><div class="line">    pmem((char *)p - 0x10, 0x10);</div><div class="line">    size_of_the_chunk = *((size_t *)((char *)p - 8));</div><div class="line">    prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">    size_of_the_chunk -= prev_used;</div><div class="line">    printf(&quot;chunk size = %li bytes\n&quot;, size_of_the_chunk);</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 10-main.c -o 10<br>julien@holberton:~/holberton/w/hackthevm3$ ./10<br>0xd08010<br>00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00<br>chunk size = 32 bytes<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>-&gt;; <code>malloc(0)</code> is actually using 32 bytes, including the first <code>0x10</code> bytes.</p><br><p>Again, note that this will not always be the case. From the man page (<code>man malloc</code>):</p><br><pre><code>NULL may also be returned by a successful call to malloc() with a size of zero<br></code></pre><br><h2>Outro</h2><br><p>We have learned a couple of things about malloc and the heap. But there is actually more than <code>brk</code> and <code>sbrk</code>. You can try malloc’ing a big chunk of memory, <code>strace</code> it, and look at <code>/proc</code> to learn more before we cover it in a next chapter <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><p>Also, studying how <code>free</code> works in coordination with <code>malloc</code> is something we haven’t covered yet. If you want to look at it, you will find part of the answer to why the minimum chunk size is <code>32</code> (when we ask <code>malloc</code> for <code>0</code> bytes) vs <code>16</code> (<code>0x10</code> in hexadecimal) or <code>0</code>.</p><br><p>As usual, to be continued! Let me know if you have something you would like me to cover in the next chapter.</p><br><h3>Questions? Feedback?</h3><br><p>If you have questions or feedback don’t hesitate to ping us on Twitter at <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a>.<br><br><em>Haters, please send your comments to <code>/dev/null</code>.</em></p><br><p>Happy Hacking!</p><br><h3>Thank you for reading!</h3><br><p>As always, no-one is perfect (except <a href="http://codesqueeze.com/the-ultimate-top-25-chuck-norris-the-programmer-jokes/" target="_blank" rel="external">Chuck</a> of course), so don’t hesitate to <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc,%20the%20heap%20and%20the%20program%20break/" target="_blank" rel="external">contribute</a> or send me your comments if you find anything I missed.</p><br><h3>Files</h3><br><p><a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/tree/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break" target="_blank" rel="external">This repo</a> contains the source code (<code>naive_malloc.c</code>, <code>version.c</code> &amp; “X-main.c` files) for programs created in this tutorial.</p><br><h3>Read more about the virtual memory</h3><br><p>Follow <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a> on Twitter to get the next chapters!</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br><li>Chapter 3: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank" rel="external">Hack the Virtual Memory: malloc, the heap &amp; the program break</a></li><br></ul><br><p><em>Many thanks to <a href="https://twitter.com/wintermanc3r" target="_blank" rel="external">Tim</a>, <a href="https://twitter.com/1million40" target="_blank" rel="external">Anne</a> and <a href="https://www.linkedin.com/in/iancugniere/" target="_blank" rel="external">Ian</a> for proof-reading!</em> <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><!-- Simple Share Buttons Adder (6.3.4) simplesharebuttons.com --><div class="ssba ssba-wrap"><div style="text-align:left">Sharing is caring<a data-site="reddit" class="ssba_reddit_share" href="http://reddit.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack the Virtual Memory: malloc, the heap &amp; the program break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png" title="Reddit" class="ssba ssba-img" alt="Share on Reddit"></a><a data-site="" class="ssba_twitter_share" href="http://twitter.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;text=Hack+the+Virtual+Memory%3A+malloc%2C+the+heap+%26+the+program+break+" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png" title="Twitter" class="ssba ssba-img" alt="Tweet about this on Twitter"></a><a data-site="" class="ssba_facebook_share" href="http://www.facebook.com/sharer.php?u=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png" title="Facebook" class="ssba ssba-img" alt="Share on Facebook"></a><a data-site="" class="ssba_google_share" href="https://plus.google.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png" title="Google+" class="ssba ssba-img" alt="Share on Google+"></a><a data-site="linkedin" class="ssba_linkedin_share ssba_share_link" href="http://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png" title="LinkedIn" class="ssba ssba-img" alt="Share on LinkedIn"></a><a data-site="digg" class="ssba_diggit_share ssba_share_link" href="http://www.digg.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/diggit.png" title="Digg" class="ssba ssba-img" alt="Digg this"></a><a data-site="stumbleupon" class="ssba_stumbleupon_share ssba_share_link" href="http://www.stumbleupon.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack%20the%20Virtual%20Memory:%20malloc,%20the%20heap%20&amp;%20the%20program%20break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/stumbleupon.png" title="StumbleUpon" class="ssba ssba-img" alt="Share on StumbleUpon"></a></div></div><br>        <div class="clearfix"></div>

<pre><code>&lt;/div&gt;
</code></pre></div>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/13/深入理解Linux中内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/13/深入理解Linux中内存管理/" itemprop="url">深入理解Linux中内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T15:20:08+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><p>平常只是知道一些进程虚拟地址空间的一些概念，并没有深入去理解Linux是如何管理内存了，刚好有时间就研究了下这块的原由。</p>
<p><span style="color: red"><strong>主题:</strong></span>Linux内存管理中的分段和分页技术</p>
<p>回顾一下历史，<span style="color: #0000ff;"><strong>在早期的计算机中，程序是直接运行在物理内存上的。</strong></span>换句话说，就是程序在运行的过程中访问的都是物理地址。</p>
<p>如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。</p>
<p>然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为<span style="color: red">内存管理</span>。</p>
<p>举一个早期的计算机系统中，内存分配管理的例子，以便于理解。</p>
<p>假如我们有三个程序，<span style="color: #993366;"><strong>程序A，B，C，程序A运行的过程中需要<span style="color: #ff6600;">10M</span>内存，程序B运行的过程中需要<span style="color: #ff6600;">100M</span>内存，而程序C运行的过程中需要<span style="color: #ff6600;">20M</span>内存。</strong></span></p>
<p>如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A，接下来的10M-110M分配给B。</p>
<p>这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。</p>
<p>大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。</p>
<p>下面来看看这种内存管理方式存在的几个比较明显的问题。</p>
<h3 id="进程地址空间不能隔离"><a href="#进程地址空间不能隔离" class="headerlink" title="进程地址空间不能隔离"></a>进程地址空间不能隔离</h3><p>由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。</p>
<p>举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以访问系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举地破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。</p>
<h3 id="内存使用的效率低"><a href="#内存使用的效率低" class="headerlink" title="内存使用的效率低　"></a>内存使用的效率低　</h3><p>如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。</p>
<p>这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道<span style="color: #ff6600;"><strong>IO操作比较耗时</strong></span>，所以这个过程效率将会十分低下。</p>
<h3 id="程序运行的地址不能确定"><a href="#程序运行的地址不能确定" class="headerlink" title="程序运行的地址不能确定"></a>程序运行的地址不能确定</h3><p>程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址，如果有不明白童鞋可以去查查编译原理方面的资料。</p>
<p><span style="color: #0000ff;"><strong>　　</strong><strong>内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？</strong></span></p>
<p>引用计算机界一句无从考证的名言：<span style="color: #993366;"><strong>计算机系统里的任何问题都可以靠引入一个中间层来解决</strong></span></p>
<p>现在的内存管理方法就是在程序和物理内存之间引入了<span style="color:red">虚拟内存</span>这个概念。</p>
<p><ol></ol></p>
<p><li><span style="color: #008080;"><strong>虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。</strong></span></li></p>
<p><li>每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。</li></p>
<p><li>顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。</li><br><br>既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。</p>
<h2 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h2><p>这种方法是人们最开始使用的一种方法，基本思路是<span style="color: #ff0000;"><strong>将程序所需要的内存地址空间大小的虚拟空间映射到某个物理地址空间。</strong></span></p>
<p><img src="memory_segmentation.jpg"></p>
<p><span style="color: #993366;"><strong>每个程序都有其独立的虚拟的独立的进程地址空间</strong></span>可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。</p>
<p>这种<span style="color: #ff6600;"><strong>分段的机制解决了开始提到的3个问题中的进程地址空间隔离和程序地址重定位的问题。</strong></span></p>
<p>程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。</p>
<p>无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。　　　</p>
<p>因为<span style="color: #008080;"><strong>这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。</strong></span></p>
<p>那么，怎么才算高效率的内存使用呢。事实上，<span style="color: #993366;"><strong>根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。</strong></span></p>
<p>所以我们需要更加小粒度的内存分割和映射方法，此时是否会想到Linux中的Buddy算法和slab内存分配机制呢。另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。</p>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p><span style="color: #0000ff;"><strong>分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。</strong></span></p>
<p>试想一下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999字节是不是浪费了。所以需要更加细粒度的磁盘分割方式，我们可以将Block设置得小一点，这当然是根据所存放文件的大小来综合考虑的，好像有点跑题了，我只是想说，内存中的分页机制跟ext文件系统中的磁盘分割机制非常相似。</p>
<p><span style="color: #993366;"><strong>Linux中一般页的大小是4KB</strong></span>我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，我们还是以一个例子来说明,如下图：</p>
<p><img src="memory_page.jpg"></p>
<p>可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行)，甚至他们共用了一部分物理地址空间，这就是<span stlye="color:red">共享内存</span>。</p>
<p>进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个<span style="color: #0000ff;"><strong>缺页异常</strong></span>，然后异常管理程序会将其读到内存中。</p>
<p>这就是<span style="color: #ff0000;"><strong>分页机制的原理</strong></span>，当然Linux中的分页机制的实现还是比较复杂的，通过了页全局目录，页上级目录，页中级目录，页表等几级的分页机制来实现的，但是基本的工作原理是不会变的。</p>
<p>分页机制的实现需要硬件的实现，这个硬件名字叫做<span style="color: #993366;"><strong>MMU</strong></span>(Memory Management Unit)，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。</p>
<p><a href="http://www.cnblogs.com/lcw/p/3505503.html" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/ky_heart/article/details/51865526" target="_blank" rel="external">重定位</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/12/如何构建一个go项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/如何构建一个go项目/" itemprop="url">如何构建一个go项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T15:44:43+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这里我会介绍开发一个简单的Go包以及对<code>go tool</code>的使用。最标准的方法是先拉取，编译再安装Go包然后再到命令行运行。</p>
<p><code>go tool</code>需要你按特定的方式组织你的代码.接下来请仔细阅读.</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li>Go程序通常把所有的Go代码放在单一的工作空间</li>
<li>工作空间包含各种版本控制的库(如:git管理的库)</li>
<li>每一个库包含一个或多个包</li>
<li>每一个包由单个目录下面的一个或多个go文件组成</li>
<li>包的路径决定了它导入的路径</li>
</ul>
<p>注意要和其它Go程序区分开来，每个Go的项目都有自己的工作空间并且工作空间是和版本控制库是紧密联系在一起的。</p>
<h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>一个工作空间是包含有三子目录的目录:</p>
<ul>
<li>src包信Go的源文析</li>
<li>pkg包含仓库生成对应的包</li>
<li>bin包含我们生成Go的可执行程序</li>
</ul>
<p><code>go tool</code>编译所有的包并安装二进制文件到<code>pkg</code>和<code>bin</code>目录<br><code>src</code>子目录通常包含多个版本控制的库,这里面包含一个或多个包</p>
<p>一个工作空间看来是是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                          # command executable</div><div class="line">    outyet                         # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a           # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	hello/</div><div class="line">	    hello.go               # command source</div><div class="line">	outyet/</div><div class="line">	    main.go                # command source</div><div class="line">	    main_test.go           # test source</div><div class="line">	stringutil/</div><div class="line">	    reverse.go             # package source</div><div class="line">	    reverse_test.go        # test source</div><div class="line">    golang.org/x/image/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	bmp/</div><div class="line">	    reader.go              # package source</div><div class="line">	    writer.go              # package source</div><div class="line">    ... (many more repositories and packages omitted) ...</div></pre></td></tr></table></figure></p>
<p>上面的结构包含两个库(example和image).example库包含两个可执行程序和一个库。image仓库包含bmp包和一些其它的。</p>
<p>一个典型的工作空间是包含多个仓库源，每个仓库包含多个包或可执行程序。大部分Go程序保持所有Go源码和依赖放在同一个工作空间。</p>
<p>可执行程序和程序所需要的库是从不同的包里生成的。我们稍后会讨论他们的区别。</p>
<h3 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h3><p>GOPATH环境变量指定了工作空间的位置.linux默认是<code>~/go</code>,windows下面是<code>C:\Users\YourName\go</code>。</p>
<p>如果你喜欢在不同的位置工作，你需要设置下GOPATH指向你想要的那个目录(另一个常见的设置是<code>GOPATH=$HOME</code>)，注意GOPATH不要和Go安装的目录相同。</p>
<p><code>go env GOPATH</code>输出当前生效的GOPATH,如果没有设置会输出默认的值。</p>
<p>为了方便把工作目录的<code>bin</code>子目录设置加入到系统PATH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$export PATH=$PATH:$(go env GOPATH)/bin</div></pre></td></tr></table></figure>
<h3 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h3><p>一个导入路径是标识唯一个包的一串字符。一个包导入路径对应它在工作空间里面的目录或是一个远程仓库。</p>
<p>标准库的包导入路径非常短,比如:”fmt”、”net/http”.对于自己的包来说，你必须选择将来加入一些标准库或其它外部库不太可能会产生冲突的基础路径。</p>
<p>如果你把代码放在某个开源仓库，你应该仓库的根目录做为你的基础路径。比如:你的github帐号是<code>github.com/user</code>，这应该是你的基础路径。</p>
<p>注意在你可以编译之前最好不要发布你的代码到远程仓库。这是一个好的习惯来组织你的代码如果你在将来某一天发布。事实上你可以选择其它任意的目录名称，只要它对标准库和Go生态生成的路径唯一就好。</p>
<p>接下来我们会用<code>github.com/user</code>做为我们的基础路径。在你的工作空间创建一个目录来放你的源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mkdir -p $GOPATH/src/github.com/user</div></pre></td></tr></table></figure></p>
<h3 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h3><p>编译和运行一个程序首先需要选择一个包路径(我们用github.com/user/hello)然后在你的工作空间创建相应的包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/hello</div></pre></td></tr></table></figure>
<p>接下来我们在目录下面创建一个叫<code>hello.go</code>的文件,文件内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Hello, world.\n"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以用<code>go tool</code>编译然后安装这个程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go install github.com/user/hello</div></pre></td></tr></table></figure>
<p>注意你可以在你电脑的任何地方运行这个命令。<code>go tool</code>会在你的<code>GOPATH</code>查找<code>github.com/user/hello</code>对应的包。</p>
<p>如果你在包的目录下面运行<code>go install</code>话，你可以忽略包的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/github.com/user/hello</div><div class="line">$ go install</div></pre></td></tr></table></figure>
<p>这个命令编译hello生成一个可执行文件。然后安装这个二进制文件到工作空间的bin目录下，生成的名字是hello(windows下是hello.exe)。在我们的例子会在$GOPATH/bin/hello,也就是$HOME/go/bin/hello.</p>
<p><code>go tool</code>只会在有错误的情况下输出，如果没有任何输出说明是执行成功。</p>
<p>现在你可以在命令行输入绝对路径来运行你的程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ $GOPATH/bin/hello</div></pre></td></tr></table></figure></p>
<p>或者你已经把$GOPATH/bin加入到系统PATH了，你只需要输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, world.</div></pre></td></tr></table></figure></p>
<p>如果你正在用一个版本控制系统，那么现在是初始化一个仓库的最佳时机，新增这些文件，然后提交你第一次变更。再强调一次，这一步是可选的:你不需要用源代码控制系统来写Go代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/src/github.com/user/hello</div><div class="line">$ git init</div><div class="line">Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/</div><div class="line">$ git add hello.go</div><div class="line">$ git commit -m &quot;initial commit&quot;</div><div class="line">[master (root-commit) 0b4507d] initial commit</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line">  create mode 100644 hello.go</div></pre></td></tr></table></figure>
<h3 id="第一个库"><a href="#第一个库" class="headerlink" title="第一个库"></a>第一个库</h3><p>让我们写一个库并在hello程序里面使用这个库</p>
<p>再说下，第一步创建包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/stringutil</div></pre></td></tr></table></figure>
<p>接下来在目录下创建一个reverse.go的文件，内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></div><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	r := []<span class="keyword">rune</span>(s)</div><div class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</div><div class="line">		r[i], r[j] = r[j], r[i]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们用<code>go build</code>来编译这个包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build github.com/user/stringutil</div></pre></td></tr></table></figure></p>
<p>或进入目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build</div></pre></td></tr></table></figure></p>
<p>这个不会产生文件。为了这样做，你必须用go install把这个包放到你工作空间的pkg目录。</p>
<p>在你确实stringutil包编译成功后，修改你原先的hello.go代码:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/user/stringutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行我们的程序，结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, Go!</div></pre></td></tr></table></figure></p>
<p>经过上面的步骤后，我们的工作空间如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                 # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/          # this will reflect your OS and architecture</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a  # package object</div><div class="line">src/</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go      # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go    # package source</div></pre></td></tr></table></figure></p>
<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>在Go的源码里面第一条语句必需是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package name</div></pre></td></tr></table></figure>
<p>name是包默认的名字用来导入。(一个包里所有的文件必须用同一个name)</p>
<p>Go的转换规则是把导入路径最后一个元素做为包名的:如果”crypto/rot13”导入的话name应该命名为rot13.</p>
<p>可执行的命令必须用package main.</p>
<p>在链接到一个二进制文件的时候不要求所有包里的名称都唯一，但是导入的路径必须唯一。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go有一个轻微测试框，由<code>go test</code>命令和testing包组成。</p>
<p>新建一个以_test.go结尾的文件名来做为测试，文件里面包含类TestXXX(t *testing.T)的函数。测试框架会运行每一个这样的函数;如果函数用T.Error或t.Fail调用失败，这个测试是被认为失败了。</p>
<p>到stringutil包里新增一个测试文件($GOPATH/src/github.com/user/stringutil/reverse_test.go),内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	cases := []<span class="keyword">struct</span> &#123;</div><div class="line">		in, want <span class="keyword">string</span></div><div class="line">	&#125;&#123;</div><div class="line">		&#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</div><div class="line">		got := Reverse(c.in)</div><div class="line">		<span class="keyword">if</span> got != c.want &#123;</div><div class="line">			t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行这个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/user/stringutil</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<p>同样的，可以在包里面运行这个测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<h2 id="远程包"><a href="#远程包" class="headerlink" title="远程包"></a>远程包</h2><p>包的导入描述了是怎样通过版本控制系统获取包的源码的(如:git或Mercurial).<code>go tool</code>利用这个特性从远程仓库获取这个包。例如,在这个文章里面example是放在Github上面的(github.com/golang/example)。如果你在包的导入路径添加了这个地址，<code>go get</code>将会自动拉取、编译和安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/golang/example/hello</div><div class="line">$ $GOPATH/bin/hello</div><div class="line">Hello, Go examples!</div></pre></td></tr></table></figure>
<p>如果指定的包不存在当前的工作空间，<code>go get</code>将会把包放到由<code>GOPATH</code>指定的工作空间里面。(如果这个包已经在工作空间中存在,<code>go get</code>跳过从远程的拉取和安装)</p>
<p>执行上面<code>go get</code>命令后，现在的工作空间目录结构是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                           # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a            # package object</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a            # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">	.git/                       # Git repository metadata</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div></pre></td></tr></table></figure></p>
<p>托管在Gihub上的<code>hello</code>程序和它依赖<code>stringutil</code>包在同一个仓库。在<code>hello.go</code>文件里用相同的导入路径转换，所以<code>go get</code>命令找到和安装依赖包到对应的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;github.com/golang/example/stringutil&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>英语很渣的一个翻译<br><a href="https://golang.org/doc/code.html" target="_blank" rel="external">参考</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">易斌</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">易斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
