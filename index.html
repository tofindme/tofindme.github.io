<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>不可同日而语</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="不可同日而语">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="不可同日而语">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不可同日而语">
  
    <link rel="alternate" href="/atom.xml" title="不可同日而语" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不可同日而语</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-如何构建一个go项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/12/如何构建一个go项目/" class="article-date">
  <time datetime="2017-09-12T07:44:43.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/如何构建一个go项目/">如何构建一个go项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这里我会介绍开发一个简单的Go包以及对<code>go tool</code>的使用。最标准的方法是先拉取，编译再安装Go包然后再到命令行运行。</p>
<p><code>go tool</code>需要你按特定的方式组织你的代码.接下来请仔细阅读.</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li>Go程序通常把所有的Go代码放在单一的工作空间</li>
<li>工作空间包含各种版本控制的库(如:git管理的库)</li>
<li>每一个库包含一个或多个包</li>
<li>每一个包由单个目录下面的一个或多个go文件组成</li>
<li>包的路径决定了它导入的路径</li>
</ul>
<p>注意要和其它Go程序区分开来，每个Go的项目都有自己的工作空间并且工作空间是和版本控制库是紧密联系在一起的。</p>
<h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>一个工作空间是包含有三子目录的目录:</p>
<ul>
<li>src包信Go的源文析</li>
<li>pkg包含仓库生成对应的包</li>
<li>bin包含我们生成Go的可执行程序</li>
</ul>
<p><code>go tool</code>编译所有的包并安装二进制文件到<code>pkg</code>和<code>bin</code>目录<br><code>src</code>子目录通常包含多个版本控制的库,这里面包含一个或多个包</p>
<p>一个工作空间看来是是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                          # command executable</div><div class="line">    outyet                         # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a           # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	hello/</div><div class="line">	    hello.go               # command source</div><div class="line">	outyet/</div><div class="line">	    main.go                # command source</div><div class="line">	    main_test.go           # test source</div><div class="line">	stringutil/</div><div class="line">	    reverse.go             # package source</div><div class="line">	    reverse_test.go        # test source</div><div class="line">    golang.org/x/image/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	bmp/</div><div class="line">	    reader.go              # package source</div><div class="line">	    writer.go              # package source</div><div class="line">    ... (many more repositories and packages omitted) ...</div></pre></td></tr></table></figure></p>
<p>上面的结构包含两个库(example和image).example库包含两个可执行程序和一个库。image仓库包含bmp包和一些其它的。</p>
<p>一个典型的工作空间是包含多个仓库源，每个仓库包含多个包或可执行程序。大部分Go程序保持所有Go源码和依赖放在同一个工作空间。</p>
<p>可执行程序和程序所需要的库是从不同的包里生成的。我们稍后会讨论他们的区别。</p>
<h3 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h3><p>GOPATH环境变量指定了工作空间的位置.linux默认是<code>~/go</code>,windows下面是<code>C:\Users\YourName\go</code>。</p>
<p>如果你喜欢在不同的位置工作，你需要设置下GOPATH指向你想要的那个目录(另一个常见的设置是<code>GOPATH=$HOME</code>)，注意GOPATH不要和Go安装的目录相同。</p>
<p><code>go env GOPATH</code>输出当前生效的GOPATH,如果没有设置会输出默认的值。</p>
<p>为了方便把工作目录的<code>bin</code>子目录设置加入到系统PATH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$export PATH=$PATH:$(go env GOPATH)/bin</div></pre></td></tr></table></figure>
<h3 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h3><p>一个导入路径是标识唯一个包的一串字符。一个包导入路径对应它在工作空间里面的目录或是一个远程仓库。</p>
<p>标准库的包导入路径非常短,比如:”fmt”、”net/http”.对于自己的包来说，你必须选择将来加入一些标准库或其它外部库不太可能会产生冲突的基础路径。</p>
<p>如果你把代码放在某个开源仓库，你应该仓库的根目录做为你的基础路径。比如:你的github帐号是<code>github.com/user</code>，这应该是你的基础路径。</p>
<p>注意在你可以编译之前最好不要发布你的代码到远程仓库。这是一个好的习惯来组织你的代码如果你在将来某一天发布。事实上你可以选择其它任意的目录名称，只要它对标准库和Go生态生成的路径唯一就好。</p>
<p>接下来我们会用<code>github.com/user</code>做为我们的基础路径。在你的工作空间创建一个目录来放你的源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mkdir -p $GOPATH/src/github.com/user</div></pre></td></tr></table></figure></p>
<h3 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h3><p>编译和运行一个程序首先需要选择一个包路径(我们用github.com/user/hello)然后在你的工作空间创建相应的包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/hello</div></pre></td></tr></table></figure>
<p>接下来我们在目录下面创建一个叫<code>hello.go</code>的文件,文件内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Hello, world.\n"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以用<code>go tool</code>编译然后安装这个程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go install github.com/user/hello</div></pre></td></tr></table></figure>
<p>注意你可以在你电脑的任何地方运行这个命令。<code>go tool</code>会在你的<code>GOPATH</code>查找<code>github.com/user/hello</code>对应的包。</p>
<p>如果你在包的目录下面运行<code>go install</code>话，你可以忽略包的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/github.com/user/hello</div><div class="line">$ go install</div></pre></td></tr></table></figure>
<p>这个命令编译hello生成一个可执行文件。然后安装这个二进制文件到工作空间的bin目录下，生成的名字是hello(windows下是hello.exe)。在我们的例子会在$GOPATH/bin/hello,也就是$HOME/go/bin/hello.</p>
<p><code>go tool</code>只会在有错误的情况下输出，如果没有任何输出说明是执行成功。</p>
<p>现在你可以在命令行输入绝对路径来运行你的程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ $GOPATH/bin/hello</div></pre></td></tr></table></figure></p>
<p>或者你已经把$GOPATH/bin加入到系统PATH了，你只需要输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, world.</div></pre></td></tr></table></figure></p>
<p>如果你正在用一个版本控制系统，那么现在是初始化一个仓库的最佳时机，新增这些文件，然后提交你第一次变更。再强调一次，这一步是可选的:你不需要用源代码控制系统来写Go代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/src/github.com/user/hello</div><div class="line">$ git init</div><div class="line">Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/</div><div class="line">$ git add hello.go</div><div class="line">$ git commit -m &quot;initial commit&quot;</div><div class="line">[master (root-commit) 0b4507d] initial commit</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line">  create mode 100644 hello.go</div></pre></td></tr></table></figure>
<h3 id="第一个库"><a href="#第一个库" class="headerlink" title="第一个库"></a>第一个库</h3><p>让我们写一个库并在hello程序里面使用这个库</p>
<p>再说下，第一步创建包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/stringutil</div></pre></td></tr></table></figure>
<p>接下来在目录下创建一个reverse.go的文件，内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></div><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	r := []<span class="keyword">rune</span>(s)</div><div class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</div><div class="line">		r[i], r[j] = r[j], r[i]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们用<code>go build</code>来编译这个包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build github.com/user/stringutil</div></pre></td></tr></table></figure></p>
<p>或进入目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build</div></pre></td></tr></table></figure></p>
<p>这个不会产生文件。为了这样做，你必须用go install把这个包放到你工作空间的pkg目录。</p>
<p>在你确实stringutil包编译成功后，修改你原先的hello.go代码:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/user/stringutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行我们的程序，结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, Go!</div></pre></td></tr></table></figure></p>
<p>经过上面的步骤后，我们的工作空间如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                 # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/          # this will reflect your OS and architecture</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a  # package object</div><div class="line">src/</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go      # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go    # package source</div></pre></td></tr></table></figure></p>
<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>在Go的源码里面第一条语句必需是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package name</div></pre></td></tr></table></figure>
<p>name是包默认的名字用来导入。(一个包里所有的文件必须用同一个name)</p>
<p>Go的转换规则是把导入路径最后一个元素做为包名的:如果”crypto/rot13”导入的话name应该命名为rot13.</p>
<p>可执行的命令必须用package main.</p>
<p>在链接到一个二进制文件的时候不要求所有包里的名称都唯一，但是导入的路径必须唯一。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go有一个轻微测试框，由<code>go test</code>命令和testing包组成。</p>
<p>新建一个以_test.go结尾的文件名来做为测试，文件里面包含类TestXXX(t *testing.T)的函数。测试框架会运行每一个这样的函数;如果函数用T.Error或t.Fail调用失败，这个测试是被认为失败了。</p>
<p>到stringutil包里新增一个测试文件($GOPATH/src/github.com/user/stringutil/reverse_test.go),内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	cases := []<span class="keyword">struct</span> &#123;</div><div class="line">		in, want <span class="keyword">string</span></div><div class="line">	&#125;&#123;</div><div class="line">		&#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</div><div class="line">		got := Reverse(c.in)</div><div class="line">		<span class="keyword">if</span> got != c.want &#123;</div><div class="line">			t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行这个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/user/stringutil</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<p>同样的，可以在包里面运行这个测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<h2 id="远程包"><a href="#远程包" class="headerlink" title="远程包"></a>远程包</h2><p>包的导入描述了是怎样通过版本控制系统获取包的源码的(如:git或Mercurial).<code>go tool</code>利用这个特性从远程仓库获取这个包。例如,在这个文章里面example是放在Github上面的(github.com/golang/example)。如果你在包的导入路径添加了这个地址，<code>go get</code>将会自动拉取、编译和安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/golang/example/hello</div><div class="line">$ $GOPATH/bin/hello</div><div class="line">Hello, Go examples!</div></pre></td></tr></table></figure>
<p>如果指定的包不存在当前的工作空间，<code>go get</code>将会把包放到由<code>GOPATH</code>指定的工作空间里面。(如果这个包已经在工作空间中存在,<code>go get</code>跳过从远程的拉取和安装)</p>
<p>执行上面<code>go get</code>命令后，现在的工作空间目录结构是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                           # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a            # package object</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a            # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">	.git/                       # Git repository metadata</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div></pre></td></tr></table></figure></p>
<p>托管在Gihub上的<code>hello</code>程序和它依赖<code>stringutil</code>包在同一个仓库。在<code>hello.go</code>文件里用相同的导入路径转换，所以<code>go get</code>命令找到和安装依赖包到对应的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;github.com/golang/example/stringutil&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>英语很渣的一个翻译<br><a href="https://golang.org/doc/code.html" target="_blank" rel="external">参考</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/12/如何构建一个go项目/" data-id="cj7iehgvx000mq0q6x9szgmqq" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GOPATH/">GOPATH</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-go-bugs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/11/go-bugs/" class="article-date">
  <time datetime="2017-09-11T01:56:22.000Z" itemprop="datePublished">2017-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/11/go-bugs/">golang开发中遇到的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>在用golang编写服务器程序的时候，遇到下面一些问题，所以在这里做一些记录，尤其是<code>slice</code>隐藏的bug较隐性，若对<code>slice</code>工作原理不了解是较难发现的。</p>
<ul>
<li>slice元素被莫名替换</li>
<li>index out of range问题</li>
<li>空指针引用</li>
<li>map的并发读写导致进程挂掉</li>
<li>String方法导致的递归死循环</li>
<li>通道多次close(close of closed channel)</li>
<li>死锁</li>
</ul>
<h3 id="slice元素被替换"><a href="#slice元素被替换" class="headerlink" title="slice元素被替换"></a>slice元素被替换</h3><blockquote>
<p>slice在开发中运用较频繁的基础数据类型,和数组相似，与数组最大的区别在于他是系统自动扩容的。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</div><div class="line">	array unsafe.Pointer</div><div class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></div><div class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>go runtime</code>里面对slice实现数据结构，指向一块内存的一个指针、一个当前slice里面的长度以及当前slice里面的最大容量。可以预想下<br>若另外一个指针同之前slice的指针有内存重叠的话，修改重叠部分是会相互影响的，下面我们用实例来确定下这个问题。</p>
<p><strong>test1.go</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</div><div class="line"></div><div class="line">sb := sa</div><div class="line">sb = <span class="built_in">append</span>(sb, <span class="number">5</span>) <span class="comment">// sb = append(sa, 5) 同样有问题</span></div><div class="line"></div><div class="line"><span class="comment">// 从小到大排序</span></div><div class="line">algorithm.Sort(sb, <span class="number">0</span>, <span class="built_in">len</span>(sb)<span class="number">-1</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 5 cap: 8 of slice sa: [1 2 3 4 5]</span></div><div class="line"><span class="comment">// len: 6 cap: 8 of slice sb: [1 2 3 4 5 6]</span></div></pre></td></tr></table></figure></p>
<p><strong>test2.go</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">sb := sa</div><div class="line">sb = <span class="built_in">append</span>(sb, <span class="number">9</span>)</div><div class="line"></div><div class="line"><span class="comment">// 从小到大排序</span></div><div class="line">algorithm.Sort(sb, <span class="number">0</span>, <span class="built_in">len</span>(sb)<span class="number">-1</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 8 cap: 8 of slice sa: [1 2 3 4 5 7 8 10]</span></div><div class="line"><span class="comment">// len: 9 cap: 16 of slice sb: [1 2 3 4 5 7 8 9 10]</span></div></pre></td></tr></table></figure></p>
<p>上面两个程序的输出可能看出，<code>test1.go</code>中对sb排完序后sa和sb第5个元素是被替换掉了的。<br>实际上sa和sb是两个指向同块内存的不同指针，只是它们的len值不一样,需要注意的是sb调用<br>append后cap的值还是和sa的一样。和<code>test2.go</code>形成鲜明的对比，只要slice的长度超过了默<br>认的容量后就会自动扩容。</p>
<p><strong>sb:=sa之后的代码写在函数里面同样有这样的问题，因为go里面传参都是按值传递的</strong></p>
<h3 id="index-out-of-range"><a href="#index-out-of-range" class="headerlink" title="index out of range"></a>index out of range</h3><ul>
<li>索引slice元素越界</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</div><div class="line"><span class="comment">// sa[5] = 20 // 这里会panic</span></div><div class="line"></div><div class="line">sb := sa[<span class="number">5</span>:]</div><div class="line"><span class="comment">// sb[0] = 5  // 这里会panic</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 5 cap: 8 of slice sa: [1 2 3 4 6]</span></div><div class="line"><span class="comment">// len: 0 cap: 3 of slice sb: []</span></div></pre></td></tr></table></figure>
<p>对于这种下标越界的问题是当索引的下标号超出了<code>len(sa)</code>的时候就抛出越界的错误</p>
<ul>
<li>slice表达式越界问题</li>
</ul>
<blockquote>
<p>根据官方文档的说明slice表达式有两个，一种简单的表达式和参数更全的表达式<br>分别对应<code>a[low : high]</code>和<code>a[low : high : max]</code></p>
</blockquote>
<p><a href="https://golang.org/ref/spec#Slice_expressions" target="_blank" rel="external">spec说明</a><br>对于这类越界是下标不在<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>这范围时会出现问题</p>
<h3 id="空指针引用"><a href="#空指针引用" class="headerlink" title="空指针引用"></a>空指针引用</h3><p>相信不论是C系还是JAVA开发者都会遇到空指针的问题，C里面对空地址的访问是致命的，<br>并且不像JAVA能把这种异常捕获，go也不例外，为了保证服务正常运行同样可以通过<br>recover把所有runtime时的错捕获到，但并发读写的错误是不行的。所以我们项目里基本<br>在所有的协程里面有recover输出的。</p>
<p>项目中我们把一个自定义的interface的变量赋值一个<code>nil</code>，但去执行原先持有的类型的<br>函数时就panic掉了，所以对默认值为空值引用的都会出这种错误，比如:空指针和接口</p>
<p><strong>有趣的例子:</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</div><div class="line">	Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stu)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"s is %v"</span>, s) <span class="comment">// 这里能正常调用,但不要再去调Stu里面的成员</span></div><div class="line">	<span class="keyword">return</span> <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> s *Stu</div><div class="line">	s.GetName()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子一开始出乎意料，但仔细一想其实是符合go的设计理念的，方法是属于类型的，<br>类型的变量当然是可以正常调用的，但变量为空再去调用里面的成员就是对空指针的访问了。</p>
<h3 id="map的并发读写导致进程挂掉"><a href="#map的并发读写导致进程挂掉" class="headerlink" title="map的并发读写导致进程挂掉"></a>map的并发读写导致进程挂掉</h3><p>对一个多线程程序来说对数据竞争的保护是必不可少的，但在处理日志输出的时候，如果<br>一个对象有map或数组之类的并对有并发读写这很容易导致进程panic掉。所以打印日志的<br>时候一定要注意不要输出一个对象。</p>
<h3 id="String方法导致的递归死循环"><a href="#String方法导致的递归死循环" class="headerlink" title="String方法导致的递归死循环"></a>String方法导致的递归死循环</h3><p>在日志输出的时候打印了一个对象并且对象实现了String()方法，如果String方法里面<br>又调了自身，这种使用方法是很危险的，在我们开发期间是有同事犯了这个一个错误的。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>既然是并发程序，难免会有数据竞争的问题，所以我们用了互斥锁来解决这个问题，<br>如果获取锁和释放锁没有成对使用或者是锁重入(递归获取锁)就会导致死锁的风险，<br>因为我们项目是针对房间的，虽然不影响所有的人，一出现死锁只会影响这个房间<br>的人，不过我们这种锁是睡眠锁,并不消耗CPU。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/11/go-bugs/" data-id="cj7iehgvn000aq0q6pz579vgj" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang-slice-空指针-并发读写/">golang slice 空指针 并发读写</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-about-me" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/11/about-me/" class="article-date">
  <time datetime="2017-09-11T01:22:48.213Z" itemprop="datePublished">2017-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/11/about-me/">关于我</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>很高兴我的博客要和大家见面了，我是coder，一个普通的程序员，今年是第七个年头了。一直希望有个博客，借助这些开源的工具，折腾后终于搭建好了属于自己的博客了!</p>
<p>工作现基本是基于linux后台的开发，c、golang、lua、c++、php都做过项目，现在工作中用lua居多。空闲之余也研究js。</p>
<p>Love what you do,do what you love.</p>
<p>思考，思考，思考!<br>DO,DO,DO!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/11/about-me/" data-id="cj7iehgvb0001q0q6wzld8j3p" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-enjoy-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/08/enjoy-hexo/" class="article-date">
  <time datetime="2017-09-08T02:50:37.000Z" itemprop="datePublished">2017-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/08/enjoy-hexo/">enjoy hexo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="搭建博客的过程"><a href="#搭建博客的过程" class="headerlink" title="搭建博客的过程"></a>搭建博客的过程</h4><p>对于没有购买自己域名的个人来说<code>hexo+github</code>是个不错的选择。</p>
<p>安装步骤:</p>
<ul>
<li>安装<code>git</code></li>
<li>安装<code>nodejs</code></li>
<li>在git上创建自己的仓库</li>
<li>用<code>hexo</code>创建博客并生成静态页面，关联自己的仓库，再<code>hexo deploy</code>基本就好了</li>
</ul>
<h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><ul>
<li><a href="https://git-for-windows.github.io/" target="_blank" rel="external">git下载</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs下载</a> 选择LTS(Long Term Support)版本就好</li>
<li><code>npm i -g hexo</code>安装hexo</li>
</ul>
<p>npm是nodejs来管理软件库的一个工具，i是安装-g 是全局安装,安装后尽情享受hexo –help的功能吧。<br><a href="https://hexo.io/themes/" target="_blank" rel="external">更换主题地址</a><code>git clone url themes/</code></p>
<h3 id="enjoy"><a href="#enjoy" class="headerlink" title="enjoy"></a>enjoy</h3><p>所有准备工作做好后直接用<code>hexo init name</code>初始化一个博客目录</p>
<ul>
<li><code>hexo new first-post</code>来创建自己的需要写的文章</li>
<li><code>hexo server</code>就可以通过访问<code>localhost:4000</code>博客地址了</li>
</ul>
<p>可以在配置文件里面支持分类、评论和主题等各种参数配置</p>
<p><strong>在配置git上面的仓库的时候用git协议每次更新就不需要输入密码~</strong></p>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>把自己本地的ssh的公钥放到github个人帐号的key下面,没有则用<code>ssh-keygen</code>一直回车生成,<code>cat ~/.ssh/id_rsa.pub</code><br>在配置里面自己github仓库地址</p>
<p><strong>仓库名格式:<code>名称+github.io</code> example:hello.github.io，否则无效</strong></p>
<p>每次有新文章需要发布的时候执行下面命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean   </div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/08/enjoy-hexo/" data-id="cj7iehgw2000tq0q6wnul0by3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo-nodejs/">hexo nodejs</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/lock/" class="article-date">
  <time datetime="2017-03-14T09:56:08.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/lock/">lock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>os是多任务操作系统,同一个进程下面是可以有多个线程(进程)同时运行的,线程实际也是一个进程,只是对父进程的一个copy,与父进程共享地址空间进程,所以对同一进程共享的资源需要进行同步,同步的方法包括<code>mutex semaphore spinlock 条件变量</code></p>
<p>很多东西如果只停留在概念层面远远是不够的，我们还是要不断的思考下面的实现机制和原理,下面说下同步的东西。</p>
<h4 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> semaphore &#123;</div><div class="line">    <span class="keyword">atomic_t</span> count;</div><div class="line">    <span class="keyword">int</span> sleepers;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> counter; </div><div class="line">&#125; <span class="keyword">atomic_t</span>;</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/03/14/lock/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/lock/" data-id="cj7iehgvp000cq0q66i2fw1v9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux-lock-mutex/">linux lock mutex</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux-io" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/linux-io/" class="article-date">
  <time datetime="2017-03-14T03:04:29.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/linux-io/">linux-io</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>少说话，多看代码，多思考，多动手</strong></p>
<p>io操作是一个程序必不可少的部分，io可以是对块设备的读写，文件的读写，基于网络上的io,这里通过内核select和epoll源码比较下这两种io的优劣。平常服务器需要处理客户端多个连接(基于tcp)的io事件。</p>
<p>对io的读写是有阻塞和非阻塞之分的，对于tcp连接上的读写实际是基于它的读写缓存区，如果fd是阻塞的话,对读来说,缓冲区没数据,对写来说，缓冲区不足够装下需要写的数据或已经满了同样会阻塞。下面是一个阻塞和非阻塞读取标准输入的程序。</p>
        
          <p class="article-more-link">
            <a href="/2017/03/14/linux-io/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/linux-io/" data-id="cj7iehgvl0006q0q6qik43wck" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io-select-epoll-socket/">io select epoll socket</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c-lua" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/13/c-lua/" class="article-date">
  <time datetime="2017-03-13T01:59:28.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/c-lua/">c和lua交互</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要理解Lua和C++交互，首先要理解Lua堆栈。</p>
<p>简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出。</p>
<p>在Lua中，Lua堆栈就是一个struct，<strong>堆栈索引的方式可是是正数也可以是负数，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶。如图：</strong></p>
<p><img src="../../../../images/stack.png" alt=""></p>
        
          <p class="article-more-link">
            <a href="/2017/03/13/c-lua/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/13/c-lua/" data-id="cj7iehgv70000q0q6kxjfd5pu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-lua/">c lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-max-open-file" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/max-open-file/" class="article-date">
  <time datetime="2017-03-08T07:21:28.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/max-open-file/">最大可打开的文件数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>平常开发项目的时候会遇到进程下打开的最大fd超过默认设置，导致用户不能正常使用服务。<code>linux</code>是基于文件系统的一个操作系统,操作系统最基本的单元就是进程。最大可打开的文件描述符分为系统级别的和进程级别的。</p>
<h5 id="面向全系统的"><a href="#面向全系统的" class="headerlink" title="面向全系统的"></a>面向全系统的</h5><p>虽然操作系统是基于文件系统的，但它对整个系统中所打开的最大fd数目也是有限制的，默认的系统最大的fd在<code>/proc/sys/fs/file-max</code>文件里，记住<code>proc</code>目录只是一个虚拟的，实际控制的值是在<code>/etc/sysctl.conf</code>里可通过以下方式修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl.conf #fs.file-max=795165把这个放到文件最后</div><div class="line">sysctl -w fs.file-max=795165</div></pre></td></tr></table></figure>
<p>最后需要执行<code>sysctl -p</code>生效,再到<code>cat /proc/sys/fs/file-max</code>验证已经同步</p>
<p>&lt;! – more –&gt;</p>
<h5 id="面向进程"><a href="#面向进程" class="headerlink" title="面向进程"></a>面向进程</h5><p>我们知道<code>linux</code>系统是一个多用户多进程的多核操作系统,进程是属于具体某一个用户的，通过<code>xshell</code>等工具<code>ulimit</code>看到的东西是对这个用户的一些资源限制，默认的最大fd数是1024,这一般不能满足于我们的需求，所以需要我们手动修改<br>如果默认从终端(shell环境)启动的进程会继承这些参数，修改可以通过以下几种方式:</p>
<ul>
<li><p><code>/etc/profile /etc/bashrc ~/.bash_profile ~/.bashrc</code> 等脚本初始化地方加入<code>ulimit -n value</code></p>
</li>
<li><p><code>vim /etc/security/limits.conf</code> 按里面的说明还以为是对用户所有打开的fd有限制，经过测试并不是，对资源的限制还是针对进程的,只是用户登录shell会读取这个默认的值</p>
</li>
</ul>
<p>ulimit -n value value值不能超过硬链接数 <code>ulimit -Hn</code>可以查看硬链数,最好在<code>/etc/security/limits.conf</code>设置自己想要的值</p>
<p><a href="https://www.cyberciti.biz/faq/linux-increase-the-maximum-number-of-open-files/" target="_blank" rel="external">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/08/max-open-file/" data-id="cj7iehgvt000gq0q6m85nfsir" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux-ulimit-openfile/">linux ulimit openfile</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/07/docker/" class="article-date">
  <time datetime="2017-03-07T09:25:11.000Z" itemprop="datePublished">2017-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/容器/">容器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/07/docker/">docker.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h1><blockquote>
<p>docker是用google开源语言golang开发的一款类似vm这样的管理容器的开源软件，他的优势在于不像vm一样启动一个虚拟机需要等待漫长的时间，而对docker而言只需要简单的启动一个image就相当于运行一个独立的container。各个container是相互独立的。启停一个container也是相对方便和快速的</p>
</blockquote>
<p><em>此笔记记录阅读docker官网及博客并实践操作所记</em></p>
<ul>
<li>docker和vm的区别</li>
<li>docker实践讲解</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2017/03/07/docker/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/07/docker/" data-id="cj7iehgvf0004q0q6tivaq5yb" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker-容器/">docker 容器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-kubernete" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/07/kubernete/" class="article-date">
  <time datetime="2017-03-07T01:34:22.000Z" itemprop="datePublished">2017-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/容器/">容器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/07/kubernete/">kubernete</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个世界最伟大的就是思想，人这一特种对这世界的改造都取决于他们独有的思想，他们用思想来创造或改造这个世界。而思想的优越之处在于把事物抽象化，技术的实现就是对现实世界的抽象。人真是太聪明了</p>
<h3 id="kubernete"><a href="#kubernete" class="headerlink" title="kubernete"></a>kubernete</h3><p>容器化技术在最近一两年可谓是风生水起,自从<code>docker</code>出世以来就爱到程序界的追棒，而去年google家亲生的<code>kubernete</code>也是更受亲耐，下面通过官网的手来学习记录。</p>
<pre><code>Production-Grade Container Orchestration
</code></pre><p>Automated container deployment, scaling, and management</p>
<p>这是官网的标语.<code>生产级别的容器编排，自动化进行容器部署、平衡、管理</code></p>
<p>通俗的说<code>kubernete</code>就是一个容器管理系统,我们的app就运行在这些容器上，官网上说google在<code>kubernete</code>一周运行了上亿的容器。管理这么多的容器，要是传统的模式这么多台服务器该怎么管理呀，真是太解放了。</p>
<h4 id="kubernete集群"><a href="#kubernete集群" class="headerlink" title="kubernete集群"></a>kubernete集群</h4><p><code>kubernete</code>集群是把多台机器抽象成一个独立的单元，并保证集群的高可用性。这样一来我们发布我们的应用的时候不需要指定到某一机器，只要把我们的应用容器化就可以部署在集群中，并不需要关心部署在某台机器上。<br><code>kubernete</code>会以高效的方式在集群中发布和调度这些容器</p>
<p>一个集群概念包含两种类型的资源:</p>
<ul>
<li><strong>Master</strong>  用来协调各个<code>Node</code>节点</li>
<li><strong>Node</strong> 运行我们的应用</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2017/03/07/kubernete/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/07/kubernete/" data-id="cj7iehgvg0005q0q60owxvkjo" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/容器-kurbenet-docker/">容器 kurbenet docker</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
     
     
            <a class="github" aria-hidden="true" href="https://github.com/tofindme" target="_blank" title="Github"></a>
    
     
          <a class="weibo" aria-hidden="true"  href="http://weibo.com/u/1924106177" target="_blank" title="微博"></a>
    
     
     
          <a class="email" aria-hidden="true"  href="mailto:849397833@qq.com" target="_blank" title="邮箱"></a>
    
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-c/">linux c</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器/">容器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开源项目/">开源项目</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/GOPATH/" style="font-size: 10px;">GOPATH</a> <a href="/tags/c-lua/" style="font-size: 10px;">c lua</a> <a href="/tags/c-skynet-linux-lua/" style="font-size: 10px;">c skynet linux lua</a> <a href="/tags/docker-容器/" style="font-size: 10px;">docker 容器</a> <a href="/tags/golang-nsq-消息队列/" style="font-size: 10px;">golang nsq 消息队列</a> <a href="/tags/golang-slice-空指针-并发读写/" style="font-size: 10px;">golang slice 空指针 并发读写</a> <a href="/tags/hexo-nodejs/" style="font-size: 10px;">hexo nodejs</a> <a href="/tags/io-select-epoll-socket/" style="font-size: 10px;">io select epoll socket</a> <a href="/tags/linux-lock-mutex/" style="font-size: 10px;">linux lock mutex</a> <a href="/tags/linux-ulimit-openfile/" style="font-size: 10px;">linux ulimit openfile</a> <a href="/tags/容器-kurbenet-docker/" style="font-size: 10px;">容器 kurbenet docker</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/12/如何构建一个go项目/">如何构建一个go项目</a>
          </li>
        
          <li>
            <a href="/2017/09/11/go-bugs/">golang开发中遇到的坑</a>
          </li>
        
          <li>
            <a href="/2017/09/11/about-me/">关于我</a>
          </li>
        
          <li>
            <a href="/2017/09/08/enjoy-hexo/">enjoy hexo</a>
          </li>
        
          <li>
            <a href="/2017/03/14/lock/">lock</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 Oscan&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;8493978933@qq.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
    



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>