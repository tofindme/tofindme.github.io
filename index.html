<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="知而智">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="知而智">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知而智">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>知而智</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <!-- <div class="headband"></div> -->

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">知而智</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>


<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/linux-concurrency-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/11/linux-concurrency-lock/" itemprop="url">linux-concurrency</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T13:14:59+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.linux-mag.com/id/2316/" alt="翻译"></p>
<blockquote>
<p>英语水平有限，工作空闲时间翻译。同时也学习了并发控制的一些知识</p>
</blockquote>
<h3 id="Concurrency-in-the-Kernel-内核里面的并发控制"><a href="#Concurrency-in-the-Kernel-内核里面的并发控制" class="headerlink" title="Concurrency in the Kernel (内核里面的并发控制)"></a>Concurrency in the Kernel (内核里面的并发控制)</h3><p>Multiple threads of execution need to be synchronized to avoid data corruption and even system freezes.</p>
<p>对于有多线程的程序来说，如果有访问共享的东西的话会导致数据的错乱甚至会导致系统的冻结</p>
<p>As the Linux kernel has grown in complexity to support Symmetric Multi-Processing (SMP) and kernel preemption, more and more scenarios generate multiple threads of execution. Because threads can simultaneously operate on shared kernel data structures, access to such data structures has to be serialized. In this column, let’s learn the basics of protecting shared kernel resources from concurrent access, starting with a simple example and slowly introducing complexities like interrupts, kernel preemption, and SMP.</p>
<p>随着linux内核支持对称多处理系统，简称SMP(Symmetric Multi-Processing)以及内核抢占，使得内核变得更加的复杂，越来越多的地方会有多线程的出现，所以线程可以同时操作内核共享的数据结构，访问这些数据必须得串行。在这里，让我们从一个简单的示例来学习并发访问时内核共享资源的基本保护并慢慢的介绍更复杂的情况。比如:中断，内核抢占以及SMP.</p>
<h4 id="Spinlocks-and-Semaphores-自旋锁和信息量"><a href="#Spinlocks-and-Semaphores-自旋锁和信息量" class="headerlink" title="Spinlocks and Semaphores (自旋锁和信息量)"></a>Spinlocks and Semaphores (自旋锁和信息量)</h4><p>A code area that accesses shared resources is called a critical section. Spinlocks and semaphores are the two mechanisms used to protect critical sections in the kernel.</p>
<p>一段访问共享资源的代码叫做临界区。在内核里面，自旋锁和信号量是用来保护临界区的两种机制。</p>
<p>A spinlock ensures that only a single thread enters a critical section at any time. Any other thread that wants to enter the critical section must wait “spinning its wheels” until the first thread exits. Listing One shows a basic use of a spinlock.</p>
<p>在任何时候，只会有一个获取自旋锁的线程进入临界区。其它线程想要进入临界区必须”自旋”等待，直到第之前获取到锁的线程释放。</p>
<p><strong>Listing One: Basic spinlock usage</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Initialize */</span></div><div class="line"><span class="keyword">spinlock_t</span> mylock = SPIN_LOCK_UNLOCKED; </div><div class="line"></div><div class="line"><span class="comment">/* Try to acquire the spinlock. This is inexpensive if there </span></div><div class="line">* is no one inside the critical section. In the face of contention,</div><div class="line">* spinlock() busy waits.</div><div class="line">*/</div><div class="line">spin_lock (&amp;mylock); </div><div class="line"></div><div class="line"><span class="comment">/* … Critical Section … */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release the lock */</span></div><div class="line">spin_unlock (&amp;mylock);</div></pre></td></tr></table></figure>
<p>In contrast to spinlocks, which put threads into a spin if they attempt to enter a busy critical section, a semaphore puts each contending thread to sleep until its turn arrives to occupy the critical section.</p>
<p>如果线程尝试进入已经被自旋锁锁住的临界区，那么自旋锁会导致线程自旋。与自旋锁相比，信号量会让每个相互竞争锁的线程休眠直到他占有这<br>临界区</p>
<p>Because it’s bad to consume processor cycles to spin, semaphores are more suitable than spinlocks to protect critical sections when the estimated wait time is long. In semaphore terms, anything more than two context switches can be considered long, since semaphores have to switch out the contending thread to sleep, and switch it back in when it’s time to wake it up.</p>
<p>由于自旋占用cpu，当执行临界区的代码需要比较长时间时，信号量来保护临界区要比自旋锁更合适。在信号量的情况下，需要考虑超过两次上下文从信号量把竞争锁的线程成休眠到唤醒休眠的切换的时间。</p>
<p>Thus, in many cases, it’s easy to make a decision on whether to use a spinlock or a semaphore:</p>
<p>因此，在各种情况下，很容易作出决定用信号量还是用自旋锁来保护临界区:</p>
<ul>
<li>If your critical section needs to sleep, you have no choice but to use a semaphore. It’s a deadly sin to schedule, preempt, or sleep on a wait queue after acquiring a spinlock.</li>
<li><p>如果你的临界区需要休眠，除了用信号量别无选择。在获取自旋锁后如果在等待队列里被重新调度、抢占或休眠是致命的错误。</p>
</li>
<li><p>Since semaphores put the calling thread to sleep in the face of contention, you have no choice but to use spinlocks inside interrupt handlers.</p>
</li>
<li>因为信号量在获取临界区是会导致调用线程休眠的，所以在中断处理程序里除了用自旋锁别无选择</li>
</ul>
<p>Unlike spinlocks, which allow only a single thread inside a critical section at a time, semaphores can be configured to allow a predetermined number of threads into the critical section simultaneously. (However, semaphores that permit only a single thread at a time are more common in the kernel.) A semaphore that permits only a single thread at a time is called a mutex. Listing Two shows basic mutex usage.</p>
<p>每个时间点自旋锁只允许一个线程处于临界区，信号量是允许配置预先定义好的线程个数同时进入临界区(然而，在内核里面，每次只允许一个线程在临界区)。每个时间点只允许一个线程进入临界区的叫互斥量。</p>
<p><strong>Listing Two: Basic Mutex Usage</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">* Architecture dependent */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/semaphore.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Statically declare a mutex. To dynamically create</span></div><div class="line">* a mutex, use init_MUTEX().</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_MUTEX</span> <span class="params">(mysem)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* Try to acquire the semaphore. This is inexpensive if there </span></div><div class="line">* is no one inside the critical section. In the face of contention,</div><div class="line">* down() puts the calling thread to sleep.</div><div class="line">*/</div><div class="line">down (&amp;mysem);</div><div class="line"></div><div class="line"><span class="comment">/* … Critical Section … */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release the semaphore */</span></div><div class="line">up (&amp;mysem);</div></pre></td></tr></table></figure>
<p>To illustrate the use of locks, let’s start with a critical section that is present only in process context and gradually introduce complexities in the following order:</p>
<p>为了说明锁的使用，我们从一个进程上下文的临界区开始然后逐渐讨论以下复杂的情况:</p>
<ul>
<li><p>Critical section present only in process context on a uniprocessor box running a non-preemptible kernel (P-UP-N). This is the simplest case and needs no locking.</p>
</li>
<li><p>临界区只存在不可抢占的单核(P-UP-N)的进程上下文时，这种简单的情况下是不需要锁的。</p>
</li>
<li><p>Critical section present in process and interrupt contexts on a uniprocessor machine running a non-preemptible kernel (PI-UP-N).</p>
</li>
<li><p>临界区存在不可抢占单核(PI-UP-N)的进程和中断上下文</p>
</li>
<li><p>Critical section present in process and interrupt contexts on a uniprocessor machine running a preemptible kernel (PI-UP-P).</p>
</li>
<li><p>临界区存在可抢占单核(PI-UP-P)的进程和中断上下文</p>
</li>
<li><p>Critical section present in process and interrupt contexts on an SMP machine running a preemptible kernel (PI-SMP-P).</p>
</li>
<li><p>临界区存在可抢占的多核(PI-SMP-P)的进程和中断上下文</p>
</li>
</ul>
<blockquote>
<p>除了第一种情况，其它三种是需要对临界区做保护的</p>
</blockquote>
<h4 id="Case-Two-PI-UP-N"><a href="#Case-Two-PI-UP-N" class="headerlink" title="Case Two: PI-UP-N"></a>Case Two: PI-UP-N</h4><p>In the case of a critical section present only in process context on a uniprocessor box running a non-preemptible kernel case, you only need to disable interrupts to protect the critical region:</p>
<p>在临界区存在中断上下文的时候，你需要把中断禁止来保护这个临界区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cli ();  <span class="comment">/* Disable Interrupts */</span></div><div class="line"><span class="comment">/* ... Critical Region ...  */</span></div><div class="line">sti ();  <span class="comment">/* Enable Interrupts */</span></div></pre></td></tr></table></figure>
<p>However, if interrupts are already disabled when execution reaches cli(), sti() has the unpleasant side effect of re-enabling interrupts, rather than restoring interrupt state. This can be fixed with:</p>
<p>然而，如果执行到cli()这里里中断已经被禁止了，sti()恢复中断后会有意想不到的影响会出现，这个可以通过恢复中断状态修改:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line"><span class="comment">/* Point A: Disable Interrupts */</span></div><div class="line">save_flags (flags); </div><div class="line">cli ();  </div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/* Restore state to what it was at Point A above */</span>	</div><div class="line">restore_flags (flags);</div></pre></td></tr></table></figure>
<p>This latter code works correctly, regardless of the interrupt state when<br>execution reaches cli().</p>
<p>这个代码正确工作，当执行到cli()时忽略中断的状态.</p>
<h4 id="Case-Three-PI-UP-P"><a href="#Case-Three-PI-UP-P" class="headerlink" title="Case Three: PI-UP-P"></a>Case Three: PI-UP-P</h4><p>If preemption is enabled, mere disabling of interrupts won’t protect your critical region from being trampled. There is the possibility of multiple threads simultaneously using the critical section in process context. The solution, apparently, is to disable kernel preemption before the start of the critical section and re-enable it at the end. Spinlocks do that internally if CONFIG_PREEMPT is enabled:</p>
<p>如果内核是可以抢占的，仅仅只禁掉中断是不能保护你的临界区的，有可能多个线程在同一个进程上下文进入到同一临界区。很显然，解决方案是在进入临界区前禁用内核抢占然后在最后重新开启内核抢占。在可抢占的内核里面，自旋锁就是这样实现的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Marker to turn OFF preemption */</span></div><div class="line">spin_lock (&amp;mylock);    </div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/* Marker to turn ON preemption */</span></div><div class="line">spin_unlock (&amp;mylock);</div></pre></td></tr></table></figure>
<p>However, this still doesn’t prevent interrupt handlers from stomping through your critical section. Instead, use the IRQ variant of spinlocks:</p>
<p>然而，这仍然还是不能避免在临界区发生的中思。取而代之的是使用自旋锁的另一种实现IRQ:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Point A:</div><div class="line"> * Save interrupt state.</div><div class="line"> * Disable interrupts and preemption.</div><div class="line"> */	</div><div class="line">spin_lock_irqsave (&amp;mylock, flags);</div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Enable preemption. Restore interrupt state to that </div><div class="line"> * at Point A.</div><div class="line"> */</div><div class="line">spin_unlock_irqrestore (&amp;mylock, flags);</div></pre></td></tr></table></figure>
<p>Preemption state need not be restored to what it was at Point A, since the kernel does that for you via a variable called the preemption counter. The counter gets incremented whenever preemption is disabled (using the preempt_disable() function), and gets decremented whenever preemption is enabled (using the preempt_enable() function). Preemption kicks in only if the counter value is zero.</p>
<p>自从内核通过一个叫可抢占计数后，在Point A不需要保存抢占的状态。这个计数在抢占禁用(preempt_disable)时会增加,在启用(preempt_enable())时会减少计数。只有当这个计数为0的时候才是可以抢占的。</p>
<h4 id="Case-Three-PI-SMP-P"><a href="#Case-Three-PI-SMP-P" class="headerlink" title="Case Three: PI-SMP-P"></a>Case Three: PI-SMP-P</h4><p>Now assume that the critical section executes on an SMP machine and that your kernel has been configured with CONFIG_SMP and CONFIG_PREEMPT turned on.</p>
<p>假设我们的临界区在一个内核已经开启SMP和可抢占的SMP机器上</p>
<p>In the scenarios discussed so far, the spinlock primitives have done little other than enable and disable preemption and interrupts. The actual lock features have been compiled away.</p>
<p>到目前为止讨论的场景中, 自旋锁原语除了启用和禁用抢占和中断之外, 没有做什么。实际上锁的功能已被编译成汇编了。</p>
<p>In the presence of SMP, the actual locking logic gets compiled in, and the spinlock primitives are rendered SMP-safe. The SMP-enabled semantics is:</p>
<p>在SMP的机器上，锁的实现逻辑是通过编译器实现的，自旋锁原语提供了SMP安全，启用SMP的语义是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Point A:</div><div class="line"> * Save interrupt state on the local CPU</div><div class="line"> * Disable interrupts on the local CPU</div><div class="line"> * Disable preemption</div><div class="line"> * Lock the section to regulate access by other CPUs</div><div class="line"> */	</div><div class="line">spin_lock_irqsave (&amp;mylock, flags);</div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Enable preemption. Restore interrupt state to what </div><div class="line"> * it was at Point A for the local CPU.</div><div class="line"> * Release the lock.</div><div class="line"> */</div><div class="line">spin_unlock_irqrestore (&amp;mylock, flags);</div></pre></td></tr></table></figure>
<p>In the SMP case, only interrupts in the local CPU are disabled when the lock is acquired. If interrupts are not disabled in the local CPU, a deadlock might arise if an interrupt is generated while execution is in the middle of a critical section. (The interrupt handler sits in a tight spin, waiting for the lock to become available, but the critical section cannot complete until the interrupt handler itself finishes execution.) However, this danger of deadlock does not arise for interrupts generated on other CPUs, since an interrupt handler executing on processor A doesn’t prevent process context code on processor B from executing. The interrupt handler on processor A spins, waiting until processor B exits the critical section.</p>
<p>在SMP的情况下，当锁获取后只有当前CPU的中断会被禁用。如果当前CPU的中断没有被禁用，在执行临界区时产生另一个中断可能会产生一个死锁。(中断处理程序会处于紧急旋转状态，一直等待之前的锁被释，但是之前的临界区一直等着现有的中断程序处理的返回)。然而，在其它CPU上产生的中断不会出现死锁的危险，当一个中断程序在processor A上执行时不会阻止进程上下文的代码在processor B上的执行。中断处理程序在processor A一直旋转直到processor B离开临界区。</p>
<p>The kernel has specialized locking primitives in its repertoire that help improve performance under specific conditions. Using a mutual exclusion scheme tailored to your needs will make your code more powerful. Let’s take a look at some of the specialized exclusion mechanisms.</p>
<p>内核指令里有专门的锁定原语，在特定的条件下帮你提升性能。根据你的需要来使用一个互斥方案会使你的代码更加强大。让我们来看一些互斥机制。</p>
<h5 id="Atomic-Operators"><a href="#Atomic-Operators" class="headerlink" title="Atomic Operators"></a>Atomic Operators</h5><p>Atomic operators are used to perform lightweight operations like bumping counters, conditional increments, and setting bit positions, in one shot. Atomic operations are guaranteed to be serialized and do not need locks for protection against concurrent access. The implementation of atomic operators is architecture-dependent.</p>
<p>原子操作被用作执行一些轻微的动作，比如:碰撞计数、条件增量和设置bit位的位置.简而言之，原子操作确保有序并且不需要锁来保护并发访问。原子操作的实现是基于系统架构的。</p>
<p>For example, to check whether there are any remaining data references before freeing a kernel network buffer (called an skbuff), the skb_release_data() routine defined in net/core/skbuff.c does the following:</p>
<p>举个例子，用来检查是否有剩余的数据引用在内核释放网络缓冲(被称为<code>skbuff</code>)的数据,skb_release_data()函数的实现在<code>net/core/skbuff.c</code>里，内容如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!skb-&gt;cloned ||</div><div class="line">    <span class="comment">/* Atomically decrement and check the reference value */</span></div><div class="line">    atomic_dec_and_test(&amp;(skb_shinfo(skb)-&gt;dataref))) &#123;</div><div class="line">    <span class="comment">/* ... */</span>    </div><div class="line">    kfree(skb-&gt;head);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>While skb_release_data() is thus executing, another thread using the skbuff_clone() function (defined in the same file), might be simultaneously incrementing the data reference counter:</p>
<p>当<code>skb_release_data()</code>执行时，另一个线程可能同时增加这数据的引用计数通过使用<code>skbuff_clone</code>(在同一个文件中)函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* .. */</span></div><div class="line"></div><div class="line"><span class="comment">/* Atomically bump the reference count */</span></div><div class="line">atomic_inc(&amp;(skb_shinfo(skb)-&gt;dataref));</div><div class="line"></div><div class="line"><span class="comment">/* .. */</span></div></pre></td></tr></table></figure>
<p>The use of atomic operators protects the data reference counter from being trampled by these two threads. It also eliminates the hassle of using locks to protect a single integer variable from concurrent access.<br>The kernel also supports operators like set_bit(), clear_bit(), and test_and_set_bit(), to atomically manipulate a single bit.</p>
<p>使用原子操作保护数据的引用计数被多个线程碰撞。它还消除了使用来锁保护对单个整型变量的并发方问。<br>内核同样支持如:<code>set_bit()、clear_bit()和test_and_set_bit()</code>在一个bit位上执行原子操作</p>
<h5 id="Reader-Write-Locks"><a href="#Reader-Write-Locks" class="headerlink" title="Reader-Write Locks"></a>Reader-Write Locks</h5><p>The reader-writer variant of a spinlock is another specialized concurrency regulation mechanism. If the usage of a critical section is such that separate threads either read or write, but don’t do both, a reader-writer lock is a natural fit.<br>Multiple reader threads are allowed inside a critical region simultaneously. Reader spinlocks are defined as:</p>
<p>自旋锁的一个变种——读写锁是是另外一个特定的并发机制。临界区的使用被分离出读和写的线程，读和写不能同时获得，读写锁是设计巧秒的。<br>多个读线程可以同时在一个临界区。读的自旋锁定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">rwlock_t</span> myrwlock = RW_LOCK_UNLOCKED;</div><div class="line"></div><div class="line"> <span class="comment">/* Acquire reader lock */</span></div><div class="line">read_lock (&amp;myrwlock);   </div><div class="line"></div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release lock */</span></div><div class="line">read_unlock (&amp;myrwlock);</div></pre></td></tr></table></figure>
<p>However, if a writer thread enters a critical section, other reader or writer threads are not allowed inside. To use writer spinlocks, you’d write:</p>
<p>然而，当一个写的线程进入临界区时，其它尝试进入临界区的读或写的线程是不成功的。对写自旋锁的使用，你可能会这样使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">rwlock_t</span> myrwlock = RW_LOCK_UNLOCKED;</div><div class="line"></div><div class="line"><span class="comment">/* Acquire writer lock */</span></div><div class="line">write_lock (&amp;myrwlock);</div><div class="line"></div><div class="line"><span class="comment">/* ... Critical Region ... */</span></div><div class="line"></div><div class="line"><span class="comment">/* Release lock */</span></div><div class="line">write_unlock (&amp;myrwlock);</div></pre></td></tr></table></figure>
<p>Look at the Internetwork Packet Exchange (IPX) routing code in net/ipx/ipx_route.c for a real life example of reader-writer spinlock usage. A reader-writer lock called ipx_routes_lock protects the IPX routing table from simultaneous access. Threads that need to look-up the routing table to forward packets don’t have to write to the table and can request reader locks. However, threads that need to add or delete entries from the routing table have to acquire writer locks. This improves performance since there will usually be far more instances of routing table look-ups than routing table updates.<br>Like regular spinlocks, reader-writer locks also have corresponding irq versions, namely, read_lock_irqsave(), read_lock_irqrestore(), write_lock_irqsave(), and write_lock_irqrestore(). The semantics of these functions are similar to that discussed for regular spinlocks.</p>
<p>通过<code>net/ipx/ipx_route.c</code>里面IPX路由代码的实现来体验下读写自旋锁的使用。一个叫ipx_routes_lock的读写锁用来保护IPX路由表的并发访问。线程需要遍历路由表来发送网络包，因为不需要对这路由表写，所以可以请求的是读锁。然而需要新增或删除路由表里面的数据需要获取写锁。这样将对性能有很大的提升，因为会查询路由表的次数会比写的次数多。<br>像常规的自旋锁一样，读写锁一样有相对应的irq版本，叫做<code>read_lock_irqsave(),read_lock_irqrestor(),write_lock_irqsave()和 write_lock_irqrestore()</code>。这些函数的语义和之前讨论的自旋锁用法一样。</p>
<p>Corresponding reader-writer flavors of semaphores are, down_read(), down_write(), up_read(), and up_write().<br>Sequence locks or seqlocks, introduced in the 2.6 kernel, are reader-writer locks where writers are favored over readers. Writer threads do not wait for readers who may be inside a critical section. Because of this, reader threads may discover that their critical section operation has failed, and may need to retry:</p>
<p>相对应的信息量的读写的方式有<code>down_read(),down_write(),up_read()和up_write()</code>。在2.6内核里面介绍的序号锁是写锁比读锁更受欢迎的读写锁。写的线程不需要等待在临界区的读线程。因此，读的线程可以发现他们的临界区操作失败然后可能需要重新获取:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    seq = read_seqbegin (&amp;mylock);</div><div class="line">    <span class="comment">/* ... Critical Section */</span></div><div class="line">&#125; <span class="keyword">while</span> (read_seqtry (&amp;mylock, seq));</div></pre></td></tr></table></figure>
<p>Writers protect critical regions using write_seqlock() and write_sequnlock().<br>The 2.6 kernel introduced another mechanism called Read-Copy Update (RCU) that can yield improved performance in cases where readers far outnumber writers. The basic idea is that reader threads can execute without locking. Writer threads are more complex: each performs update operations on a copy of the data structure and replaces the pointer that readers will see. The original copy is maintained until the next context switch to ensure completion of all ongoing read operations. (Be aware that using RCU is more involved than using the primitives discussed thus far, and should be used only if you are sure that it’s the right tool for the job. There’s ample documentation in the kernel tree in Documentation/RCU/*.)<br>For an example on using RCU, look at fs/dcache.c. In Linux, each file is associated with directory entry information (stored in a structure called dentry), meta data information (stored in an inode), and actual data (stored in data blocks). Each time you operate on a file, the components in the file path are traversed and corresponding dentries are created. The dentries are kept cached in a data structure called the dcache to speed up future operations. At any time, the number of dcache lookups will be much more than dcache updates, so references to the dcache are protected using RCU primitives.</p>
<p>写的线程使用 write_seqlock () 和 write_sequnlock () 保护关键区域。<br>2.6 内核引入了另一个称为读拷贝更新的机制, 在读者远远超过作者的情况下, 可以提高性能。基本思想是, 读取器线程无需锁定即可执行。写线程更为复杂: 每一个都对数据结构的副本执行更新操作, 并替换读者将看到的指针。原始副本一直保持到下一上下文切换, 以确保所有正在进行的读取操作完成。(请注意, 使用RCU比使用上面讨论过的原语更复杂难懂, 只有当您确信它对你正在进行的任务是正确的工具才使用。内核在Documentation/RCU/*中有足够的文件对其说明。<br>举一个使用RCU的例子, 请查看 fs/dcache。在 Linux 中, 每个文件都与目录条目信息 (存储在称为 dentry 的结构中)、元数据信息 (存储在 inode 中) 和实际数据 (存储在数据块中) 相关联。每次对文件进行操作时, 都会遍历文件路径中的组件, 并创建相应的 dentries。dentries 被保存在一个称为 dcache 的数据结构中, 以加速未来的操作。在任何时候, dcache 查找的数量将远远超过 dcache 的更新, 因此对 dcache 的引用是使用协调单位原语进行保护的。</p>
<h5 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h5><p>Concurrency-related problems are generally hard to debug since they are usually difficult to reproduce. It’s a good idea to enable SMP (CONFIG_SMP) and preemption (CONFIG_PREEMPT) while compiling and testing your code, even if your production kernel is going to run on a UP machine with preemption disabled. There is a configuration option under Kernel Hacking called Spinlock Debugging (CONFIG_DEBUG_SPINLOCK) that can help you catch some common spinlock errors. Also, tools like lockmeter (<a href="http://oss.sgi.com/projects/lockmeter/" target="_blank" rel="external">http://oss.sgi.com/projects/lockmeter/</a>) can be used to collect lock-related statistics.<br>The most common concurrency problem occurs when you forget to lock an access to a shared resource. This results in different threads “racing” through that access in an unregulated manner. The problem (called a race condition) may appear in the form of occasional strange code behavior.<br>Another potential problem arises when you miss releasing held locks in certain code paths, resulting in deadlocks. To get a hang of this, consider the following example:</p>
<p>并发相关的问题通常很难调试,因为它们通常很难重现。在编译和测试代码时启用 SMP (CONFIG_SMP) 和抢占 (CONFIG_PREEMPT) 是个好主意，即使你的生产环境内核运行在一个不可中断的单核机器。在内核里面有个叫Spinlock Debugging(CONFIG_DEBUG_SPINLOCK)的配置选项，这个可以帮助你发现一些常见的自旋锁的错误。当然，类似<code>lockmeter</code>(<a href="http://oss.sgi.com/projects/lockmeter/)的工具同样可以用来收集锁信息的信息。" target="_blank" rel="external">http://oss.sgi.com/projects/lockmeter/)的工具同样可以用来收集锁信息的信息。</a></p>
<p>当您忘记锁定对共享资源的访问时, 会发生最常见的并发问题。这种不常规的访问方式会导致不同的线程同步问题。这个问题(数据竞争情况)可能偶尔出现奇奇怪怪的代码行为</p>
<p>另一个潜在的问题是，当你忘记代码中忘记对获得的锁进行释放时，就会导致死锁的问题。为了理解这个，考虑下下面的例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Acquire lock */</span></div><div class="line">spin_lock (&amp;mylock);    </div><div class="line"></div><div class="line"><span class="comment">/* ... Critical Section ... */</span></div><div class="line"></div><div class="line"><span class="comment">/* Assume that error is very rare </span></div><div class="line"> *</div><div class="line"> * I forgot to release the lock! </div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (error) &#123;    </div><div class="line">   <span class="keyword">return</span> -EIO; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Release lock */</span></div><div class="line">spin_unlock (&amp;mylock);</div></pre></td></tr></table></figure>
<p>After the occurrence of the error condition, any thread trying to acquire mylock gets deadlocked, and the kernel may freeze.<br>If the problem first manifests months or years after you write the code, it’s that much harder to go back and debug it. To avoid such unpleasant encounters, concurrency logic should be designed systematically at the beginning, when you architect your software.</p>
<p>在error条件判断出现的后面，任一尝试获取锁的线程都会死锁，系统可能会冻结住(死循环了)。如果问题首先体现在编写代码后的几个月或数年, 那么返回并调试它会更加困难。为了避免这种不愉快的遭遇, 在构建软件时, 应该在开始时系统地设计并发逻辑。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/linux-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/linux-thread/" itemprop="url">linux-thread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T14:40:06+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你是否知道进程和线程的关系？是否知道(user/kernel) space thread以及LWP之间的区别和关系。<br>以及操作系统如何调度它们的？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/linux-cpu-core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/linux-cpu-core/" itemprop="url">linux-cpu-core</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T11:44:59+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计算机从单任务到多任务的发展也是对应的CPU的处理能力。现在的系统基本都是多核的系统并有着更高的系统吞吐能力。</p>
<p>平常只是脑海中有这些概念，并没有通过某些方法去论证这些东西。</p>
<p>在linux上面我们所有CPU相关的信息可以在<code>/proc/cpuinfo</code>文件里面可以看到，我们可以看到以下信息:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查看CPU信息（型号）</span></div><div class="line">[root@local ~]<span class="comment"># cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span></div><div class="line">     <span class="number">24</span>         Intel(R) Xeon(R) CPU E5-<span class="number">2630</span> <span class="number">0</span> @ <span class="number">2.30</span>GHz</div><div class="line"></div><div class="line"><span class="comment"># 查看物理CPU个数</span></div><div class="line">[root@local ~]<span class="comment"># cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l</span></div><div class="line"><span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment"># 查看每个物理CPU中core的个数(即核数)</span></div><div class="line">[root@local ~]<span class="comment"># cat /proc/cpuinfo| grep "cpu cores"| uniq</span></div><div class="line">cpu cores    : <span class="number">6</span></div><div class="line"></div><div class="line"><span class="comment"># 查看逻辑CPU的个数</span></div><div class="line">[root@local ~]<span class="comment"># cat /proc/cpuinfo| grep "processor"| wc -l</span></div><div class="line"><span class="number">24</span></div></pre></td></tr></table></figure>
<p><strong>以上各信息有如下关系:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数 </div><div class="line">总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</div></pre></td></tr></table></figure>
<p><span style="color:blue;"><strong>从上面执行的结果来看，证明我使用的cpu有2 * 6 = 12核，每个核有2个超线程，所以有24个逻辑cpu。</strong></span></p>
<p>我们来看各CPU的架构</p>
<p><strong>多个物理CPU，CPU通过总线进行通信，效率比较低，如下：</strong></p>
<p><img src="../../../../images/cpu_single_core.jpg" alt=""></p>
<p><em>多核CPU，不同的核通过L2 cache进行通信，存储和外设通过总线与CPU通信，如下：*</em></p>
<p><img src="../../../../images/cpu_multi_core.jpg" alt=""></p>
<p><strong>多核超线程,每个核有两个逻辑的处理单元，两个核共同分享一个核的资源，如下：</strong></p>
<p><img src="../../../../images/cpu_multi_core_super.jpg" alt=""></p>
<p><a href="http://www.cnblogs.com/bugutian/p/6138880.html" target="_blank" rel="external">参数</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/30/linux-tcp-ip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/30/linux-tcp-ip/" itemprop="url">tcp/ip</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T10:53:32+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于之前所学没有系统性的对网络这块的知识也没个详细学习过程，对于<code>http</code>、<code>tcp/ip</code>这些东西还只是停留在使用层面，但具体对系统是如何实现的原理无所适从。一个东西只要<br>弄清楚原理后，对这东西的使用就如刨丁解牛。</p>
<blockquote>
<p>对一个东西的理解不能停留在表面，也不要感性的理解一个东西，我们需要看到一个东西<br>本质</p>
</blockquote>
<p>我们平常生活中用电脑、手机很方便的上网或和它人聊天，这里就用到一些类似http、tcp等<br>技术实现，不同电脑或手机能识别其它设备发过来的东西要利益于互联网以及很早以前制订的<br>OSI模型。</p>
<blockquote>
<p>国际标准化组织ISO在1979年建立了一个分委员会来专门研究一种用于开放系统的体系结构，<br>提出了开放系统互连OSI模型，这是一个定义连接异种计算机的标准主体结构。</p>
</blockquote>
<p><img src="../../../../images/osi_layer.png" alt="flow"></p>
<p><img src="../../../../images/osi_protocol.png" alt="flow"></p>
<p>下面是自己根据现实实际情况非官方的语言版的理解:</p>
<ul>
<li><p>物理层<br>相对于接收数据而言，是把发过来的信号转成机器识别的数据<br>相对于发送数据来说，是把数据转化成信号在线路上传递。<br><strong>也就是说设备之间沟通的第一个媒介及其连接</strong></p>
</li>
<li><p>数据链路层</p>
</li>
</ul>
<p>相对于维护网络中需要通信的一条路，用来传递数据，只是这个数据是以帧来定义</p>
<ul>
<li>网络层</li>
</ul>
<p>这层标识了网络中两个实体的数据用的什么协议从哪里到哪里。</p>
<ul>
<li>传输层</li>
</ul>
<p>数据的包的传送，保证消息的有序性，你抓包看到的seq ack等.我们平常用read读和写在这层</p>
<ul>
<li>会话层</li>
</ul>
<p>也不知道怎么描述</p>
<ul>
<li>表示层</li>
</ul>
<p>主要定义数据格式以及加密</p>
<ul>
<li>应用层</li>
</ul>
<p>http、telnet等都是实现了应用层</p>
<h3 id="网络数据流向"><a href="#网络数据流向" class="headerlink" title="网络数据流向"></a>网络数据流向</h3><p>一个网络数据包会经过多层路由器转发，所以下图是一个包从一个机器发出到达另外一台机器的示意图</p>
<p><img src="../../../../images/data_flow.jpg" alt="flow"></p>
<h3 id="TCP简述"><a href="#TCP简述" class="headerlink" title="TCP简述"></a>TCP简述</h3><p>大家都知道tcp是一个面向连接的，可靠的，基于字节流的位于传输层的通信协议。</p>
<p><img src="../../../../images/protocol-stack.jpg" alt="flow"></p>
<p><img src="../../../../images/tcp-ip.png" alt="flow"></p>
<p><img src="../../../../images/tcp_header.png" alt="flow"></p>
<p> 其中不携带选项的TCP头如下图所示(其中阴影部分的四个字段表示了相反方向的数据流信息)，其中header length字段由4比特构成，最大为15，单位是32比特(32-bit word)，即头长的最大值为15*32 bits = 60bytes，因此上面说携带选项的TCP头长最长为60bytes。</p>
<p><img src="../../../../images/tcpdump.png" alt="flow"></p>
<p>根据上面的图，tcp_header以及tcpdump日志截图，我们可以知道内部的一些实现</p>
<p>上图中有几个字段需要重点介绍下：<br>  （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>  （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。<br>  （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<br>  （A）URG：紧急指针（urgent pointer）有效。<br>  （B）ACK：确认序号有效。<br>  （C）PSH：接收方应该尽快将这个报文交给应用层。<br>  （D）RST：重置连接。<br>  （E）SYN：发起一个新连接。<br>  （F）FIN：释放一个连接。</p>
<p>通过tcpdump日志的截图我们发现，回包的ACK都是发送方SEQ+1是告诉发送方你下次包的序号是ACK代码的</p>
<p><img src="http://www.cnblogs.com/lshs/p/6038458.html" alt="参考"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/28/部署脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/28/部署脚本/" itemprop="url">部署脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-28T15:55:54+08:00">
                2017-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/脚本/" itemprop="url" rel="index">
                    <span itemprop="name">脚本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发工作做好后，我们经常要发布到其它的服务器上，外网的服务器配置是不一样。<br>所以我们把配置做成模版是有必要的，把需要变更部分用脚本把它替换掉。</p>
<p>有时间也学习<code>python</code>脚本，<code>python</code>脚本现在都成<code>linux</code>标配脚本了，这是一门很<br>强大的脚本语言。</p>
<blockquote>
<p>既然现在用的<code>markdown</code>生成的<code>html</code>都不支持<code>shell</code>高亮，只支持<code>bash</code></p>
</blockquote>
<p><strong>模版变量:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># 这里的变量用于替换模版配置需要替换的值</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line"><span class="comment"># 游戏服ip</span></div><div class="line">GAME_IP=<span class="string">"127.0.0.1"</span></div><div class="line"><span class="comment"># 游戏服端口</span></div><div class="line">GAME_PORT=<span class="string">":7206"</span></div><div class="line"><span class="comment"># 游戏服地址</span></div><div class="line">GAME_HOST=<span class="string">"<span class="variable">$&#123;GAME_IP&#125;</span><span class="variable">$&#123;GAME_PORT&#125;</span>"</span></div><div class="line"><span class="comment"># 大厅IP地址(只有IP)</span></div><div class="line">HALL_IP=<span class="string">"127.0.0.1"</span></div><div class="line"><span class="comment"># 网关地址</span></div><div class="line"></div><div class="line">GATEWAY_HOST=<span class="string">"127.0.0.1:7208"</span></div><div class="line"></div><div class="line"><span class="comment"># 数据库连接</span></div><div class="line">DB_HOST=<span class="string">"postgres://postgres:qingyuan,123@192.168.1.1.123:5432/platform_test?sslmode=disable"</span></div><div class="line"><span class="comment"># redis服务器</span></div><div class="line">REDIS_HOST=<span class="string">"39.108.10.12:26310"</span></div><div class="line"><span class="comment"># redis密码</span></div><div class="line">REDIS_PASSWD=<span class="string">"af623spo"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 七牛回放文件的存放目录</span></div><div class="line">QINIU_DIR=<span class="string">"playback_dev"</span></div><div class="line"></div><div class="line"><span class="comment"># 微信订单回调配置</span></div><div class="line">NOTIFYURL=<span class="string">"http://127.0.0.1:8090/paynotify"</span></div><div class="line"></div><div class="line"><span class="comment"># 统计服地址</span></div><div class="line">ROUNDPATH=<span class="string">"rank/rankRoundDev"</span>       <span class="comment">#局数榜的7牛地址  默认为rank/rankRound</span></div><div class="line">CHARGEPATH=<span class="string">"rank/rankChargeDev"</span>      <span class="comment">#充值榜的7牛地址  默认为rank/rankCharge</span></div><div class="line"></div><div class="line"><span class="comment"># 声明一个键值对数组</span></div><div class="line"><span class="built_in">declare</span> -A STR_ARR</div><div class="line">STR_ARR=([DB_HOST]=<span class="variable">$&#123;DB_HOST&#125;</span> [REDIS_HOST]=<span class="variable">$&#123;REDIS_HOST&#125;</span> [REDIS_PASSWD]=<span class="variable">$&#123;REDIS_PASSWD&#125;</span> \</div><div class="line">         [HALL_IP]=<span class="variable">$&#123;HALL_IP&#125;</span> [GATEWAY_HOST]=<span class="variable">$&#123;GATEWAY_HOST&#125;</span> [GAME_PORT]=<span class="variable">$&#123;GAME_PORT&#125;</span> \</div><div class="line">          [GAME_HOST]=<span class="variable">$&#123;GAME_HOST&#125;</span>  [QINIU_DIR]=<span class="variable">$&#123;QINIU_DIR&#125;</span> [NOTIFYURL]=<span class="variable">$&#123;NOTIFYURL&#125;</span> \</div><div class="line">           [ROUNDPATH]=<span class="variable">$&#123;ROUNDPATH&#125;</span> [CHARGEPATH]=<span class="variable">$&#123;CHARGEPATH&#125;</span> )</div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!STR_ARR[*]&#125;</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;key&#125;</span>   -----&gt; <span class="variable">$&#123;STR_ARR[$key]&#125;</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p><strong>替换模版的脚本:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">CUR_DIR=$(dirname $(readlink <span class="_">-f</span> <span class="variable">$0</span>))</div><div class="line"></div><div class="line"><span class="comment"># 用模版文件生成FILES里面的配置</span></div><div class="line"></div><div class="line">COLOR_RED=<span class="string">'\033[0;31m'</span></div><div class="line">COLOR_GREEN=<span class="string">'\033[0;32m'</span></div><div class="line">COLOR_RESET=<span class="string">'\033[0m'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="variable">$CUR_DIR</span>/public_conf.sh ]; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"<span class="variable">$COLOR_RED</span>  file <span class="variable">$CUR_DIR</span>/public_conf.sh not exit <span class="variable">$COLOR_RESET</span>"</span></div><div class="line">    <span class="built_in">exit</span> 2</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">source</span> <span class="variable">$CUR_DIR</span>/public_conf.sh</div><div class="line"></div><div class="line"><span class="built_in">read</span> -p <span class="string">"请确认下是否正确，确认输入 yes : "</span> var</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$var</span>"</span> ] || [ <span class="string">"<span class="variable">$var</span>"</span>x != <span class="string">"yes"</span>x ] ; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"<span class="variable">$COLOR_RED</span> 错误的输入:<span class="variable">$var</span> <span class="variable">$COLOR_RESET</span>"</span></div><div class="line">    <span class="built_in">exit</span> 3</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line">FILES=(</div><div class="line">    config.toml \</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">copyFile</span></span>()&#123;</div><div class="line">    file=<span class="variable">$1</span></div><div class="line">    name=<span class="variable">$&#123;file%%.*&#125;</span></div><div class="line">    <span class="keyword">if</span> [ ! <span class="_">-f</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$file</span>"</span> ]; <span class="keyword">then</span></div><div class="line">        cp <span class="_">-f</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$&#123;name&#125;</span>_template.toml"</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$file</span>"</span></div><div class="line">        <span class="keyword">if</span> [ <span class="variable">$file</span> == <span class="string">"config.toml"</span> ]; <span class="keyword">then</span></div><div class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!STR_ARR[*]&#125;</span></div><div class="line">            <span class="keyword">do</span></div><div class="line">                sed -i <span class="string">"s#<span class="variable">$&#123;key&#125;</span>#<span class="variable">$&#123;STR_ARR[$key]&#125;</span>#g"</span> <span class="string">"<span class="variable">$CUR_DIR</span>/<span class="variable">$file</span>"</span></div><div class="line">            <span class="keyword">done</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;FILES[*]&#125;</span> ; <span class="keyword">do</span></div><div class="line">  copyFile <span class="variable">$file</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/malloc/" itemprop="url">malloc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T13:35:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存管理转载"><a href="#内存管理转载" class="headerlink" title="内存管理转载"></a>内存管理转载</h3><p>一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。<br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">原文</a></p>
<div class="entry-content"><br><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/htvm3.png" alt="Hack the VM!" scale="0"></p><br><p>This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.</p><br><p>If you missed the previous chapters, you should probably start there:</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br></ul><br><h2>The heap</h2><br><p>In this chapter we will look at the heap and <code>malloc</code> in order to answer some of the questions we ended with at the end of the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>:</p><br><ul><br><li>Why doesn’t our allocated memory start at the very beginning of the heap (0x2050010 vs 02050000)? What are those first 16 bytes used for?</li><br><li>Is the heap actually growing upwards?</li><br></ul><br><h2>Prerequisites</h2><br><p>In order to fully understand this article, you will need to know:</p><br><ul><br><li>The basics of the C programming language (especially pointers)</li><br><li>The very basics of the Linux filesystem and the shell</li><br><li>We will also use the <code>/proc/[pid]/maps</code> file (see <code>man proc</code> or read our first article <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory, chapter 0: C strings &amp; /proc</a>)</li><br></ul><br><h2>Environment</h2><br><p>All scripts and programs have been tested on the following system:</p><br><ul><br><li>Ubuntu<br><ul><br><li>Linux ubuntu 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</li><br></ul><br></li><br></ul><br><p>Tools used:</p><br><ul><br><li>gcc<br><ul><br><li>gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4</li><br></ul><br></li><br><li>glibc 2.19 (see <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break/version.c" target="_blank" rel="external">version.c</a> if you need to check your glibc version)</li><br><li>strace<br><ul><br><li>strace — version 4.8</li><br></ul><br></li><br></ul><br><p><strong>Everything we will write will be true for this system/environment, but may be different on another system</strong></p><br><p>We will also go through the Linux source code. If you are on Ubuntu, you can download the sources of your current kernel by running this command:</p><br><pre><code>apt-get source linux-image-$(uname -r)<br></code></pre><br><h2><code>malloc</code></h2><br><p><code>malloc</code> is the common function used to dynamically allocate memory. This memory is allocated on the “heap”.<br><br><em>Note: <code>malloc</code> is not a system call.</em></p><br><p>From <code>man malloc</code>:</p><br><pre><code>[…] allocate dynamic memory[…]<br>void <em>malloc(size_t size);<br>[…]<br>The malloc() function allocates size bytes and returns a pointer to the allocated memory.<br></em></code></pre><br><h3>No malloc, no [heap]</h3><br><p>Let’s look at memory regions of a process that does not call <code>malloc</code> (<code>0-main.c</code>).</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <stdio.h>;<br><br>/**
  main - do nothing<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br><br></em></stdio.h></stdlib.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 0-main.c -o 0<br>julien@holberton:~/holberton/w/hackthevm3$ ./0<br><br></code></pre><br><p><em>Quick reminder (1/3): the memory regions of a process are listed in the <code>/proc/[pid]/maps</code> file. As a result, we first need to know the PID of the process. That is done using the <code>ps</code> command; the second column of <code>ps aux</code> output will give us the PID of the process. Please read <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">chapter 0</a> to learn more.</em></p><br><pre><code>julien@holberton:/tmp$ ps aux | grep \ ./0$<br>julien     3638  0.0  0.0   4200   648 pts/9    S+   12:01   0:00 ./0<br></code></pre><br><p><em>Quick reminder (2/3): from the above output, we can see that the PID of the process we want to look at is <code>3638</code>. As a result, the <code>maps</code> file will be found in the directory <code>/proc/3638</code>.</em></p><br><pre><code>julien@holberton:/tmp$ cd /proc/3638<br></code></pre><br><p><em>Quick reminder (3/3): The <code>maps</code> file contains the memory regions of the process. The format of each line in this file is:<br><br>address           perms offset  dev   inode       pathname</em></p><br><pre><code>julien@holberton:/proc/3638$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00600000-00601000 r–p 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00601000-00602000 rw-p 00001000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>7f38f87d7000-7f38f8991000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8991000-7f38f8b91000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b91000-7f38f8b95000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b95000-7f38f8b97000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b97000-7f38f8b9c000 rw-p 00000000 00:00 0<br>7f38f8b9c000-7f38f8bbf000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8da3000-7f38f8da6000 rw-p 00000000 00:00 0<br>7f38f8dbb000-7f38f8dbe000 rw-p 00000000 00:00 0<br>7f38f8dbe000-7f38f8dbf000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dbf000-7f38f8dc0000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dc0000-7f38f8dc1000 rw-p 00000000 00:00 0<br>7ffdd85c5000-7ffdd85e6000 rw-p 00000000 00:00 0                          [stack]<br>7ffdd85f2000-7ffdd85f4000 r–p 00000000 00:00 0                          [vvar]<br>7ffdd85f4000-7ffdd85f6000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/3638$<br></code></pre><br><p><em>Note: <code>hackthevm3</code> is a symbolic link to <code>hack_the_virtual_memory/03. The Heap/</code></em></p><br><p>-&gt;; As we can see from the above maps file, there’s no [heap] region allocated.</p><br><h3><code>malloc(x)</code></h3><br><p>Let’s do the same but with a program that calls <code>malloc</code> (<code>1-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - 1 call to malloc<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    malloc(1);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 1-main.c -o 1<br>julien@holberton:~/holberton/w/hackthevm3$ ./1<br><br></code></pre><br><pre><code>julien@holberton:/proc/3638$ ps aux | grep \ ./1$<br>julien     3718  0.0  0.0   4332   660 pts/9    S+   12:09   0:00 ./1<br>julien@holberton:/proc/3638$ cd /proc/3718<br>julien@holberton:/proc/3718$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00600000-00601000 r–p 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00601000-00602000 rw-p 00001000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>01195000-011b6000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3718$<br></code></pre><br><p>-&gt;; the [heap] is here.</p><br><p>Let’s check the return value of <code>malloc</code> to make sure the returned address is in the heap region (<code>2-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - prints the malloc returned address<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br><br>    p = malloc(1);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 2-main.c -o 2<br>julien@holberton:~/holberton/w/hackthevm3$ ./2<br>0x24d6010<br><br></code></pre><br><pre><code>julien@holberton:/proc/3718$ ps aux | grep \ ./2$<br>julien     3834  0.0  0.0   4336   676 pts/9    S+   12:48   0:00 ./2<br>julien@holberton:/proc/3718$ cd /proc/3834<br>julien@holberton:/proc/3834$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00600000-00601000 r–p 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00601000-00602000 rw-p 00001000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>024d6000-024f7000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3834$<br></code></pre><br><p>-&gt;; <code>024d6000</code> &lt;<code>0x24d6010</code> &lt; <code>024f7000</code></p><br><p>The returned address is inside the heap region. And as we have seen in the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>, the returned address does not start exactly at the beginning of the region; we’ll see why later.</p><br><h2><code>strace</code>, <code>brk</code> and <code>sbrk</code></h2><br><p><code>malloc</code> is a “regular” function (as opposed to a system call), so it must call some kind of syscall in order to manipulate the heap. Let’s use <code>strace</code> to find out.</p><br><p><code>strace</code> is a program used to trace system calls and signals. Any program will always use a few syscalls before your <code>main</code> function is executed. In order to know which syscalls are used by <code>malloc</code>, we will add a <code>write</code> syscall before and after the call to <code>malloc</code>(<code>3-main.c</code>).</p><br><pre><code>#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> main - let’s find out which syscall malloc is using
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC\n”, 14);<br>    p = malloc(1);<br>    write(1, “AFTER MALLOC\n”, 13);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></strong></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 3-main.c -o 3<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./3<br>execve(“./3”, [“./3”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC\n”, 14BEFORE MALLOC<br>)         = 14<br>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br>write(1, “AFTER MALLOC\n”, 13AFTER MALLOC<br>)          = 13<br>…<br>read(0,<br></em></code></pre><br><p>From the above listing we can focus on this:</p><br><pre><code>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br></code></pre><br><p>-&gt;; <code>malloc</code> is using the <code>brk</code> system call in order to manipulate the heap. From <code>brk</code> man page (<code>man brk</code>), we can see what this system call is doing:</p><br><pre><code>…<br>       int brk(void addr);<br>       void *sbrk(intptr_t increment);<br>…<br>DESCRIPTION<br>       brk() and sbrk() change the location of the program  break,  which  defines<br>       the end of the process’s data segment (i.e., the program break is the first<br>       location after the end of the uninitialized data segment).  Increasing  the<br>       program  break has the effect of allocating memory to the process; decreas‐<br>       ing the break deallocates memory.<br><br>       brk() sets the end of the data segment to the value specified by addr, when<br>       that  value  is  reasonable,  the system has enough memory, and the process<br>       does not exceed its maximum data size (see setrlimit(2)).<br><br>       sbrk() increments the program’s data space  by  increment  bytes.   Calling<br>       sbrk()  with  an increment of 0 can be used to find the current location of<br>       the program break.<br></code></pre><br><p>The program break is the address of the first location beyond the current end of the data region of the program in the virual memory.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-before.png" alt="program break before the call to malloc / brk" scale="0"></p><br><p>By increasing the value of the program break, via <code>brk</code> or <code>sbrk</code>, the function <code>malloc</code> creates a new space that can then be used by the process to dynamically allocate memory (using <code>malloc</code>).</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-after.png" alt="program break after the malloc / brk call" scale="0"></p><br><p>So the heap is actually an extension of the data segment of the program.</p><br><p>The first call to <code>brk</code> (<code>brk(0)</code>) returns the current address of the program break to <code>malloc</code>. And the second call is the one that actually creates new memory (since <code>0xe91000</code> &gt;; <code>0xe70000</code>) by increasing the value of the program break. In the above example, the heap is now starting at <code>0xe70000</code> and ends at <code>0xe91000</code>. Let’s double check with the <code>/proc/[PID]/maps</code> file:</p><br><pre><code>julien@holberton:/proc/3855$ ps aux | grep \ ./3$<br>julien     4011  0.0  0.0   4748   708 pts/9    S+   13:04   0:00 strace ./3<br>julien     4014  0.0  0.0   4336   644 pts/9    S+   13:04   0:00 ./3<br>julien@holberton:/proc/3855$ cd /proc/4014<br>julien@holberton:/proc/4014$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00600000-00601000 r–p 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00601000-00602000 rw-p 00001000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/4014$<br></code></pre><br><p>-&gt;; <code>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]</code> matches the pointers returned back to <code>malloc</code> by <code>brk</code>.</p><br><p>That’s great, but wait, why did<code>malloc</code> increment the heap by <code>00e91000</code> – <code>00e70000</code> = <code>0x21000</code> or <code>135168</code> bytes, when we only asked for only 1 byte?</p><br><h2>Many mallocs</h2><br><p>What will happen if we call <code>malloc</code> several times? (<code>4-main.c</code>)</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<br> <em> main - many calls to malloc
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC #0\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #0\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #1\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #1\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #2\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #2\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #3\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #3\n”, 16);<br>    printf(“%p\n”, p);<br><br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 4-main.c -o 4<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./4<br>execve(“./4”, [“./4”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC #0\n”, 17BEFORE MALLOC #0<br>)      = 17<br>brk(0)                                  = 0x1314000<br>brk(0x1335000)                          = 0x1335000<br>write(1, “AFTER MALLOC #0\n”, 16AFTER MALLOC #0<br>)       = 16<br>…<br>write(1, “0x1314010\n”, 100x1314010<br>)             = 10<br>write(1, “BEFORE MALLOC #1\n”, 17BEFORE MALLOC #1<br>)      = 17<br>write(1, “AFTER MALLOC #1\n”, 16AFTER MALLOC #1<br>)       = 16<br>write(1, “0x1314420\n”, 100x1314420<br>)             = 10<br>write(1, “BEFORE MALLOC #2\n”, 17BEFORE MALLOC #2<br>)      = 17<br>write(1, “AFTER MALLOC #2\n”, 16AFTER MALLOC #2<br>)       = 16<br>write(1, “0x1314830\n”, 100x1314830<br>)             = 10<br>write(1, “BEFORE MALLOC #3\n”, 17BEFORE MALLOC #3<br>)      = 17<br>write(1, “AFTER MALLOC #3\n”, 16AFTER MALLOC #3<br>)       = 16<br>write(1, “0x1314c40\n”, 100x1314c40<br>)             = 10<br>…<br>read(0,<br></em></code></pre><br><p>-&gt;; <code>malloc</code> is NOT calling <code>brk</code> each time we call it.</p><br><p>The first time, <code>malloc</code> creates a new space (the heap) for the program (by increasing the program break location). The following times, <code>malloc</code> uses the same space to give our program “new” chunks of memory. Those “new” chunks of memory are part of the memory previously allocated using <code>brk</code>. This way, <code>malloc</code> doesn’t have to use syscalls (<code>brk</code>) every time we call it, and thus it makes <code>malloc</code> – and our programs using <code>malloc</code> – faster. It also allows <code>malloc</code> and <code>free</code> to optimize the usage of the memory.</p><br><p>Let’s double check that we have only one heap, allocated by the first call to <code>brk</code>:</p><br><pre><code>julien@holberton:/proc/4014$ ps aux | grep \ ./4$<br>julien     4169  0.0  0.0   4748   688 pts/9    S+   13:33   0:00 strace ./4<br>julien     4172  0.0  0.0   4336   656 pts/9    S+   13:33   0:00 ./4<br>julien@holberton:/proc/4014$ cd /proc/4172<br>julien@holberton:/proc/4172$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00600000-00601000 r–p 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00601000-00602000 rw-p 00001000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>01314000-01335000 rw-p 00000000 00:00 0                                  [heap]<br>7f4a3f2c4000-7f4a3f47e000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f47e000-7f4a3f67e000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f67e000-7f4a3f682000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f682000-7f4a3f684000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f684000-7f4a3f689000 rw-p 00000000 00:00 0<br>7f4a3f689000-7f4a3f6ac000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f890000-7f4a3f893000 rw-p 00000000 00:00 0<br>7f4a3f8a7000-7f4a3f8ab000 rw-p 00000000 00:00 0<br>7f4a3f8ab000-7f4a3f8ac000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ac000-7f4a3f8ad000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ad000-7f4a3f8ae000 rw-p 00000000 00:00 0<br>7ffd1ba73000-7ffd1ba94000 rw-p 00000000 00:00 0                          [stack]<br>7ffd1bbed000-7ffd1bbef000 r–p 00000000 00:00 0                          [vvar]<br>7ffd1bbef000-7ffd1bbf1000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/4172$<br></code></pre><br><p>-&gt;; We have only one [heap] and the addresses match those returned by <code>sbrk</code>: <code>0x1314000</code> &amp; <code>0x1335000</code></p><br><h2>Naive malloc</h2><br><p>Based on the above, and assuming we won’t ever need to free anything, we can now write our own (naive) version of <code>malloc</code>, that would move the program break each time it is called.</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  malloc - naive version of malloc: dynamically allocates memory on the heap using sbrk<br> <em> @size: number of bytes to allocate                                                          
 </em><br> <em> Return: the memory address newly allocated, or NULL on error                                
 </em><br> <em> Note: don’t do this at home :)                                                              
 </em>/<br>void <em>malloc(size_t size)<br>{<br>    void </em>previous_break;<br><br>    previous_break = sbrk(size);<br>    /<em> check for error </em>/<br>    if (previous_break == (void <em>) -1)<br>    {<br>        /</em> on error malloc returns NULL <em>/<br>        return (NULL);<br>    }<br>    return (previous_break);<br>}<br></em></unistd.h></stdlib.h></code></pre><br><h2>The 0x10 lost bytes</h2><br><p>If we look at the output of the previous program (<code>4-main.c</code>), we can see that the first memory address returned by <code>malloc</code> doesn’t start at the beginning of the heap, but <code>0x10</code> bytes after: <code>0x1314010</code> vs <code>0x1314000</code>. Also, when we call <code>malloc(1024)</code> a second time, the address should be <code>0x1314010</code> (the returned value of the first call to <code>malloc</code>) + <code>1024</code> (or <code>0x400</code> in hexadecimal, since the first call to <code>malloc</code> was asking for <code>1024</code> bytes) = <code>0x1318010</code>. But the return value of the second call to <code>malloc</code> is <code>0x1314420</code>. We have lost <code>0x10</code> bytes again! Same goes for the subsequent calls.</p><br><p>Let’s look at what we can find inside those “lost” <code>0x10</code>-byte memory spaces (<code>5-main.c</code>) and whether the memory loss stays constant:</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  pmem - print mem<br> <em> @p: memory address to start printing from                                                   
 </em> @bytes: number of bytes to print<br> <em>                                                                                             
 </em> Return: nothing<br> <em>/<br>void pmem(void </em>p, unsigned int bytes)<br>{<br>    unsigned char <em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char </em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, <em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/**
 </em> main - the 0x10 lost bytes<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br>    int i;<br><br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1));<br>        printf(“%p\n”, p);<br>        printf(“bytes at %p:\n”, (void </em>)((char <em>)p - 0x10));<br>        pmem((char </em>)p - 0x10, 0x10);<br>    }<br>    return (EXIT_SUCCESS);<br>}<br></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 5-main.c -o 5<br>julien@holberton:~/holberton/w/hackthevm3$ ./5<br>0x1fa8010<br>bytes at 0x1fa8000:<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x1fa8420<br>bytes at 0x1fa8410:<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x1fa8c30<br>bytes at 0x1fa8c20:<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x1fa9840<br>bytes at 0x1fa9830:<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x1faa850<br>bytes at 0x1faa840:<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x1fabc60<br>bytes at 0x1fabc50:<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x1fad470<br>bytes at 0x1fad460:<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x1faf080<br>bytes at 0x1faf070:<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x1fb1090<br>bytes at 0x1fb1080:<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x1fb34a0<br>bytes at 0x1fb3490:<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>There is one clear pattern: the size of the malloc’ed memory chunk is always found in the preceding 0x10 bytes. For instance, the first <code>malloc</code> call is malloc’ing <code>1024</code> (<code>0x0400</code>) bytes and we can find <code>11 04 00 00 00 00 00 00</code> in the preceding <code>0x10</code> bytes. Those last bytes represent the number <code>0x 00 00 00 00 00 00 04 11</code> = <code>0x400</code> (1024) + <code>0x10</code> (the block size preceding those <code>1024</code> bytes + <code>1</code> (we’ll talk about this “+1” later in this chapter). If we look at each <code>0x10</code> bytes preceding the addresses returned by <code>malloc</code>, they all contain the size of the chunk of memory asked to <code>malloc</code> + <code>0x10</code> + <code>1</code>.</p><br><p>At this point, given what we said and saw earlier, we can probably guess that those 0x10 bytes are a sort of data structure used by <code>malloc</code> (and <code>free</code>) to deal with the heap. And indeed, even though we don’t understand everything yet, we can already use this data structure to go from one malloc’ed chunk of memory to the other (<code>6-main.c</code>) as long as we have the address of the beginning of the heap (<em>and as long as we have never called <code>free</code></em>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> pmem - print mem                                                                            
 </em> @p: memory address to start printing from<br> <em> @bytes: number of bytes to print                                                            
 </em><br> <em> Return: nothing                                                                             
 </em>/<br>void pmem(void <em>p, unsigned int bytes)<br>{<br>    unsigned char </em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char <em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, </em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/</strong><br> <em> main - using the 0x10 bytes to jump to next malloc’ed chunks
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br>    int i;<br>    void </em>heap_start;<br>    size_t size_of_the_block;<br><br>    heap_start = sbrk(0);<br>    write(1, “START\n”, 6);<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1)); 
        </em>((int <em>)p) = i;<br>        printf(“%p: [%i]\n”, p, i);<br>    }<br>    p = heap_start;<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        pmem(p, 0x10);<br>        size_of_the_block = </em>((size_t <em>)((char </em>)p + 8)) - 1;<br>        printf(“%p: [%i] - size = %lu\n”,<br>              (void <em>)((char </em>)p + 0x10),<br>              <em>((int </em>)((char <em>)p + 0x10)),<br>              size_of_the_block);<br>        p = (void </em>)((char <em>)p + size_of_the_block);<br>    }<br>    write(1, “END\n”, 4);<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 6-main.c -o 6<br>julien@holberton:~/holberton/w/hackthevm3$ ./6<br>START<br>0x9e6010: [0]<br>0x9e6420: [1]<br>0x9e6c30: [2]<br>0x9e7840: [3]<br>0x9e8850: [4]<br>0x9e9c60: [5]<br>0x9eb470: [6]<br>0x9ed080: [7]<br>0x9ef090: [8]<br>0x9f14a0: [9]<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x9e6010: [0] - size = 1040<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x9e6420: [1] - size = 2064<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x9e6c30: [2] - size = 3088<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x9e7840: [3] - size = 4112<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x9e8850: [4] - size = 5136<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x9e9c60: [5] - size = 6160<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x9eb470: [6] - size = 7184<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x9ed080: [7] - size = 8208<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x9ef090: [8] - size = 9232<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>0x9f14a0: [9] - size = 10256<br>END<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>One of our open questions from the previous chapter is now answered: <code>malloc</code> is using <code>0x10</code> additional bytes for each malloc’ed memory block to store the size of the block.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/0x10-malloc.png" alt="0x10 bytes preceeding malloc" scale="0"></p><br><p>This data will actually be used by <code>free</code> to save it to a list of available blocks for future calls to <code>malloc</code>.</p><br><p>But our study also raises a new question: what are the first 8 bytes of the 16 (<code>0x10</code> in hexadecimal) bytes used for? It seems to always be zero. Is it just padding?</p><br><h3>RTFSC</h3><br><p>At this stage, we probably want to check the source code of <code>malloc</code> to confirm what we just found (<code>malloc.c</code> from the glibc).</p><br><pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">1055 /*</div><div class="line">1056       malloc_chunk details:</div><div class="line">1057    </div><div class="line">1058        (The following includes lightly edited explanations by Colin Plumb.)</div><div class="line">1059    </div><div class="line">1060        Chunks of memory are maintained using a `boundary tag&apos; method as</div><div class="line">1061        described in e.g., Knuth or Standish.  (See the paper by Paul</div><div class="line">1062        Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</div><div class="line">1063        survey of such techniques.)  Sizes of free chunks are stored both</div><div class="line">1064        in the front of each chunk and at the end.  This makes</div><div class="line">1065        consolidating fragmented chunks into bigger chunks very fast.  The</div><div class="line">1066        size fields also hold bits representing whether chunks are free or</div><div class="line">1067        in use.</div><div class="line">1068    </div><div class="line">1069        An allocated chunk looks like this:</div><div class="line">1070    </div><div class="line">1071    </div><div class="line">1072        chunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1073                |             Size of previous chunk, if unallocated (P clear)  |</div><div class="line">1074                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1075                |             Size of chunk, in bytes                     |A|M|P|</div><div class="line">1076          mem-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1077                |             User data starts here...                          .</div><div class="line">1078                .                                                               .</div><div class="line">1079                .             (malloc_usable_size() bytes)                      .</div><div class="line">1080                .                                                               |</div><div class="line">1081    nextchunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1082                |             (size of chunk, but used for application data)    |</div><div class="line">1083                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1084                |             Size of next chunk, in bytes                |A|0|1|</div><div class="line">1085                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1086    </div><div class="line">1087        Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</div><div class="line">1088        the malloc code, but &quot;mem&quot; is the pointer that is returned to the</div><div class="line">1089        user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</div><div class="line">```&lt;/pre&gt;</div><div class="line">&lt;p&gt;-&gt;; We were correct \o/. Right before the address returned by &lt;code&gt;malloc&lt;/code&gt; to the user, we have two variables:&lt;/p&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">&lt;li&gt;Size of previous chunk, if unallocated: we never free’d any chunks so that is why it was always 0&lt;/li&gt;</div><div class="line">&lt;li&gt;Size of chunk, in bytes&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;p&gt;Let’s free some chunks to confirm that the first 8 bytes are used the way the source code describes it (&lt;code&gt;7-main.c&lt;/code&gt;):&lt;/p&gt;</div><div class="line">&lt;pre&gt;</div><div class="line">```C</div><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - confirm the source code</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">        printf(&quot;%p\n&quot;, p);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8)) - 1;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk, size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 7-main.c -o 7<br>julien@holberton:~/holberton/w/hackthevm3$ ./7<br>0x1536010<br>0x1536420<br>0x1536c30<br>0x1537840<br>0x1538850<br>0x1539c60<br>0x153b470<br>0x153d080<br>0x153f090<br>0x15414a0<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1536000, size = 1040, prev = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1536410, size = 2064, prev = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1536c20, size = 3088, prev = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1537830, size = 4112, prev = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1538840, size = 5135, prev = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1539c50, size = 6160, prev = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x153b460, size = 7184, prev = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x153d070, size = 8208, prev = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x153f080, size = 9231, prev = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x1541490, size = 10256, prev = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>As we can see from the above listing, when the previous chunk has been free’d, the malloc chunk’s first 8 bytes contain the size of the previous unallocated chunk. So the correct representation of a malloc chunk is the following:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/malloc-chunk.png" alt="malloc chunk" scale="0"></p><br><p>Also, it seems that the first bit of the next 8 bytes (containing the size of the current chunk) serves as a flag to check if the previous chunk is used (<code>1</code>) or not (<code>0</code>). So the correct updated version of our program should be written this way (<code>8-main.c</code>):</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - updating with correct checks</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8));</div><div class="line">        prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">        size_of_the_chunk -= prev_used;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev (%s) = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk,</div><div class="line">              (prev_used? &quot;allocated&quot;: &quot;unallocated&quot;), size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 8-main.c -o 8<br>julien@holberton:~/holberton/w/hackthevm3$ ./8<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1031000, size = 1040, prev (allocated) = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1031410, size = 2064, prev (allocated) = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1031c20, size = 3088, prev (allocated) = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1032830, size = 4112, prev (allocated) = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1033840, size = 5136, prev (unallocated) = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1034c50, size = 6160, prev (allocated) = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x1036460, size = 7184, prev (allocated) = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x1038070, size = 8208, prev (allocated) = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x103a080, size = 9232, prev (unallocated) = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x103c490, size = 10256, prev (allocated) = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><h2>Is the heap actually growing upwards?</h2><br><p>The last question left unanswered is: “Is the heap actually growing upwards?”. From the <code>brk</code> man page, it seems so:</p><br><pre><code>DESCRIPTION<br>       brk() and sbrk() change the location of the program break, which defines the end  of  the<br>       process’s  data  segment  (i.e., the program break is the first location after the end of<br>       the uninitialized data segment).  Increasing the program break has the effect of allocat‐<br>       ing memory to the process; decreasing the break deallocates memory.<br></code></pre><br><p>Let’s check! (<code>9-main.c</code>)</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    write(1, &quot;START\n&quot;, 6);</div><div class="line">    malloc(1);</div><div class="line">    getchar();</div><div class="line">    write(1, &quot;LOOP\n&quot;, 5);</div><div class="line">    for (i = 0; i &lt; 0x25000 / 1024; i++)</div><div class="line">    &#123;</div><div class="line">        malloc(1024);</div><div class="line">    &#125;</div><div class="line">    write(1, &quot;END\n&quot;, 4);</div><div class="line">    getchar();</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>Now let’s confirm this assumption with strace:</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ strace ./9<br>execve(“./9”, [“./9”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “START\n”, 6START<br>)                  = 6<br>brk(0)                                  = 0x1fd8000<br>brk(0x1ff9000)                          = 0x1ff9000<br>…<br>write(1, “LOOP\n”, 5LOOP<br>)                   = 5<br>brk(0x201a000)                          = 0x201a000<br>write(1, “END\n”, 4END<br>)                    = 4<br>…<br>julien@holberton:~/holberton/w/hackthevm3$<br></em></code></pre><br><p>clearly, <code>malloc</code> made only two calls to <code>brk</code> to increase the allocated space on the heap. And the second call is using a higher memory address argument (<code>0x201a000</code> &gt;; <code>0x1ff9000</code>). The second syscall was triggered when the space on the heap was too small to host all the malloc calls.</p><br><p>Let’s double check with <code>/proc</code>.</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 9-main.c -o 9<br>julien@holberton:~/holberton/w/hackthevm3$ ./9<br>START<br><br></code></pre><br><pre><code>julien@holberton:/proc/7855$ ps aux | grep \ ./9$<br>julien     7972  0.0  0.0   4332   684 pts/9    S+   19:08   0:00 ./9<br>julien@holberton:/proc/7855$ cd /proc/7972<br>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>Let’s hit Enter and look at the [heap] again:</p><br><pre><code>LOOP<br>END<br><br></code></pre><br><pre><code>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>The beginning of the heap is still the same, but the size has increased upwards from <code>00922000</code> to <code>00943000</code>.</p><br><h2>The Address Space Layout Randomisation (ASLR)</h2><br><p>You may have noticed something “strange” in the <code>/proc/pid/maps</code> listing above, that we want to study:</p><br><p>The program break is the address of the first location beyond the current end of the data region – so the address of the first location beyond the executable in the virtual memory. As a consequence, the heap should start right after the end of the executable in memory. As you can see in all above listing, it is NOT the case. The only thing that is true is that the heap is always the next memory region after the executable, which makes sense since the heap is actually part of the data segment of the executable itself. Also, if we look even closer, the memory gap size between the executable and the heap is never the same:</p><br><p><em>Format of the following lines: [PID of the above <code>maps</code> listings]: address of the beginning of the [heap] – address of the end of the executable = memory gap size</em></p><br><ul><br><li>[3718]: 01195000 – 00602000 = b93000</li><br><li>[3834]: 024d6000 – 00602000 = 1ed4000</li><br><li>[4014]: 00e70000 – 00602000 = 86e000</li><br><li>[4172]: 01314000 – 00602000 = d12000</li><br><li>[7972]: 00901000 – 00602000 = 2ff000</li><br></ul><br><p>It seems that this gap size is random, and indeed, it is. If we look at the ELF binary loader source code (<code>fs/binfmt_elf.c</code>) we can find this:</p><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">if</span> ((current-&gt;;flags &amp;amp; PF_RANDOMIZE) &amp;amp;&amp;amp; (randomize_va_space &gt;; <span class="number">1</span>)) &#123;</div><div class="line">                current-&gt;;mm-&gt;;brk = current-&gt;;mm-&gt;;start_brk =</div><div class="line">                        arch_randomize_brk(current-&gt;;mm);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> compat_brk_randomized</span></div><div class="line">                current-&gt;;brk_randomized = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div></pre></td></tr></table></figure><br><br><p>where <code>current-&gt;;mm-&gt;;brk</code> is the address of the program break. The <code>arch_randomize_brk</code> function can be found in the <code>arch/x86/kernel/process.c</code> file:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_randomize_brk</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> range_end = mm-&gt;;brk + <span class="number">0x02000000</span>;</div><div class="line">        <span class="keyword">return</span> randomize_range(mm-&gt;;brk, range_end, <span class="number">0</span>) ? : mm-&gt;;brk;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>The <code>randomize_range</code> returns a start address such that:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  [...... &lt;range&gt;; .....]</div><div class="line">start                  end</div></pre></td></tr></table></figure><br><br><p>Source code of the <code>randomize_range</code> function (<code>drivers/char/random.c</code>):</p><br><pre><code class="C">/<br> <em> randomize_range() returns a start address such that
 </em><br> <em>    […… <range>; …..]
 </range></em>  start                  end<br> <em>
 </em> a <range>; with size “len” starting at the return value is inside in the<br> <em> area defined by [start, end], but is otherwise randomized.
 </em>/<br>unsigned long<br>randomize_range(unsigned long start, unsigned long end, unsigned long len)<br>{<br>        unsigned long range = end - len - start;<br><br>        if (end &lt;= start + len)<br>                return 0;<br>        return PAGE_ALIGN(get_random_int() % range + start);<br>}<br></range></code></pre><br><p>As a result, the offset between the data section of the executable and the program break initial position when the process runs can have a size of anywhere between <code>0</code> and <code>0x02000000</code>. This randomization is known as Address Space Layout Randomisation (ASLR). ASLR is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the positions of the heap and the stack.</p><br><h2>The updated VM diagram</h2><br><p>With all the above in mind, we can now update our VM diagram:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/virtual_memory_diagram_v2.png" alt="Virtual memory diagram" scale="0"></p><br><h2><code>malloc(0)</code></h2><br><p>Did you ever wonder what was happening when we call <code>malloc</code> with a size of <code>0</code>? Let’s check! (<code>10-main.c</code>)</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    p = malloc(0);</div><div class="line">    printf(&quot;%p\n&quot;, p);</div><div class="line">    pmem((char *)p - 0x10, 0x10);</div><div class="line">    size_of_the_chunk = *((size_t *)((char *)p - 8));</div><div class="line">    prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">    size_of_the_chunk -= prev_used;</div><div class="line">    printf(&quot;chunk size = %li bytes\n&quot;, size_of_the_chunk);</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 10-main.c -o 10<br>julien@holberton:~/holberton/w/hackthevm3$ ./10<br>0xd08010<br>00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00<br>chunk size = 32 bytes<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>-&gt;; <code>malloc(0)</code> is actually using 32 bytes, including the first <code>0x10</code> bytes.</p><br><p>Again, note that this will not always be the case. From the man page (<code>man malloc</code>):</p><br><pre><code>NULL may also be returned by a successful call to malloc() with a size of zero<br></code></pre><br><h2>Outro</h2><br><p>We have learned a couple of things about malloc and the heap. But there is actually more than <code>brk</code> and <code>sbrk</code>. You can try malloc’ing a big chunk of memory, <code>strace</code> it, and look at <code>/proc</code> to learn more before we cover it in a next chapter <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><p>Also, studying how <code>free</code> works in coordination with <code>malloc</code> is something we haven’t covered yet. If you want to look at it, you will find part of the answer to why the minimum chunk size is <code>32</code> (when we ask <code>malloc</code> for <code>0</code> bytes) vs <code>16</code> (<code>0x10</code> in hexadecimal) or <code>0</code>.</p><br><p>As usual, to be continued! Let me know if you have something you would like me to cover in the next chapter.</p><br><h3>Questions? Feedback?</h3><br><p>If you have questions or feedback don’t hesitate to ping us on Twitter at <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a>.<br><br><em>Haters, please send your comments to <code>/dev/null</code>.</em></p><br><p>Happy Hacking!</p><br><h3>Thank you for reading!</h3><br><p>As always, no-one is perfect (except <a href="http://codesqueeze.com/the-ultimate-top-25-chuck-norris-the-programmer-jokes/" target="_blank" rel="external">Chuck</a> of course), so don’t hesitate to <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc,%20the%20heap%20and%20the%20program%20break/" target="_blank" rel="external">contribute</a> or send me your comments if you find anything I missed.</p><br><h3>Files</h3><br><p><a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/tree/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break" target="_blank" rel="external">This repo</a> contains the source code (<code>naive_malloc.c</code>, <code>version.c</code> &amp; “X-main.c` files) for programs created in this tutorial.</p><br><h3>Read more about the virtual memory</h3><br><p>Follow <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a> on Twitter to get the next chapters!</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br><li>Chapter 3: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank" rel="external">Hack the Virtual Memory: malloc, the heap &amp; the program break</a></li><br></ul><br><p><em>Many thanks to <a href="https://twitter.com/wintermanc3r" target="_blank" rel="external">Tim</a>, <a href="https://twitter.com/1million40" target="_blank" rel="external">Anne</a> and <a href="https://www.linkedin.com/in/iancugniere/" target="_blank" rel="external">Ian</a> for proof-reading!</em> <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><!-- Simple Share Buttons Adder (6.3.4) simplesharebuttons.com --><div class="ssba ssba-wrap"><div style="text-align:left">Sharing is caring<a data-site="reddit" class="ssba_reddit_share" href="http://reddit.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack the Virtual Memory: malloc, the heap &amp; the program break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png" title="Reddit" class="ssba ssba-img" alt="Share on Reddit"></a><a data-site="" class="ssba_twitter_share" href="http://twitter.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;text=Hack+the+Virtual+Memory%3A+malloc%2C+the+heap+%26+the+program+break+" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png" title="Twitter" class="ssba ssba-img" alt="Tweet about this on Twitter"></a><a data-site="" class="ssba_facebook_share" href="http://www.facebook.com/sharer.php?u=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png" title="Facebook" class="ssba ssba-img" alt="Share on Facebook"></a><a data-site="" class="ssba_google_share" href="https://plus.google.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png" title="Google+" class="ssba ssba-img" alt="Share on Google+"></a><a data-site="linkedin" class="ssba_linkedin_share ssba_share_link" href="http://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png" title="LinkedIn" class="ssba ssba-img" alt="Share on LinkedIn"></a><a data-site="digg" class="ssba_diggit_share ssba_share_link" href="http://www.digg.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/diggit.png" title="Digg" class="ssba ssba-img" alt="Digg this"></a><a data-site="stumbleupon" class="ssba_stumbleupon_share ssba_share_link" href="http://www.stumbleupon.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack%20the%20Virtual%20Memory:%20malloc,%20the%20heap%20&amp;%20the%20program%20break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/stumbleupon.png" title="StumbleUpon" class="ssba ssba-img" alt="Share on StumbleUpon"></a></div></div><br>        <div class="clearfix"></div>

<pre><code>&lt;/div&gt;
</code></pre></div>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/13/深入理解Linux中内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/13/深入理解Linux中内存管理/" itemprop="url">深入理解Linux中内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T15:20:08+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux-c/" itemprop="url" rel="index">
                    <span itemprop="name">linux-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><p>平常只是知道一些进程虚拟地址空间的一些概念，并没有深入去理解Linux是如何管理内存了，刚好有时间就研究了下这块的原由。</p>
<p><span style="color: red"><strong>主题:</strong></span>Linux内存管理中的分段和分页技术</p>
<p>回顾一下历史，<span style="color: #0000ff;"><strong>在早期的计算机中，程序是直接运行在物理内存上的。</strong></span>换句话说，就是程序在运行的过程中访问的都是物理地址。</p>
<p>如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。</p>
<p>然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为<span style="color: red">内存管理</span>。</p>
<p>举一个早期的计算机系统中，内存分配管理的例子，以便于理解。</p>
<p>假如我们有三个程序，<span style="color: #993366;"><strong>程序A，B，C，程序A运行的过程中需要<span style="color: #ff6600;">10M</span>内存，程序B运行的过程中需要<span style="color: #ff6600;">100M</span>内存，而程序C运行的过程中需要<span style="color: #ff6600;">20M</span>内存。</strong></span></p>
<p>如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A，接下来的10M-110M分配给B。</p>
<p>这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。</p>
<p>大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。</p>
<p>下面来看看这种内存管理方式存在的几个比较明显的问题。</p>
<h3 id="进程地址空间不能隔离"><a href="#进程地址空间不能隔离" class="headerlink" title="进程地址空间不能隔离"></a>进程地址空间不能隔离</h3><p>由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。</p>
<p>举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以访问系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举地破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。</p>
<h3 id="内存使用的效率低"><a href="#内存使用的效率低" class="headerlink" title="内存使用的效率低　"></a>内存使用的效率低　</h3><p>如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。</p>
<p>这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道<span style="color: #ff6600;"><strong>IO操作比较耗时</strong></span>，所以这个过程效率将会十分低下。</p>
<h3 id="程序运行的地址不能确定"><a href="#程序运行的地址不能确定" class="headerlink" title="程序运行的地址不能确定"></a>程序运行的地址不能确定</h3><p>程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址，如果有不明白童鞋可以去查查编译原理方面的资料。</p>
<p><span style="color: #0000ff;"><strong>　　</strong><strong>内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？</strong></span></p>
<p>引用计算机界一句无从考证的名言：<span style="color: #993366;"><strong>计算机系统里的任何问题都可以靠引入一个中间层来解决</strong></span></p>
<p>现在的内存管理方法就是在程序和物理内存之间引入了<span style="color:red">虚拟内存</span>这个概念。</p>
<p><ol></ol></p>
<p><li><span style="color: #008080;"><strong>虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。</strong></span></li></p>
<p><li>每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。</li></p>
<p><li>顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。</li><br><br>既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。</p>
<h2 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h2><p>这种方法是人们最开始使用的一种方法，基本思路是<span style="color: #ff0000;"><strong>将程序所需要的内存地址空间大小的虚拟空间映射到某个物理地址空间。</strong></span></p>
<p><img src="memory_segmentation.jpg"></p>
<p><span style="color: #993366;"><strong>每个程序都有其独立的虚拟的独立的进程地址空间</strong></span>可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。</p>
<p>这种<span style="color: #ff6600;"><strong>分段的机制解决了开始提到的3个问题中的进程地址空间隔离和程序地址重定位的问题。</strong></span></p>
<p>程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。</p>
<p>无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。　　　</p>
<p>因为<span style="color: #008080;"><strong>这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。</strong></span></p>
<p>那么，怎么才算高效率的内存使用呢。事实上，<span style="color: #993366;"><strong>根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。</strong></span></p>
<p>所以我们需要更加小粒度的内存分割和映射方法，此时是否会想到Linux中的Buddy算法和slab内存分配机制呢。另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。</p>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p><span style="color: #0000ff;"><strong>分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。</strong></span></p>
<p>试想一下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999字节是不是浪费了。所以需要更加细粒度的磁盘分割方式，我们可以将Block设置得小一点，这当然是根据所存放文件的大小来综合考虑的，好像有点跑题了，我只是想说，内存中的分页机制跟ext文件系统中的磁盘分割机制非常相似。</p>
<p><span style="color: #993366;"><strong>Linux中一般页的大小是4KB</strong></span>我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，我们还是以一个例子来说明,如下图：</p>
<p><img src="memory_page.jpg"></p>
<p>可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行)，甚至他们共用了一部分物理地址空间，这就是<span stlye="color:red">共享内存</span>。</p>
<p>进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个<span style="color: #0000ff;"><strong>缺页异常</strong></span>，然后异常管理程序会将其读到内存中。</p>
<p>这就是<span style="color: #ff0000;"><strong>分页机制的原理</strong></span>，当然Linux中的分页机制的实现还是比较复杂的，通过了页全局目录，页上级目录，页中级目录，页表等几级的分页机制来实现的，但是基本的工作原理是不会变的。</p>
<p>分页机制的实现需要硬件的实现，这个硬件名字叫做<span style="color: #993366;"><strong>MMU</strong></span>(Memory Management Unit)，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。</p>
<p><a href="http://www.cnblogs.com/lcw/p/3505503.html" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/ky_heart/article/details/51865526" target="_blank" rel="external">重定位</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/12/如何构建一个go项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/如何构建一个go项目/" itemprop="url">如何构建一个go项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T15:44:43+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这里我会介绍开发一个简单的Go包以及对<code>go tool</code>的使用。最标准的方法是先拉取，编译再安装Go包然后再到命令行运行。</p>
<p><code>go tool</code>需要你按特定的方式组织你的代码.接下来请仔细阅读.</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li>Go程序通常把所有的Go代码放在单一的工作空间</li>
<li>工作空间包含各种版本控制的库(如:git管理的库)</li>
<li>每一个库包含一个或多个包</li>
<li>每一个包由单个目录下面的一个或多个go文件组成</li>
<li>包的路径决定了它导入的路径</li>
</ul>
<p>注意要和其它Go程序区分开来，每个Go的项目都有自己的工作空间并且工作空间是和版本控制库是紧密联系在一起的。</p>
<h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>一个工作空间是包含有三子目录的目录:</p>
<ul>
<li>src包信Go的源文析</li>
<li>pkg包含仓库生成对应的包</li>
<li>bin包含我们生成Go的可执行程序</li>
</ul>
<p><code>go tool</code>编译所有的包并安装二进制文件到<code>pkg</code>和<code>bin</code>目录<br><code>src</code>子目录通常包含多个版本控制的库,这里面包含一个或多个包</p>
<p>一个工作空间看来是是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                          # command executable</div><div class="line">    outyet                         # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a           # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	hello/</div><div class="line">	    hello.go               # command source</div><div class="line">	outyet/</div><div class="line">	    main.go                # command source</div><div class="line">	    main_test.go           # test source</div><div class="line">	stringutil/</div><div class="line">	    reverse.go             # package source</div><div class="line">	    reverse_test.go        # test source</div><div class="line">    golang.org/x/image/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	bmp/</div><div class="line">	    reader.go              # package source</div><div class="line">	    writer.go              # package source</div><div class="line">    ... (many more repositories and packages omitted) ...</div></pre></td></tr></table></figure></p>
<p>上面的结构包含两个库(example和image).example库包含两个可执行程序和一个库。image仓库包含bmp包和一些其它的。</p>
<p>一个典型的工作空间是包含多个仓库源，每个仓库包含多个包或可执行程序。大部分Go程序保持所有Go源码和依赖放在同一个工作空间。</p>
<p>可执行程序和程序所需要的库是从不同的包里生成的。我们稍后会讨论他们的区别。</p>
<h3 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h3><p>GOPATH环境变量指定了工作空间的位置.linux默认是<code>~/go</code>,windows下面是<code>C:\Users\YourName\go</code>。</p>
<p>如果你喜欢在不同的位置工作，你需要设置下GOPATH指向你想要的那个目录(另一个常见的设置是<code>GOPATH=$HOME</code>)，注意GOPATH不要和Go安装的目录相同。</p>
<p><code>go env GOPATH</code>输出当前生效的GOPATH,如果没有设置会输出默认的值。</p>
<p>为了方便把工作目录的<code>bin</code>子目录设置加入到系统PATH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$export PATH=$PATH:$(go env GOPATH)/bin</div></pre></td></tr></table></figure>
<h3 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h3><p>一个导入路径是标识唯一个包的一串字符。一个包导入路径对应它在工作空间里面的目录或是一个远程仓库。</p>
<p>标准库的包导入路径非常短,比如:”fmt”、”net/http”.对于自己的包来说，你必须选择将来加入一些标准库或其它外部库不太可能会产生冲突的基础路径。</p>
<p>如果你把代码放在某个开源仓库，你应该仓库的根目录做为你的基础路径。比如:你的github帐号是<code>github.com/user</code>，这应该是你的基础路径。</p>
<p>注意在你可以编译之前最好不要发布你的代码到远程仓库。这是一个好的习惯来组织你的代码如果你在将来某一天发布。事实上你可以选择其它任意的目录名称，只要它对标准库和Go生态生成的路径唯一就好。</p>
<p>接下来我们会用<code>github.com/user</code>做为我们的基础路径。在你的工作空间创建一个目录来放你的源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mkdir -p $GOPATH/src/github.com/user</div></pre></td></tr></table></figure></p>
<h3 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h3><p>编译和运行一个程序首先需要选择一个包路径(我们用github.com/user/hello)然后在你的工作空间创建相应的包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/hello</div></pre></td></tr></table></figure>
<p>接下来我们在目录下面创建一个叫<code>hello.go</code>的文件,文件内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Hello, world.\n"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以用<code>go tool</code>编译然后安装这个程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go install github.com/user/hello</div></pre></td></tr></table></figure>
<p>注意你可以在你电脑的任何地方运行这个命令。<code>go tool</code>会在你的<code>GOPATH</code>查找<code>github.com/user/hello</code>对应的包。</p>
<p>如果你在包的目录下面运行<code>go install</code>话，你可以忽略包的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/github.com/user/hello</div><div class="line">$ go install</div></pre></td></tr></table></figure>
<p>这个命令编译hello生成一个可执行文件。然后安装这个二进制文件到工作空间的bin目录下，生成的名字是hello(windows下是hello.exe)。在我们的例子会在$GOPATH/bin/hello,也就是$HOME/go/bin/hello.</p>
<p><code>go tool</code>只会在有错误的情况下输出，如果没有任何输出说明是执行成功。</p>
<p>现在你可以在命令行输入绝对路径来运行你的程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ $GOPATH/bin/hello</div></pre></td></tr></table></figure></p>
<p>或者你已经把$GOPATH/bin加入到系统PATH了，你只需要输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, world.</div></pre></td></tr></table></figure></p>
<p>如果你正在用一个版本控制系统，那么现在是初始化一个仓库的最佳时机，新增这些文件，然后提交你第一次变更。再强调一次，这一步是可选的:你不需要用源代码控制系统来写Go代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/src/github.com/user/hello</div><div class="line">$ git init</div><div class="line">Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/</div><div class="line">$ git add hello.go</div><div class="line">$ git commit -m &quot;initial commit&quot;</div><div class="line">[master (root-commit) 0b4507d] initial commit</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line">  create mode 100644 hello.go</div></pre></td></tr></table></figure>
<h3 id="第一个库"><a href="#第一个库" class="headerlink" title="第一个库"></a>第一个库</h3><p>让我们写一个库并在hello程序里面使用这个库</p>
<p>再说下，第一步创建包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/stringutil</div></pre></td></tr></table></figure>
<p>接下来在目录下创建一个reverse.go的文件，内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></div><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	r := []<span class="keyword">rune</span>(s)</div><div class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</div><div class="line">		r[i], r[j] = r[j], r[i]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们用<code>go build</code>来编译这个包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build github.com/user/stringutil</div></pre></td></tr></table></figure></p>
<p>或进入目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build</div></pre></td></tr></table></figure></p>
<p>这个不会产生文件。为了这样做，你必须用go install把这个包放到你工作空间的pkg目录。</p>
<p>在你确实stringutil包编译成功后，修改你原先的hello.go代码:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/user/stringutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行我们的程序，结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, Go!</div></pre></td></tr></table></figure></p>
<p>经过上面的步骤后，我们的工作空间如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                 # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/          # this will reflect your OS and architecture</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a  # package object</div><div class="line">src/</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go      # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go    # package source</div></pre></td></tr></table></figure></p>
<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>在Go的源码里面第一条语句必需是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package name</div></pre></td></tr></table></figure>
<p>name是包默认的名字用来导入。(一个包里所有的文件必须用同一个name)</p>
<p>Go的转换规则是把导入路径最后一个元素做为包名的:如果”crypto/rot13”导入的话name应该命名为rot13.</p>
<p>可执行的命令必须用package main.</p>
<p>在链接到一个二进制文件的时候不要求所有包里的名称都唯一，但是导入的路径必须唯一。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go有一个轻微测试框，由<code>go test</code>命令和testing包组成。</p>
<p>新建一个以_test.go结尾的文件名来做为测试，文件里面包含类TestXXX(t *testing.T)的函数。测试框架会运行每一个这样的函数;如果函数用T.Error或t.Fail调用失败，这个测试是被认为失败了。</p>
<p>到stringutil包里新增一个测试文件($GOPATH/src/github.com/user/stringutil/reverse_test.go),内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	cases := []<span class="keyword">struct</span> &#123;</div><div class="line">		in, want <span class="keyword">string</span></div><div class="line">	&#125;&#123;</div><div class="line">		&#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</div><div class="line">		got := Reverse(c.in)</div><div class="line">		<span class="keyword">if</span> got != c.want &#123;</div><div class="line">			t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行这个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/user/stringutil</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<p>同样的，可以在包里面运行这个测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<h2 id="远程包"><a href="#远程包" class="headerlink" title="远程包"></a>远程包</h2><p>包的导入描述了是怎样通过版本控制系统获取包的源码的(如:git或Mercurial).<code>go tool</code>利用这个特性从远程仓库获取这个包。例如,在这个文章里面example是放在Github上面的(github.com/golang/example)。如果你在包的导入路径添加了这个地址，<code>go get</code>将会自动拉取、编译和安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/golang/example/hello</div><div class="line">$ $GOPATH/bin/hello</div><div class="line">Hello, Go examples!</div></pre></td></tr></table></figure>
<p>如果指定的包不存在当前的工作空间，<code>go get</code>将会把包放到由<code>GOPATH</code>指定的工作空间里面。(如果这个包已经在工作空间中存在,<code>go get</code>跳过从远程的拉取和安装)</p>
<p>执行上面<code>go get</code>命令后，现在的工作空间目录结构是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                           # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a            # package object</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a            # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">	.git/                       # Git repository metadata</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div></pre></td></tr></table></figure></p>
<p>托管在Gihub上的<code>hello</code>程序和它依赖<code>stringutil</code>包在同一个仓库。在<code>hello.go</code>文件里用相同的导入路径转换，所以<code>go get</code>命令找到和安装依赖包到对应的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;github.com/golang/example/stringutil&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>英语很渣的一个翻译<br><a href="https://golang.org/doc/code.html" target="_blank" rel="external">参考</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/go-solutions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/go-solutions/" itemprop="url">golang开发中遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T09:56:22+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>在用golang编写服务器程序的时候，遇到下面一些问题，所以在这里做一些记录，尤其是<code>slice</code>隐藏的bug较隐性，若对<code>slice</code>工作原理不了解是较难发现的。</p>
<ul>
<li>slice元素被莫名替换</li>
<li>index out of range问题</li>
<li>空指针引用</li>
<li>map的并发读写导致进程挂掉</li>
<li>String方法导致的递归死循环</li>
<li>通道多次close(close of closed channel)</li>
<li>死锁</li>
<li>下次gc内存回收条件</li>
<li>定时任务的问题</li>
</ul>
<h3 id="slice元素被替换"><a href="#slice元素被替换" class="headerlink" title="slice元素被替换"></a>slice元素被替换</h3><blockquote>
<p>slice在开发中运用较频繁的基础数据类型,和数组相似，与数组最大的区别在于他是系统自动扩容的。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</div><div class="line">	array unsafe.Pointer</div><div class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></div><div class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>go runtime</code>里面对slice实现数据结构，指向一块内存的一个指针、一个当前slice里面的长度以及当前slice里面的最大容量。可以预想下<br>若另外一个指针同之前slice的指针有内存重叠的话，修改重叠部分是会相互影响的，下面我们用实例来确定下这个问题。</p>
<p><strong>test1.go</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</div><div class="line"></div><div class="line">sb := sa</div><div class="line">sb = <span class="built_in">append</span>(sb, <span class="number">5</span>) <span class="comment">// sb = append(sa, 5) 同样有问题</span></div><div class="line"></div><div class="line"><span class="comment">// 从小到大排序</span></div><div class="line">algorithm.Sort(sb, <span class="number">0</span>, <span class="built_in">len</span>(sb)<span class="number">-1</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 5 cap: 8 of slice sa: [1 2 3 4 5]</span></div><div class="line"><span class="comment">// len: 6 cap: 8 of slice sb: [1 2 3 4 5 6]</span></div></pre></td></tr></table></figure></p>
<p><strong>test2.go</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">sb := sa</div><div class="line">sb = <span class="built_in">append</span>(sb, <span class="number">9</span>)</div><div class="line"></div><div class="line"><span class="comment">// 从小到大排序</span></div><div class="line">algorithm.Sort(sb, <span class="number">0</span>, <span class="built_in">len</span>(sb)<span class="number">-1</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 8 cap: 8 of slice sa: [1 2 3 4 5 7 8 10]</span></div><div class="line"><span class="comment">// len: 9 cap: 16 of slice sb: [1 2 3 4 5 7 8 9 10]</span></div></pre></td></tr></table></figure></p>
<p>上面两个程序的输出可能看出，<code>test1.go</code>中对sb排完序后sa和sb第5个元素是被替换掉了的。<br>实际上sa和sb是两个指向同块内存的不同指针，只是它们的len值不一样,需要注意的是sb调用<br>append后cap的值还是和sa的一样。和<code>test2.go</code>形成鲜明的对比，只要slice的长度超过了默<br>认的容量后就会自动扩容。</p>
<p><strong>sb:=sa之后的代码写在函数里面同样有这样的问题，因为go里面传参都是按值传递的</strong></p>
<h3 id="index-out-of-range"><a href="#index-out-of-range" class="headerlink" title="index out of range"></a>index out of range</h3><ul>
<li>索引slice元素越界</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</div><div class="line"><span class="comment">// sa[5] = 20 // 这里会panic</span></div><div class="line"></div><div class="line">sb := sa[<span class="number">5</span>:]</div><div class="line"><span class="comment">// sb[0] = 5  // 这里会panic</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 5 cap: 8 of slice sa: [1 2 3 4 6]</span></div><div class="line"><span class="comment">// len: 0 cap: 3 of slice sb: []</span></div></pre></td></tr></table></figure>
<p>对于这种下标越界的问题是当索引的下标号超出了<code>len(sa)</code>的时候就抛出越界的错误</p>
<ul>
<li>slice表达式越界问题</li>
</ul>
<blockquote>
<p>根据官方文档的说明slice表达式有两个，一种简单的表达式和参数更全的表达式<br>分别对应<code>a[low : high]</code>和<code>a[low : high : max]</code></p>
</blockquote>
<p><a href="https://golang.org/ref/spec#Slice_expressions" target="_blank" rel="external">spec说明</a><br>对于这类越界是下标不在<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>这范围时会出现问题</p>
<h3 id="空指针引用"><a href="#空指针引用" class="headerlink" title="空指针引用"></a>空指针引用</h3><p>相信不论是C系还是JAVA开发者都会遇到空指针的问题，C里面对空地址的访问是致命的，<br>并且不像JAVA能把这种异常捕获，go也不例外，为了保证服务正常运行同样可以通过<br>recover把所有runtime时的错捕获到，但并发读写的错误是不行的。所以我们项目里基本<br>在所有的协程里面有recover输出的。</p>
<p>项目中我们把一个自定义的interface的变量赋值一个<code>nil</code>，但去执行原先持有的类型的<br>函数时就panic掉了，所以对默认值为空值引用的都会出这种错误，比如:空指针和接口</p>
<p><strong>有趣的例子:</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</div><div class="line">	Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stu)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"s is %v"</span>, s) <span class="comment">// 这里能正常调用,但不要再去调Stu里面的成员</span></div><div class="line">	<span class="keyword">return</span> <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> s *Stu</div><div class="line">	s.GetName()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子一开始出乎意料，但仔细一想其实是符合go的设计理念的，方法是属于类型的，<br>类型的变量当然是可以正常调用的，但变量为空再去调用里面的成员就是对空指针的访问了。</p>
<h3 id="map的并发读写导致进程挂掉"><a href="#map的并发读写导致进程挂掉" class="headerlink" title="map的并发读写导致进程挂掉"></a>map的并发读写导致进程挂掉</h3><p>对一个多线程程序来说对数据竞争的保护是必不可少的，但在处理日志输出的时候，如果<br>一个对象有map或数组之类的并对有并发读写这很容易导致进程panic掉。所以打印日志的<br>时候一定要注意不要输出一个对象。</p>
<h3 id="String方法导致的递归死循环"><a href="#String方法导致的递归死循环" class="headerlink" title="String方法导致的递归死循环"></a>String方法导致的递归死循环</h3><p>在日志输出的时候打印了一个对象并且对象实现了String()方法，如果String方法里面<br>又调了自身，这种使用方法是很危险的，在我们开发期间是有同事犯了这个一个错误的。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>既然是并发程序，难免会有数据竞争的问题，所以我们用了互斥锁来解决这个问题，<br>如果获取锁和释放锁没有成对使用或者是锁重入(递归获取锁)就会导致死锁的风险，<br>因为我们项目是针对房间的，虽然不影响所有的人，一出现死锁只会影响这个房间<br>的人，不过我们这种锁是睡眠锁,并不消耗CPU。</p>
<blockquote>
<p>我们的产品是一款地方麻将,用golang开发的</p>
</blockquote>
<p><strong>死锁1:</strong></p>
<p>我们的产品上线第二天就出现导致全服(多个逻辑服)服务不可用。后来经过排查是有死锁影响了全局。</p>
<p>一开始并不知道问题在哪，有以下两个解决方案:</p>
<ul>
<li>新增高版本的逻辑服(不影响新的玩家)</li>
<li>停服维护</li>
</ul>
<p>一开始我们选择的是一方案，但好像出了点问题，又换了二方案，二方案虽然可以但是已经开的房间的钻石没返还。<br>弄了好久才弄程序把需要返还钻石返还。</p>
<p>不过好在上线前有人说要开放pprof接口,经过日志分析是有很多goroutine阻塞在获取锁的地方。<br>上线前我们做了一个需求，10分钟没开局的房间需要解散掉。也没考虑太多，觉得这个需求比较<br>简单，所以逻辑服这边起了个定时任务1分钟扫下单个逻辑服的房间列表。</p>
<p>定时任务我们是用的读锁来执行的，从列表里面删除一个房间的是写锁的。读锁是可以多次获取的。<br>假如1分钟还没遍历完所有的房间，另外一个定时任务立即执行，又重新获取房间列表的读锁。1分<br>钟遍历的时候是有获取房间的锁的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">R*是获取房间里面的锁</div><div class="line">RA ——&gt; roomA</div><div class="line">RB ——&gt; roomB</div><div class="line">    再尝试获取房间列表写锁的:</div><div class="line">    RA ——&gt; list</div><div class="line">    RB ——&gt; list</div><div class="line"></div><div class="line">T*是定时任务得到房间列表的读锁:</div><div class="line">T1  ——&gt; list</div><div class="line">T2  ——&gt; list</div><div class="line">T3  ——&gt; list</div><div class="line">	再获取房间里面的锁</div><div class="line">	TA ——&gt; roomA</div><div class="line">	TB ——&gt; roomB</div></pre></td></tr></table></figure>
<p><strong>定时任务是有获取房间的锁的,如果刚好TA的锁等着RA的锁就会产生死锁</strong></p>
<p>后续我们的解决方案是为每一个房间启一个定时。能不用锁解决的问题千万不要不用，获取锁是会导致上下文的切换，<br>从一执行线程切换到另一个执行线程。</p>
<p>golang的<code>channel</code>就是通过锁来实现不同的协程之间可以通信。虽然用到了锁，但是这个锁对开发人员是无感的，所<br>以对使用者来说就安全了。</p>
<p><strong>死锁2:</strong></p>
<p>这个问题是异常情况下面导致的单个房间的死锁，当时写代码的时候能不用defer就不用，所以在一个加锁的函数的<br>地方没有用defer解锁，在函数执行当中有panic，所以没执行后面解锁的函数。如果用了defer解锁就不会有这个问<br>题了。所以在有锁的情况尽量用defer就用defer。</p>
<h3 id="下次gc内存回收条件"><a href="#下次gc内存回收条件" class="headerlink" title="下次gc内存回收条件"></a>下次gc内存回收条件</h3><p>线上因为通过<code>pprof</code>看到<code>heap</code>一直在增长，一天增长了一千多。用top观察实际res也增了几十兆的物理内存。<br>因此网上找了很多关于linux内存管理以及golang的pprof里面的heap各字段详细描述。</p>
<p>(MemStats)[<a href="https://golang.org/pkg/runtime/#MemStats" target="_blank" rel="external">https://golang.org/pkg/runtime/#MemStats</a>]</p>
<p>通过线上实际表现，内存是一直往上增的情况，所以看了下哪里可能有内存没被回收掉，以及GC的回收机制。</p>
<p>一开始自己有以下疑问:</p>
<ul>
<li>有垃圾回收的语言不是会自动回收的吗?</li>
<li>有回收的话哪些对象没被回收掉？</li>
</ul>
<p>一开始对代码大概的看了一下，除了其它一些频繁make的切片(也就十几个byte)的长度，这些部分是由他底层内存分配<br>管理器来控制的，我是束手无从的，不过也对一些频繁用到的对像用了内置的pool对象池。所以从其它地方想下还有哪<br>些地方没被回收掉，后来想到定时器！定时器确实也是有泄漏的(有些没有Stop掉)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GODEBUG=GOGC=50,GCTRACE=1</div><div class="line">./main</div></pre></td></tr></table></figure>
<p>默认GOGC是100的，所以gc会在下次分配的内存和上次分配的内存的比是成倍的才会把内存回收掉，设置成50后<br>通过压测试后通过日志输出会发现回收的次数相对来说要频繁，所以内存没有出现大的增长，停下来的时候恢复<br>平稳的值，但设置成50的时候会偶发的卡顿。线上估计也只能设置成80左右吧！暂时这个值没放到线上去跑。</p>
<p><a href="https://golang.org/pkg/runtime/#GC" target="_blank" rel="external">参数说明</a></p>
<h3 id="定时任务的问题"><a href="#定时任务的问题" class="headerlink" title="定时任务的问题"></a>定时任务的问题</h3><p><strong>参考:</strong><br><a href="https://guidao.github.io/go_timer.html" target="_blank" rel="external">实现说明</a></p>
<p>go里面使用定时器有以下几种方式:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</div><div class="line">	t := &amp;Timer&#123;</div><div class="line">		C: c,</div><div class="line">		r: runtimeTimer&#123;</div><div class="line">			when: when(d),</div><div class="line">			f:    sendTime,</div><div class="line">			arg:  c,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	startTimer(&amp;t.r)</div><div class="line">	<span class="keyword">return</span> t</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> runtimeTimer <span class="keyword">struct</span> &#123;</div><div class="line">	i      <span class="keyword">int</span></div><div class="line">	when   <span class="keyword">int64</span></div><div class="line">	period <span class="keyword">int64</span></div><div class="line">	f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span> // <span class="title">NOTE</span>: <span class="title">must</span> <span class="title">not</span> <span class="title">be</span> <span class="title">closure</span></span></div><div class="line">	<span class="title">arg</span>    <span class="title">interface</span>&#123;&#125;</div><div class="line">	seq    <span class="keyword">uintptr</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span></span> &#123;</div><div class="line">	t := &amp;Timer&#123;</div><div class="line">		r: runtimeTimer&#123;</div><div class="line">			when: when(d),</div><div class="line">			f:    goFunc,</div><div class="line">			arg:  f,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	startTimer(&amp;t.r)</div><div class="line">	<span class="keyword">return</span> t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">goFunc</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="keyword">uintptr</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> arg.(<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="title">time</span>.<span class="title">NewTicker</span><span class="params">(time.Second)</span></div><div class="line"><span class="title">time</span>.<span class="title">After</span><span class="params">(time.Second)</span></div><div class="line"><span class="title">time</span>.<span class="title">AfterFun</span><span class="params">(time.Second, <span class="keyword">func</span>()</span>&#123;&#125;)</div></pre></td></tr></table></figure>
<p>通过源码以及使用接口总结，主要有两种定时器。1) 执行一次的  2) 定期执行的。通过数据结构<br>我们看了下不同接口实际的区别只在<code>period</code>字段。以及这个<code>f</code>参数用的默认的<code>sendTime</code>是非<br>阻塞的调用，<code>AfterFun</code>和前面两个接口不同的时没通过管道来实现定时器到点了(可以执行我的<br>业务了)，而它是直接用的goFunc包装在自己的协程里面执行</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">1000000</span>; i++ &#123;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-time.Tick(time.Second):</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果像上面的代码用<code>time.Tick()</code>创建的定时器(也就是管道)没<code>Stop()</code>掉，定时器任务<br>列表会一直规程，导致内存一直无法得到释放。尤其是循环条件加大到百万级别的时候就<br>更明显了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/08/enjoy-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="易斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知而智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/enjoy-hexo/" itemprop="url">enjoy hexo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T10:50:37+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="搭建博客的过程"><a href="#搭建博客的过程" class="headerlink" title="搭建博客的过程"></a>搭建博客的过程</h4><p>对于没有购买自己域名的个人来说<code>hexo+github</code>是个不错的选择。</p>
<p>安装步骤:</p>
<ul>
<li>安装<code>git</code></li>
<li>安装<code>nodejs</code></li>
<li>在git上创建自己的仓库</li>
<li>用<code>hexo</code>创建博客并生成静态页面，关联自己的仓库，再<code>hexo deploy</code>基本就好了</li>
</ul>
<h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><ul>
<li><a href="https://git-for-windows.github.io/" target="_blank" rel="external">git下载</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs下载</a> 选择LTS(Long Term Support)版本就好</li>
<li><code>npm i -g hexo</code>安装hexo</li>
</ul>
<p>npm是nodejs来管理软件库的一个工具，i是安装-g 是全局安装,安装后尽情享受hexo –help的功能吧。<br><a href="https://hexo.io/themes/" target="_blank" rel="external">更换主题地址</a><code>git clone url themes/</code></p>
<h3 id="enjoy"><a href="#enjoy" class="headerlink" title="enjoy"></a>enjoy</h3><p>所有准备工作做好后直接用<code>hexo init name</code>初始化一个博客目录</p>
<ul>
<li><code>hexo new first-post</code>来创建自己的需要写的文章</li>
<li><code>hexo server</code>就可以通过访问<code>localhost:4000</code>博客地址了</li>
</ul>
<p>可以在配置文件里面支持分类、评论和主题等各种参数配置</p>
<p><strong>在配置git上面的仓库的时候用git协议每次更新就不需要输入密码~</strong></p>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>把自己本地的ssh的公钥放到github个人帐号的key下面,没有则用<code>ssh-keygen</code>一直回车生成,<code>cat ~/.ssh/id_rsa.pub</code><br>在配置里面自己github仓库地址</p>
<p><strong>仓库名格式:<code>名称+github.io</code> example:hello.github.io，否则无效</strong></p>
<p>每次有新文章需要发布的时候执行下面命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean   </div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">易斌</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">易斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
