<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>不可同日而语</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="不可同日而语">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="不可同日而语">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不可同日而语">
  
    <link rel="alternate" href="/atom.xml" title="不可同日而语" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">不可同日而语</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-malloc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/20/malloc/" class="article-date">
  <time datetime="2017-09-20T05:35:00.000Z" itemprop="datePublished">2017-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/20/malloc/">malloc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="内存管理转载"><a href="#内存管理转载" class="headerlink" title="内存管理转载"></a>内存管理转载</h3><p>一直对linux内存管理比较的疑惑，所以在网上搜集资料，收藏下这篇。<br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">原文</a></p>
<div class="entry-content"><br><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/htvm3.png" alt="Hack the VM!" scale="0"></p><br><p>This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.</p><br><p>If you missed the previous chapters, you should probably start there:</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br></ul><br><h2>The heap</h2><br><p>In this chapter we will look at the heap and <code>malloc</code> in order to answer some of the questions we ended with at the end of the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>:</p><br><ul><br><li>Why doesn’t our allocated memory start at the very beginning of the heap (0x2050010 vs 02050000)? What are those first 16 bytes used for?</li><br><li>Is the heap actually growing upwards?</li><br></ul><br><h2>Prerequisites</h2><br><p>In order to fully understand this article, you will need to know:</p><br><ul><br><li>The basics of the C programming language (especially pointers)</li><br><li>The very basics of the Linux filesystem and the shell</li><br><li>We will also use the <code>/proc/[pid]/maps</code> file (see <code>man proc</code> or read our first article <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory, chapter 0: C strings &amp; /proc</a>)</li><br></ul><br><h2>Environment</h2><br><p>All scripts and programs have been tested on the following system:</p><br><ul><br><li>Ubuntu<br><ul><br><li>Linux ubuntu 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</li><br></ul><br></li><br></ul><br><p>Tools used:</p><br><ul><br><li>gcc<br><ul><br><li>gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4</li><br></ul><br></li><br><li>glibc 2.19 (see <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break/version.c" target="_blank" rel="external">version.c</a> if you need to check your glibc version)</li><br><li>strace<br><ul><br><li>strace — version 4.8</li><br></ul><br></li><br></ul><br><p><strong>Everything we will write will be true for this system/environment, but may be different on another system</strong></p><br><p>We will also go through the Linux source code. If you are on Ubuntu, you can download the sources of your current kernel by running this command:</p><br><pre><code>apt-get source linux-image-$(uname -r)<br></code></pre><br><h2><code>malloc</code></h2><br><p><code>malloc</code> is the common function used to dynamically allocate memory. This memory is allocated on the “heap”.<br><br><em>Note: <code>malloc</code> is not a system call.</em></p><br><p>From <code>man malloc</code>:</p><br><pre><code>[…] allocate dynamic memory[…]<br>void <em>malloc(size_t size);<br>[…]<br>The malloc() function allocates size bytes and returns a pointer to the allocated memory.<br></em></code></pre><br><h3>No malloc, no [heap]</h3><br><p>Let’s look at memory regions of a process that does not call <code>malloc</code> (<code>0-main.c</code>).</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <stdio.h>;<br><br>/**
  main - do nothing<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br><br></em></stdio.h></stdlib.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 0-main.c -o 0<br>julien@holberton:~/holberton/w/hackthevm3$ ./0<br><br></code></pre><br><p><em>Quick reminder (1/3): the memory regions of a process are listed in the <code>/proc/[pid]/maps</code> file. As a result, we first need to know the PID of the process. That is done using the <code>ps</code> command; the second column of <code>ps aux</code> output will give us the PID of the process. Please read <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">chapter 0</a> to learn more.</em></p><br><pre><code>julien@holberton:/tmp$ ps aux | grep \ ./0$<br>julien     3638  0.0  0.0   4200   648 pts/9    S+   12:01   0:00 ./0<br></code></pre><br><p><em>Quick reminder (2/3): from the above output, we can see that the PID of the process we want to look at is <code>3638</code>. As a result, the <code>maps</code> file will be found in the directory <code>/proc/3638</code>.</em></p><br><pre><code>julien@holberton:/tmp$ cd /proc/3638<br></code></pre><br><p><em>Quick reminder (3/3): The <code>maps</code> file contains the memory regions of the process. The format of each line in this file is:<br><br>address           perms offset  dev   inode       pathname</em></p><br><pre><code>julien@holberton:/proc/3638$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00600000-00601000 r–p 00000000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>00601000-00602000 rw-p 00001000 08:01 174583                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/0<br>7f38f87d7000-7f38f8991000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8991000-7f38f8b91000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b91000-7f38f8b95000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b95000-7f38f8b97000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f38f8b97000-7f38f8b9c000 rw-p 00000000 00:00 0<br>7f38f8b9c000-7f38f8bbf000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8da3000-7f38f8da6000 rw-p 00000000 00:00 0<br>7f38f8dbb000-7f38f8dbe000 rw-p 00000000 00:00 0<br>7f38f8dbe000-7f38f8dbf000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dbf000-7f38f8dc0000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f38f8dc0000-7f38f8dc1000 rw-p 00000000 00:00 0<br>7ffdd85c5000-7ffdd85e6000 rw-p 00000000 00:00 0                          [stack]<br>7ffdd85f2000-7ffdd85f4000 r–p 00000000 00:00 0                          [vvar]<br>7ffdd85f4000-7ffdd85f6000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/3638$<br></code></pre><br><p><em>Note: <code>hackthevm3</code> is a symbolic link to <code>hack_the_virtual_memory/03. The Heap/</code></em></p><br><p>-&gt;; As we can see from the above maps file, there’s no [heap] region allocated.</p><br><h3><code>malloc(x)</code></h3><br><p>Let’s do the same but with a program that calls <code>malloc</code> (<code>1-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - 1 call to malloc<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    malloc(1);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 1-main.c -o 1<br>julien@holberton:~/holberton/w/hackthevm3$ ./1<br><br></code></pre><br><pre><code>julien@holberton:/proc/3638$ ps aux | grep \ ./1$<br>julien     3718  0.0  0.0   4332   660 pts/9    S+   12:09   0:00 ./1<br>julien@holberton:/proc/3638$ cd /proc/3718<br>julien@holberton:/proc/3718$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00600000-00601000 r–p 00000000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>00601000-00602000 rw-p 00001000 08:01 176964                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/1<br>01195000-011b6000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3718$<br></code></pre><br><p>-&gt;; the [heap] is here.</p><br><p>Let’s check the return value of <code>malloc</code> to make sure the returned address is in the heap region (<code>2-main.c</code>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br><br>/**
  main - prints the malloc returned address<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br><br>    p = malloc(1);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 2-main.c -o 2<br>julien@holberton:~/holberton/w/hackthevm3$ ./2<br>0x24d6010<br><br></code></pre><br><pre><code>julien@holberton:/proc/3718$ ps aux | grep \ ./2$<br>julien     3834  0.0  0.0   4336   676 pts/9    S+   12:48   0:00 ./2<br>julien@holberton:/proc/3718$ cd /proc/3834<br>julien@holberton:/proc/3834$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00600000-00601000 r–p 00000000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>00601000-00602000 rw-p 00001000 08:01 176966                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/2<br>024d6000-024f7000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/3834$<br></code></pre><br><p>-&gt;; <code>024d6000</code> &lt;<code>0x24d6010</code> &lt; <code>024f7000</code></p><br><p>The returned address is inside the heap region. And as we have seen in the <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">previous chapter</a>, the returned address does not start exactly at the beginning of the region; we’ll see why later.</p><br><h2><code>strace</code>, <code>brk</code> and <code>sbrk</code></h2><br><p><code>malloc</code> is a “regular” function (as opposed to a system call), so it must call some kind of syscall in order to manipulate the heap. Let’s use <code>strace</code> to find out.</p><br><p><code>strace</code> is a program used to trace system calls and signals. Any program will always use a few syscalls before your <code>main</code> function is executed. In order to know which syscalls are used by <code>malloc</code>, we will add a <code>write</code> syscall before and after the call to <code>malloc</code>(<code>3-main.c</code>).</p><br><pre><code>#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> main - let’s find out which syscall malloc is using
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC\n”, 14);<br>    p = malloc(1);<br>    write(1, “AFTER MALLOC\n”, 13);<br>    printf(“%p\n”, p);<br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></strong></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 3-main.c -o 3<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./3<br>execve(“./3”, [“./3”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC\n”, 14BEFORE MALLOC<br>)         = 14<br>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br>write(1, “AFTER MALLOC\n”, 13AFTER MALLOC<br>)          = 13<br>…<br>read(0,<br></em></code></pre><br><p>From the above listing we can focus on this:</p><br><pre><code>brk(0)                                  = 0xe70000<br>brk(0xe91000)                           = 0xe91000<br></code></pre><br><p>-&gt;; <code>malloc</code> is using the <code>brk</code> system call in order to manipulate the heap. From <code>brk</code> man page (<code>man brk</code>), we can see what this system call is doing:</p><br><pre><code>…<br>       int brk(void addr);<br>       void *sbrk(intptr_t increment);<br>…<br>DESCRIPTION<br>       brk() and sbrk() change the location of the program  break,  which  defines<br>       the end of the process’s data segment (i.e., the program break is the first<br>       location after the end of the uninitialized data segment).  Increasing  the<br>       program  break has the effect of allocating memory to the process; decreas‐<br>       ing the break deallocates memory.<br><br>       brk() sets the end of the data segment to the value specified by addr, when<br>       that  value  is  reasonable,  the system has enough memory, and the process<br>       does not exceed its maximum data size (see setrlimit(2)).<br><br>       sbrk() increments the program’s data space  by  increment  bytes.   Calling<br>       sbrk()  with  an increment of 0 can be used to find the current location of<br>       the program break.<br></code></pre><br><p>The program break is the address of the first location beyond the current end of the data region of the program in the virual memory.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-before.png" alt="program break before the call to malloc / brk" scale="0"></p><br><p>By increasing the value of the program break, via <code>brk</code> or <code>sbrk</code>, the function <code>malloc</code> creates a new space that can then be used by the process to dynamically allocate memory (using <code>malloc</code>).</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/program-break-after.png" alt="program break after the malloc / brk call" scale="0"></p><br><p>So the heap is actually an extension of the data segment of the program.</p><br><p>The first call to <code>brk</code> (<code>brk(0)</code>) returns the current address of the program break to <code>malloc</code>. And the second call is the one that actually creates new memory (since <code>0xe91000</code> &gt;; <code>0xe70000</code>) by increasing the value of the program break. In the above example, the heap is now starting at <code>0xe70000</code> and ends at <code>0xe91000</code>. Let’s double check with the <code>/proc/[PID]/maps</code> file:</p><br><pre><code>julien@holberton:/proc/3855$ ps aux | grep \ ./3$<br>julien     4011  0.0  0.0   4748   708 pts/9    S+   13:04   0:00 strace ./3<br>julien     4014  0.0  0.0   4336   644 pts/9    S+   13:04   0:00 ./3<br>julien@holberton:/proc/3855$ cd /proc/4014<br>julien@holberton:/proc/4014$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00600000-00601000 r–p 00000000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00601000-00602000 rw-p 00001000 08:01 176967                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3<br>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/4014$<br></code></pre><br><p>-&gt;; <code>00e70000-00e91000 rw-p 00000000 00:00 0                                  [heap]</code> matches the pointers returned back to <code>malloc</code> by <code>brk</code>.</p><br><p>That’s great, but wait, why did<code>malloc</code> increment the heap by <code>00e91000</code> – <code>00e70000</code> = <code>0x21000</code> or <code>135168</code> bytes, when we only asked for only 1 byte?</p><br><h2>Many mallocs</h2><br><p>What will happen if we call <code>malloc</code> several times? (<code>4-main.c</code>)</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<br> <em> main - many calls to malloc
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br><br>    write(1, “BEFORE MALLOC #0\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #0\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #1\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #1\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #2\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #2\n”, 16);<br>    printf(“%p\n”, p);<br><br>    write(1, “BEFORE MALLOC #3\n”, 17);<br>    p = malloc(1024);<br>    write(1, “AFTER MALLOC #3\n”, 16);<br>    printf(“%p\n”, p);<br><br>    getchar();<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 4-main.c -o 4<br>julien@holberton:~/holberton/w/hackthevm3$ strace ./4<br>execve(“./4”, [“./4”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “BEFORE MALLOC #0\n”, 17BEFORE MALLOC #0<br>)      = 17<br>brk(0)                                  = 0x1314000<br>brk(0x1335000)                          = 0x1335000<br>write(1, “AFTER MALLOC #0\n”, 16AFTER MALLOC #0<br>)       = 16<br>…<br>write(1, “0x1314010\n”, 100x1314010<br>)             = 10<br>write(1, “BEFORE MALLOC #1\n”, 17BEFORE MALLOC #1<br>)      = 17<br>write(1, “AFTER MALLOC #1\n”, 16AFTER MALLOC #1<br>)       = 16<br>write(1, “0x1314420\n”, 100x1314420<br>)             = 10<br>write(1, “BEFORE MALLOC #2\n”, 17BEFORE MALLOC #2<br>)      = 17<br>write(1, “AFTER MALLOC #2\n”, 16AFTER MALLOC #2<br>)       = 16<br>write(1, “0x1314830\n”, 100x1314830<br>)             = 10<br>write(1, “BEFORE MALLOC #3\n”, 17BEFORE MALLOC #3<br>)      = 17<br>write(1, “AFTER MALLOC #3\n”, 16AFTER MALLOC #3<br>)       = 16<br>write(1, “0x1314c40\n”, 100x1314c40<br>)             = 10<br>…<br>read(0,<br></em></code></pre><br><p>-&gt;; <code>malloc</code> is NOT calling <code>brk</code> each time we call it.</p><br><p>The first time, <code>malloc</code> creates a new space (the heap) for the program (by increasing the program break location). The following times, <code>malloc</code> uses the same space to give our program “new” chunks of memory. Those “new” chunks of memory are part of the memory previously allocated using <code>brk</code>. This way, <code>malloc</code> doesn’t have to use syscalls (<code>brk</code>) every time we call it, and thus it makes <code>malloc</code> – and our programs using <code>malloc</code> – faster. It also allows <code>malloc</code> and <code>free</code> to optimize the usage of the memory.</p><br><p>Let’s double check that we have only one heap, allocated by the first call to <code>brk</code>:</p><br><pre><code>julien@holberton:/proc/4014$ ps aux | grep \ ./4$<br>julien     4169  0.0  0.0   4748   688 pts/9    S+   13:33   0:00 strace ./4<br>julien     4172  0.0  0.0   4336   656 pts/9    S+   13:33   0:00 ./4<br>julien@holberton:/proc/4014$ cd /proc/4172<br>julien@holberton:/proc/4172$ cat maps<br>00400000-00401000 r-xp 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00600000-00601000 r–p 00000000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>00601000-00602000 rw-p 00001000 08:01 176973                             /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4<br>01314000-01335000 rw-p 00000000 00:00 0                                  [heap]<br>7f4a3f2c4000-7f4a3f47e000 r-xp 00000000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f47e000-7f4a3f67e000 —p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f67e000-7f4a3f682000 r–p 001ba000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f682000-7f4a3f684000 rw-p 001be000 08:01 136253                     /lib/x86_64-linux-gnu/libc-2.19.so<br>7f4a3f684000-7f4a3f689000 rw-p 00000000 00:00 0<br>7f4a3f689000-7f4a3f6ac000 r-xp 00000000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f890000-7f4a3f893000 rw-p 00000000 00:00 0<br>7f4a3f8a7000-7f4a3f8ab000 rw-p 00000000 00:00 0<br>7f4a3f8ab000-7f4a3f8ac000 r–p 00022000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ac000-7f4a3f8ad000 rw-p 00023000 08:01 136229                     /lib/x86_64-linux-gnu/ld-2.19.so<br>7f4a3f8ad000-7f4a3f8ae000 rw-p 00000000 00:00 0<br>7ffd1ba73000-7ffd1ba94000 rw-p 00000000 00:00 0                          [stack]<br>7ffd1bbed000-7ffd1bbef000 r–p 00000000 00:00 0                          [vvar]<br>7ffd1bbef000-7ffd1bbf1000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br>julien@holberton:/proc/4172$<br></code></pre><br><p>-&gt;; We have only one [heap] and the addresses match those returned by <code>sbrk</code>: <code>0x1314000</code> &amp; <code>0x1335000</code></p><br><h2>Naive malloc</h2><br><p>Based on the above, and assuming we won’t ever need to free anything, we can now write our own (naive) version of <code>malloc</code>, that would move the program break each time it is called.</p><br><pre><code class="C">#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  malloc - naive version of malloc: dynamically allocates memory on the heap using sbrk<br> <em> @size: number of bytes to allocate                                                          
 </em><br> <em> Return: the memory address newly allocated, or NULL on error                                
 </em><br> <em> Note: don’t do this at home :)                                                              
 </em>/<br>void <em>malloc(size_t size)<br>{<br>    void </em>previous_break;<br><br>    previous_break = sbrk(size);<br>    /<em> check for error </em>/<br>    if (previous_break == (void <em>) -1)<br>    {<br>        /</em> on error malloc returns NULL <em>/<br>        return (NULL);<br>    }<br>    return (previous_break);<br>}<br></em></unistd.h></stdlib.h></code></pre><br><h2>The 0x10 lost bytes</h2><br><p>If we look at the output of the previous program (<code>4-main.c</code>), we can see that the first memory address returned by <code>malloc</code> doesn’t start at the beginning of the heap, but <code>0x10</code> bytes after: <code>0x1314010</code> vs <code>0x1314000</code>. Also, when we call <code>malloc(1024)</code> a second time, the address should be <code>0x1314010</code> (the returned value of the first call to <code>malloc</code>) + <code>1024</code> (or <code>0x400</code> in hexadecimal, since the first call to <code>malloc</code> was asking for <code>1024</code> bytes) = <code>0x1318010</code>. But the return value of the second call to <code>malloc</code> is <code>0x1314420</code>. We have lost <code>0x10</code> bytes again! Same goes for the subsequent calls.</p><br><p>Let’s look at what we can find inside those “lost” <code>0x10</code>-byte memory spaces (<code>5-main.c</code>) and whether the memory loss stays constant:</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/**                                                                                            
  pmem - print mem<br> <em> @p: memory address to start printing from                                                   
 </em> @bytes: number of bytes to print<br> <em>                                                                                             
 </em> Return: nothing<br> <em>/<br>void pmem(void </em>p, unsigned int bytes)<br>{<br>    unsigned char <em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char </em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, <em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/**
 </em> main - the 0x10 lost bytes<br> <em>
 </em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS<br> <em>/<br>int main(void)<br>{<br>    void </em>p;<br>    int i;<br><br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1));<br>        printf(“%p\n”, p);<br>        printf(“bytes at %p:\n”, (void </em>)((char <em>)p - 0x10));<br>        pmem((char </em>)p - 0x10, 0x10);<br>    }<br>    return (EXIT_SUCCESS);<br>}<br></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 5-main.c -o 5<br>julien@holberton:~/holberton/w/hackthevm3$ ./5<br>0x1fa8010<br>bytes at 0x1fa8000:<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x1fa8420<br>bytes at 0x1fa8410:<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x1fa8c30<br>bytes at 0x1fa8c20:<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x1fa9840<br>bytes at 0x1fa9830:<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x1faa850<br>bytes at 0x1faa840:<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x1fabc60<br>bytes at 0x1fabc50:<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x1fad470<br>bytes at 0x1fad460:<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x1faf080<br>bytes at 0x1faf070:<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x1fb1090<br>bytes at 0x1fb1080:<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x1fb34a0<br>bytes at 0x1fb3490:<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>There is one clear pattern: the size of the malloc’ed memory chunk is always found in the preceding 0x10 bytes. For instance, the first <code>malloc</code> call is malloc’ing <code>1024</code> (<code>0x0400</code>) bytes and we can find <code>11 04 00 00 00 00 00 00</code> in the preceding <code>0x10</code> bytes. Those last bytes represent the number <code>0x 00 00 00 00 00 00 04 11</code> = <code>0x400</code> (1024) + <code>0x10</code> (the block size preceding those <code>1024</code> bytes + <code>1</code> (we’ll talk about this “+1” later in this chapter). If we look at each <code>0x10</code> bytes preceding the addresses returned by <code>malloc</code>, they all contain the size of the chunk of memory asked to <code>malloc</code> + <code>0x10</code> + <code>1</code>.</p><br><p>At this point, given what we said and saw earlier, we can probably guess that those 0x10 bytes are a sort of data structure used by <code>malloc</code> (and <code>free</code>) to deal with the heap. And indeed, even though we don’t understand everything yet, we can already use this data structure to go from one malloc’ed chunk of memory to the other (<code>6-main.c</code>) as long as we have the address of the beginning of the heap (<em>and as long as we have never called <code>free</code></em>):</p><br><pre><code class="C">#include <stdio.h>;<br>#include <stdlib.h>;<br>#include <unistd.h>;<br><br>/<strong><br> <em> pmem - print mem                                                                            
 </em> @p: memory address to start printing from<br> <em> @bytes: number of bytes to print                                                            
 </em><br> <em> Return: nothing                                                                             
 </em>/<br>void pmem(void <em>p, unsigned int bytes)<br>{<br>    unsigned char </em>ptr;<br>    unsigned int i;<br><br>    ptr = (unsigned char <em>)p;<br>    for (i = 0; i &lt; bytes; i++)<br>    {<br>        if (i != 0)<br>        {<br>            printf(“ “);<br>        }<br>        printf(“%02x”, </em>(ptr + i));<br>    }<br>    printf(“\n”);<br>}<br><br>/</strong><br> <em> main - using the 0x10 bytes to jump to next malloc’ed chunks
 </em><br> <em> Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS
 </em>/<br>int main(void)<br>{<br>    void <em>p;<br>    int i;<br>    void </em>heap_start;<br>    size_t size_of_the_block;<br><br>    heap_start = sbrk(0);<br>    write(1, “START\n”, 6);<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        p = malloc(1024 <em> (i + 1)); 
        </em>((int <em>)p) = i;<br>        printf(“%p: [%i]\n”, p, i);<br>    }<br>    p = heap_start;<br>    for (i = 0; i &lt; 10; i++)<br>    {<br>        pmem(p, 0x10);<br>        size_of_the_block = </em>((size_t <em>)((char </em>)p + 8)) - 1;<br>        printf(“%p: [%i] - size = %lu\n”,<br>              (void <em>)((char </em>)p + 0x10),<br>              <em>((int </em>)((char <em>)p + 0x10)),<br>              size_of_the_block);<br>        p = (void </em>)((char <em>)p + size_of_the_block);<br>    }<br>    write(1, “END\n”, 4);<br>    return (EXIT_SUCCESS);<br>}<br></em></unistd.h></stdlib.h></stdio.h></code></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 6-main.c -o 6<br>julien@holberton:~/holberton/w/hackthevm3$ ./6<br>START<br>0x9e6010: [0]<br>0x9e6420: [1]<br>0x9e6c30: [2]<br>0x9e7840: [3]<br>0x9e8850: [4]<br>0x9e9c60: [5]<br>0x9eb470: [6]<br>0x9ed080: [7]<br>0x9ef090: [8]<br>0x9f14a0: [9]<br>00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>0x9e6010: [0] - size = 1040<br>00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>0x9e6420: [1] - size = 2064<br>00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>0x9e6c30: [2] - size = 3088<br>00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>0x9e7840: [3] - size = 4112<br>00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00<br>0x9e8850: [4] - size = 5136<br>00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>0x9e9c60: [5] - size = 6160<br>00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>0x9eb470: [6] - size = 7184<br>00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>0x9ed080: [7] - size = 8208<br>00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00<br>0x9ef090: [8] - size = 9232<br>00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>0x9f14a0: [9] - size = 10256<br>END<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>One of our open questions from the previous chapter is now answered: <code>malloc</code> is using <code>0x10</code> additional bytes for each malloc’ed memory block to store the size of the block.</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/0x10-malloc.png" alt="0x10 bytes preceeding malloc" scale="0"></p><br><p>This data will actually be used by <code>free</code> to save it to a list of available blocks for future calls to <code>malloc</code>.</p><br><p>But our study also raises a new question: what are the first 8 bytes of the 16 (<code>0x10</code> in hexadecimal) bytes used for? It seems to always be zero. Is it just padding?</p><br><h3>RTFSC</h3><br><p>At this stage, we probably want to check the source code of <code>malloc</code> to confirm what we just found (<code>malloc.c</code> from the glibc).</p><br><pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">1055 /*</div><div class="line">1056       malloc_chunk details:</div><div class="line">1057    </div><div class="line">1058        (The following includes lightly edited explanations by Colin Plumb.)</div><div class="line">1059    </div><div class="line">1060        Chunks of memory are maintained using a `boundary tag&apos; method as</div><div class="line">1061        described in e.g., Knuth or Standish.  (See the paper by Paul</div><div class="line">1062        Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</div><div class="line">1063        survey of such techniques.)  Sizes of free chunks are stored both</div><div class="line">1064        in the front of each chunk and at the end.  This makes</div><div class="line">1065        consolidating fragmented chunks into bigger chunks very fast.  The</div><div class="line">1066        size fields also hold bits representing whether chunks are free or</div><div class="line">1067        in use.</div><div class="line">1068    </div><div class="line">1069        An allocated chunk looks like this:</div><div class="line">1070    </div><div class="line">1071    </div><div class="line">1072        chunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1073                |             Size of previous chunk, if unallocated (P clear)  |</div><div class="line">1074                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1075                |             Size of chunk, in bytes                     |A|M|P|</div><div class="line">1076          mem-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1077                |             User data starts here...                          .</div><div class="line">1078                .                                                               .</div><div class="line">1079                .             (malloc_usable_size() bytes)                      .</div><div class="line">1080                .                                                               |</div><div class="line">1081    nextchunk-&gt;; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1082                |             (size of chunk, but used for application data)    |</div><div class="line">1083                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1084                |             Size of next chunk, in bytes                |A|0|1|</div><div class="line">1085                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line">1086    </div><div class="line">1087        Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</div><div class="line">1088        the malloc code, but &quot;mem&quot; is the pointer that is returned to the</div><div class="line">1089        user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</div><div class="line">```&lt;/pre&gt;</div><div class="line">&lt;p&gt;-&gt;; We were correct \o/. Right before the address returned by &lt;code&gt;malloc&lt;/code&gt; to the user, we have two variables:&lt;/p&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">&lt;li&gt;Size of previous chunk, if unallocated: we never free’d any chunks so that is why it was always 0&lt;/li&gt;</div><div class="line">&lt;li&gt;Size of chunk, in bytes&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;p&gt;Let’s free some chunks to confirm that the first 8 bytes are used the way the source code describes it (&lt;code&gt;7-main.c&lt;/code&gt;):&lt;/p&gt;</div><div class="line">&lt;pre&gt;</div><div class="line">```C</div><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - confirm the source code</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">        printf(&quot;%p\n&quot;, p);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8)) - 1;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk, size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></pre><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 7-main.c -o 7<br>julien@holberton:~/holberton/w/hackthevm3$ ./7<br>0x1536010<br>0x1536420<br>0x1536c30<br>0x1537840<br>0x1538850<br>0x1539c60<br>0x153b470<br>0x153d080<br>0x153f090<br>0x15414a0<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1536000, size = 1040, prev = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1536410, size = 2064, prev = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1536c20, size = 3088, prev = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1537830, size = 4112, prev = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1538840, size = 5135, prev = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1539c50, size = 6160, prev = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x153b460, size = 7184, prev = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x153d070, size = 8208, prev = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x153f080, size = 9231, prev = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x1541490, size = 10256, prev = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>As we can see from the above listing, when the previous chunk has been free’d, the malloc chunk’s first 8 bytes contain the size of the previous unallocated chunk. So the correct representation of a malloc chunk is the following:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/malloc-chunk.png" alt="malloc chunk" scale="0"></p><br><p>Also, it seems that the first bit of the next 8 bytes (containing the size of the current chunk) serves as a flag to check if the previous chunk is used (<code>1</code>) or not (<code>0</code>). So the correct updated version of our program should be written this way (<code>8-main.c</code>):</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - updating with correct checks</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    int i;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    size_t size_of_the_previous_chunk;</div><div class="line">    void *chunks[10];</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = malloc(1024 * (i + 1));</div><div class="line">        chunks[i] = (void *)((char *)p - 0x10);</div><div class="line">    &#125;</div><div class="line">    free((char *)(chunks[3]) + 0x10);</div><div class="line">    free((char *)(chunks[7]) + 0x10);</div><div class="line">    for (i = 0; i &lt; 10; i++)</div><div class="line">    &#123;</div><div class="line">        p = chunks[i];</div><div class="line">        printf(&quot;chunks[%d]: &quot;, i);</div><div class="line">        pmem(p, 0x10);</div><div class="line">        size_of_the_chunk = *((size_t *)((char *)p + 8));</div><div class="line">        prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">        size_of_the_chunk -= prev_used;</div><div class="line">        size_of_the_previous_chunk = *((size_t *)((char *)p));</div><div class="line">        printf(&quot;chunks[%d]: %p, size = %li, prev (%s) = %li\n&quot;,</div><div class="line">              i, p, size_of_the_chunk,</div><div class="line">              (prev_used? &quot;allocated&quot;: &quot;unallocated&quot;), size_of_the_previous_chunk);</div><div class="line">    &#125;</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 8-main.c -o 8<br>julien@holberton:~/holberton/w/hackthevm3$ ./8<br>chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00<br>chunks[0]: 0x1031000, size = 1040, prev (allocated) = 0<br>chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00<br>chunks[1]: 0x1031410, size = 2064, prev (allocated) = 0<br>chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00<br>chunks[2]: 0x1031c20, size = 3088, prev (allocated) = 0<br>chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00<br>chunks[3]: 0x1032830, size = 4112, prev (allocated) = 0<br>chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00<br>chunks[4]: 0x1033840, size = 5136, prev (unallocated) = 4112<br>chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00<br>chunks[5]: 0x1034c50, size = 6160, prev (allocated) = 0<br>chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00<br>chunks[6]: 0x1036460, size = 7184, prev (allocated) = 0<br>chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00<br>chunks[7]: 0x1038070, size = 8208, prev (allocated) = 0<br>chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00<br>chunks[8]: 0x103a080, size = 9232, prev (unallocated) = 8208<br>chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00<br>chunks[9]: 0x103c490, size = 10256, prev (allocated) = 0<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><h2>Is the heap actually growing upwards?</h2><br><p>The last question left unanswered is: “Is the heap actually growing upwards?”. From the <code>brk</code> man page, it seems so:</p><br><pre><code>DESCRIPTION<br>       brk() and sbrk() change the location of the program break, which defines the end  of  the<br>       process’s  data  segment  (i.e., the program break is the first location after the end of<br>       the uninitialized data segment).  Increasing the program break has the effect of allocat‐<br>       ing memory to the process; decreasing the break deallocates memory.<br></code></pre><br><p>Let’s check! (<code>9-main.c</code>)</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    write(1, &quot;START\n&quot;, 6);</div><div class="line">    malloc(1);</div><div class="line">    getchar();</div><div class="line">    write(1, &quot;LOOP\n&quot;, 5);</div><div class="line">    for (i = 0; i &lt; 0x25000 / 1024; i++)</div><div class="line">    &#123;</div><div class="line">        malloc(1024);</div><div class="line">    &#125;</div><div class="line">    write(1, &quot;END\n&quot;, 4);</div><div class="line">    getchar();</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>Now let’s confirm this assumption with strace:</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ strace ./9<br>execve(“./9”, [“./9”], [/ 61 vars <em>/]) = 0<br>…<br>write(1, “START\n”, 6START<br>)                  = 6<br>brk(0)                                  = 0x1fd8000<br>brk(0x1ff9000)                          = 0x1ff9000<br>…<br>write(1, “LOOP\n”, 5LOOP<br>)                   = 5<br>brk(0x201a000)                          = 0x201a000<br>write(1, “END\n”, 4END<br>)                    = 4<br>…<br>julien@holberton:~/holberton/w/hackthevm3$<br></em></code></pre><br><p>clearly, <code>malloc</code> made only two calls to <code>brk</code> to increase the allocated space on the heap. And the second call is using a higher memory address argument (<code>0x201a000</code> &gt;; <code>0x1ff9000</code>). The second syscall was triggered when the space on the heap was too small to host all the malloc calls.</p><br><p>Let’s double check with <code>/proc</code>.</p><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 9-main.c -o 9<br>julien@holberton:~/holberton/w/hackthevm3$ ./9<br>START<br><br></code></pre><br><pre><code>julien@holberton:/proc/7855$ ps aux | grep \ ./9$<br>julien     7972  0.0  0.0   4332   684 pts/9    S+   19:08   0:00 ./9<br>julien@holberton:/proc/7855$ cd /proc/7972<br>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00922000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>Let’s hit Enter and look at the [heap] again:</p><br><pre><code>LOOP<br>END<br><br></code></pre><br><pre><code>julien@holberton:/proc/7972$ cat maps<br>…<br>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]<br>…<br>julien@holberton:/proc/7972$<br></code></pre><br><p>-&gt;; <code>00901000-00943000 rw-p 00000000 00:00 0                                  [heap]</code><br><br>The beginning of the heap is still the same, but the size has increased upwards from <code>00922000</code> to <code>00943000</code>.</p><br><h2>The Address Space Layout Randomisation (ASLR)</h2><br><p>You may have noticed something “strange” in the <code>/proc/pid/maps</code> listing above, that we want to study:</p><br><p>The program break is the address of the first location beyond the current end of the data region – so the address of the first location beyond the executable in the virtual memory. As a consequence, the heap should start right after the end of the executable in memory. As you can see in all above listing, it is NOT the case. The only thing that is true is that the heap is always the next memory region after the executable, which makes sense since the heap is actually part of the data segment of the executable itself. Also, if we look even closer, the memory gap size between the executable and the heap is never the same:</p><br><p><em>Format of the following lines: [PID of the above <code>maps</code> listings]: address of the beginning of the [heap] – address of the end of the executable = memory gap size</em></p><br><ul><br><li>[3718]: 01195000 – 00602000 = b93000</li><br><li>[3834]: 024d6000 – 00602000 = 1ed4000</li><br><li>[4014]: 00e70000 – 00602000 = 86e000</li><br><li>[4172]: 01314000 – 00602000 = d12000</li><br><li>[7972]: 00901000 – 00602000 = 2ff000</li><br></ul><br><p>It seems that this gap size is random, and indeed, it is. If we look at the ELF binary loader source code (<code>fs/binfmt_elf.c</code>) we can find this:</p><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">if</span> ((current-&gt;;flags &amp;amp; PF_RANDOMIZE) &amp;amp;&amp;amp; (randomize_va_space &gt;; <span class="number">1</span>)) &#123;</div><div class="line">                current-&gt;;mm-&gt;;brk = current-&gt;;mm-&gt;;start_brk =</div><div class="line">                        arch_randomize_brk(current-&gt;;mm);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> compat_brk_randomized</span></div><div class="line">                current-&gt;;brk_randomized = <span class="number">1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div></pre></td></tr></table></figure><br><br><p>where <code>current-&gt;;mm-&gt;;brk</code> is the address of the program break. The <code>arch_randomize_brk</code> function can be found in the <code>arch/x86/kernel/process.c</code> file:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_randomize_brk</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> range_end = mm-&gt;;brk + <span class="number">0x02000000</span>;</div><div class="line">        <span class="keyword">return</span> randomize_range(mm-&gt;;brk, range_end, <span class="number">0</span>) ? : mm-&gt;;brk;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><p>The <code>randomize_range</code> returns a start address such that:</p><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  [...... &lt;range&gt;; .....]</div><div class="line">start                  end</div></pre></td></tr></table></figure><br><br><p>Source code of the <code>randomize_range</code> function (<code>drivers/char/random.c</code>):</p><br><pre><code class="C">/<br> <em> randomize_range() returns a start address such that
 </em><br> <em>    […… <range>; …..]
 </range></em>  start                  end<br> <em>
 </em> a <range>; with size “len” starting at the return value is inside in the<br> <em> area defined by [start, end], but is otherwise randomized.
 </em>/<br>unsigned long<br>randomize_range(unsigned long start, unsigned long end, unsigned long len)<br>{<br>        unsigned long range = end - len - start;<br><br>        if (end &lt;= start + len)<br>                return 0;<br>        return PAGE_ALIGN(get_random_int() % range + start);<br>}<br></range></code></pre><br><p>As a result, the offset between the data section of the executable and the program break initial position when the process runs can have a size of anywhere between <code>0</code> and <code>0x02000000</code>. This randomization is known as Address Space Layout Randomisation (ASLR). ASLR is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities. In order to prevent an attacker from jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the positions of the heap and the stack.</p><br><h2>The updated VM diagram</h2><br><p>With all the above in mind, we can now update our VM diagram:</p><br><p><img src="https://s3-us-west-1.amazonaws.com/holbertonschool/medias/virtual_memory_diagram_v2.png" alt="Virtual memory diagram" scale="0"></p><br><h2><code>malloc(0)</code></h2><br><p>Did you ever wonder what was happening when we call <code>malloc</code> with a size of <code>0</code>? Let’s check! (<code>10-main.c</code>)</p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;;</div><div class="line">#include &lt;stdlib.h&gt;;</div><div class="line">#include &lt;unistd.h&gt;;</div><div class="line"></div><div class="line">/**                                                                                            </div><div class="line"> * pmem - print mem                                                                            </div><div class="line"> * @p: memory address to start printing from                                                   </div><div class="line"> * @bytes: number of bytes to print                                                            </div><div class="line"> *                                                                                             </div><div class="line"> * Return: nothing                                                                             </div><div class="line"> */</div><div class="line">void pmem(void *p, unsigned int bytes)</div><div class="line">&#123;</div><div class="line">    unsigned char *ptr;</div><div class="line">    unsigned int i;</div><div class="line"></div><div class="line">    ptr = (unsigned char *)p;</div><div class="line">    for (i = 0; i &lt; bytes; i++)</div><div class="line">    &#123;</div><div class="line">        if (i != 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%02x&quot;, *(ptr + i));</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * main - moving the program break</div><div class="line"> *</div><div class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</div><div class="line"> */</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *p;</div><div class="line">    size_t size_of_the_chunk;</div><div class="line">    char prev_used;</div><div class="line"></div><div class="line">    p = malloc(0);</div><div class="line">    printf(&quot;%p\n&quot;, p);</div><div class="line">    pmem((char *)p - 0x10, 0x10);</div><div class="line">    size_of_the_chunk = *((size_t *)((char *)p - 8));</div><div class="line">    prev_used = size_of_the_chunk &amp;amp; 1;</div><div class="line">    size_of_the_chunk -= prev_used;</div><div class="line">    printf(&quot;chunk size = %li bytes\n&quot;, size_of_the_chunk);</div><div class="line">    return (EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><pre><code>julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 10-main.c -o 10<br>julien@holberton:~/holberton/w/hackthevm3$ ./10<br>0xd08010<br>00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00<br>chunk size = 32 bytes<br>julien@holberton:~/holberton/w/hackthevm3$<br></code></pre><br><p>-&gt;; <code>malloc(0)</code> is actually using 32 bytes, including the first <code>0x10</code> bytes.</p><br><p>Again, note that this will not always be the case. From the man page (<code>man malloc</code>):</p><br><pre><code>NULL may also be returned by a successful call to malloc() with a size of zero<br></code></pre><br><h2>Outro</h2><br><p>We have learned a couple of things about malloc and the heap. But there is actually more than <code>brk</code> and <code>sbrk</code>. You can try malloc’ing a big chunk of memory, <code>strace</code> it, and look at <code>/proc</code> to learn more before we cover it in a next chapter <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><p>Also, studying how <code>free</code> works in coordination with <code>malloc</code> is something we haven’t covered yet. If you want to look at it, you will find part of the answer to why the minimum chunk size is <code>32</code> (when we ask <code>malloc</code> for <code>0</code> bytes) vs <code>16</code> (<code>0x10</code> in hexadecimal) or <code>0</code>.</p><br><p>As usual, to be continued! Let me know if you have something you would like me to cover in the next chapter.</p><br><h3>Questions? Feedback?</h3><br><p>If you have questions or feedback don’t hesitate to ping us on Twitter at <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a>.<br><br><em>Haters, please send your comments to <code>/dev/null</code>.</em></p><br><p>Happy Hacking!</p><br><h3>Thank you for reading!</h3><br><p>As always, no-one is perfect (except <a href="http://codesqueeze.com/the-ultimate-top-25-chuck-norris-the-programmer-jokes/" target="_blank" rel="external">Chuck</a> of course), so don’t hesitate to <a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/blob/master/03.%20malloc,%20the%20heap%20and%20the%20program%20break/" target="_blank" rel="external">contribute</a> or send me your comments if you find anything I missed.</p><br><h3>Files</h3><br><p><a href="https://github.com/holbertonschool/Hack-The-Virtual-Memory/tree/master/03.%20malloc%2C%20the%20heap%20and%20the%20program%20break" target="_blank" rel="external">This repo</a> contains the source code (<code>naive_malloc.c</code>, <code>version.c</code> &amp; “X-main.c` files) for programs created in this tutorial.</p><br><h3>Read more about the virtual memory</h3><br><p>Follow <a href="https://twitter.com/holbertonschool" target="_blank" rel="external">@holbertonschool</a> or <a href="https://twitter.com/julienbarbier42" target="_blank" rel="external">@julienbarbier42</a> on Twitter to get the next chapters!</p><br><ul><br><li>Chapter 0: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="external">Hack The Virtual Memory: C strings &amp; /proc</a></li><br><li>Chapter 1: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-python-bytes/" target="_blank" rel="external">Hack The Virtual Memory: Python bytes</a></li><br><li>Chapter 2: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="external">Hack The Virtual Memory: Drawing the VM diagram</a></li><br><li>Chapter 3: <a href="https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank" rel="external">Hack the Virtual Memory: malloc, the heap &amp; the program break</a></li><br></ul><br><p><em>Many thanks to <a href="https://twitter.com/wintermanc3r" target="_blank" rel="external">Tim</a>, <a href="https://twitter.com/1million40" target="_blank" rel="external">Anne</a> and <a href="https://www.linkedin.com/in/iancugniere/" target="_blank" rel="external">Ian</a> for proof-reading!</em> <img draggable="false" class="emoji" alt="🙂" src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" scale="0"></p><br><!-- Simple Share Buttons Adder (6.3.4) simplesharebuttons.com --><div class="ssba ssba-wrap"><div style="text-align:left">Sharing is caring<a data-site="reddit" class="ssba_reddit_share" href="http://reddit.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack the Virtual Memory: malloc, the heap &amp; the program break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/reddit.png" title="Reddit" class="ssba ssba-img" alt="Share on Reddit"></a><a data-site="" class="ssba_twitter_share" href="http://twitter.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;text=Hack+the+Virtual+Memory%3A+malloc%2C+the+heap+%26+the+program+break+" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/twitter.png" title="Twitter" class="ssba ssba-img" alt="Tweet about this on Twitter"></a><a data-site="" class="ssba_facebook_share" href="http://www.facebook.com/sharer.php?u=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/facebook.png" title="Facebook" class="ssba ssba-img" alt="Share on Facebook"></a><a data-site="" class="ssba_google_share" href="https://plus.google.com/share?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/google.png" title="Google+" class="ssba ssba-img" alt="Share on Google+"></a><a data-site="linkedin" class="ssba_linkedin_share ssba_share_link" href="http://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/linkedin.png" title="LinkedIn" class="ssba ssba-img" alt="Share on LinkedIn"></a><a data-site="digg" class="ssba_diggit_share ssba_share_link" href="http://www.digg.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/diggit.png" title="Digg" class="ssba ssba-img" alt="Digg this"></a><a data-site="stumbleupon" class="ssba_stumbleupon_share ssba_share_link" href="http://www.stumbleupon.com/submit?url=https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/&amp;title=Hack%20the%20Virtual%20Memory:%20malloc,%20the%20heap%20&amp;%20the%20program%20break" target="_blank"><img src="https://blog.holbertonschool.com/wp-content/plugins/simple-share-buttons-adder/buttons/somacro/stumbleupon.png" title="StumbleUpon" class="ssba ssba-img" alt="Share on StumbleUpon"></a></div></div><br>        <div class="clearfix"></div>

<pre><code>&lt;/div&gt;
</code></pre></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/20/malloc/" data-id="cj81bptif000x2gq6q734jez3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理-虚拟内存/">内存管理  虚拟内存</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入理解Linux中内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/深入理解Linux中内存管理/" class="article-date">
  <time datetime="2017-09-13T07:20:08.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/深入理解Linux中内存管理/">深入理解Linux中内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><p>平常只是知道一些进程虚拟地址空间的一些概念，并没有深入去理解Linux是如何管理内存了，刚好有时间就研究了下这块的原由。</p>
<p><span style="color: red"><strong>主题:</strong></span>Linux内存管理中的分段和分页技术</p>
<p>回顾一下历史，<span style="color: #0000ff;"><strong>在早期的计算机中，程序是直接运行在物理内存上的。</strong></span>换句话说，就是程序在运行的过程中访问的都是物理地址。</p>
<p>如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。</p>
<p>然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为<span style="color: red">内存管理</span>。</p>
<p>举一个早期的计算机系统中，内存分配管理的例子，以便于理解。</p>
<p>假如我们有三个程序，<span style="color: #993366;"><strong>程序A，B，C，程序A运行的过程中需要<span style="color: #ff6600;">10M</span>内存，程序B运行的过程中需要<span style="color: #ff6600;">100M</span>内存，而程序C运行的过程中需要<span style="color: #ff6600;">20M</span>内存。</strong></span></p>
<p>如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A，接下来的10M-110M分配给B。</p>
<p>这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。</p>
<p>大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。</p>
<p>下面来看看这种内存管理方式存在的几个比较明显的问题。</p>
<h3 id="进程地址空间不能隔离"><a href="#进程地址空间不能隔离" class="headerlink" title="进程地址空间不能隔离"></a>进程地址空间不能隔离</h3><p>由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。</p>
<p>举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以访问系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举地破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。</p>
<h3 id="内存使用的效率低"><a href="#内存使用的效率低" class="headerlink" title="内存使用的效率低　"></a>内存使用的效率低　</h3><p>如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。</p>
<p>这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道<span style="color: #ff6600;"><strong>IO操作比较耗时</strong></span>，所以这个过程效率将会十分低下。</p>
<h3 id="程序运行的地址不能确定"><a href="#程序运行的地址不能确定" class="headerlink" title="程序运行的地址不能确定"></a>程序运行的地址不能确定</h3><p>程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址，如果有不明白童鞋可以去查查编译原理方面的资料。</p>
<p><span style="color: #0000ff;"><strong>　　</strong><strong>内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？</strong></span></p>
<p>引用计算机界一句无从考证的名言：<span style="color: #993366;"><strong>计算机系统里的任何问题都可以靠引入一个中间层来解决</strong></span></p>
<p>现在的内存管理方法就是在程序和物理内存之间引入了<span style="color:red">虚拟内存</span>这个概念。</p>
<p><ol></ol></p>
<p><li><span style="color: #008080;"><strong>虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。</strong></span></li></p>
<p><li>每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。</li></p>
<p><li>顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。</li><br><br>既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。</p>
<h2 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h2><p>这种方法是人们最开始使用的一种方法，基本思路是<span style="color: #ff0000;"><strong>将程序所需要的内存地址空间大小的虚拟空间映射到某个物理地址空间。</strong></span></p>
<p><img src="memory_segmentation.jpg"></p>
<p><span style="color: #993366;"><strong>每个程序都有其独立的虚拟的独立的进程地址空间</strong></span>可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。</p>
<p>这种<span style="color: #ff6600;"><strong>分段的机制解决了开始提到的3个问题中的进程地址空间隔离和程序地址重定位的问题。</strong></span></p>
<p>程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。</p>
<p>无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。　　　</p>
<p>因为<span style="color: #008080;"><strong>这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。</strong></span></p>
<p>那么，怎么才算高效率的内存使用呢。事实上，<span style="color: #993366;"><strong>根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。</strong></span></p>
<p>所以我们需要更加小粒度的内存分割和映射方法，此时是否会想到Linux中的Buddy算法和slab内存分配机制呢。另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。</p>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p><span style="color: #0000ff;"><strong>分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。</strong></span></p>
<p>试想一下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999字节是不是浪费了。所以需要更加细粒度的磁盘分割方式，我们可以将Block设置得小一点，这当然是根据所存放文件的大小来综合考虑的，好像有点跑题了，我只是想说，内存中的分页机制跟ext文件系统中的磁盘分割机制非常相似。</p>
<p><span style="color: #993366;"><strong>Linux中一般页的大小是4KB</strong></span>我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，我们还是以一个例子来说明,如下图：</p>
<p><img src="memory_page.jpg"></p>
<p>可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行)，甚至他们共用了一部分物理地址空间，这就是<span stlye="color:red">共享内存</span>。</p>
<p>进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个<span style="color: #0000ff;"><strong>缺页异常</strong></span>，然后异常管理程序会将其读到内存中。</p>
<p>这就是<span style="color: #ff0000;"><strong>分页机制的原理</strong></span>，当然Linux中的分页机制的实现还是比较复杂的，通过了页全局目录，页上级目录，页中级目录，页表等几级的分页机制来实现的，但是基本的工作原理是不会变的。</p>
<p>分页机制的实现需要硬件的实现，这个硬件名字叫做<span style="color: #993366;"><strong>MMU</strong></span>(Memory Management Unit)，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。</p>
<p><a href="http://www.cnblogs.com/lcw/p/3505503.html" target="_blank" rel="external">参考</a><br><a href="http://blog.csdn.net/ky_heart/article/details/51865526" target="_blank" rel="external">重定位</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/13/深入理解Linux中内存管理/" data-id="cj81bptie000u2gq6hwm4bnzu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理-分页/">内存管理 分页</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-如何构建一个go项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/12/如何构建一个go项目/" class="article-date">
  <time datetime="2017-09-12T07:44:43.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/如何构建一个go项目/">如何构建一个go项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这里我会介绍开发一个简单的Go包以及对<code>go tool</code>的使用。最标准的方法是先拉取，编译再安装Go包然后再到命令行运行。</p>
<p><code>go tool</code>需要你按特定的方式组织你的代码.接下来请仔细阅读.</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li>Go程序通常把所有的Go代码放在单一的工作空间</li>
<li>工作空间包含各种版本控制的库(如:git管理的库)</li>
<li>每一个库包含一个或多个包</li>
<li>每一个包由单个目录下面的一个或多个go文件组成</li>
<li>包的路径决定了它导入的路径</li>
</ul>
<p>注意要和其它Go程序区分开来，每个Go的项目都有自己的工作空间并且工作空间是和版本控制库是紧密联系在一起的。</p>
<h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>一个工作空间是包含有三子目录的目录:</p>
<ul>
<li>src包信Go的源文析</li>
<li>pkg包含仓库生成对应的包</li>
<li>bin包含我们生成Go的可执行程序</li>
</ul>
<p><code>go tool</code>编译所有的包并安装二进制文件到<code>pkg</code>和<code>bin</code>目录<br><code>src</code>子目录通常包含多个版本控制的库,这里面包含一个或多个包</p>
<p>一个工作空间看来是是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                          # command executable</div><div class="line">    outyet                         # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a           # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	hello/</div><div class="line">	    hello.go               # command source</div><div class="line">	outyet/</div><div class="line">	    main.go                # command source</div><div class="line">	    main_test.go           # test source</div><div class="line">	stringutil/</div><div class="line">	    reverse.go             # package source</div><div class="line">	    reverse_test.go        # test source</div><div class="line">    golang.org/x/image/</div><div class="line">        .git/                      # Git repository metadata</div><div class="line">	bmp/</div><div class="line">	    reader.go              # package source</div><div class="line">	    writer.go              # package source</div><div class="line">    ... (many more repositories and packages omitted) ...</div></pre></td></tr></table></figure></p>
<p>上面的结构包含两个库(example和image).example库包含两个可执行程序和一个库。image仓库包含bmp包和一些其它的。</p>
<p>一个典型的工作空间是包含多个仓库源，每个仓库包含多个包或可执行程序。大部分Go程序保持所有Go源码和依赖放在同一个工作空间。</p>
<p>可执行程序和程序所需要的库是从不同的包里生成的。我们稍后会讨论他们的区别。</p>
<h3 id="GOPATH环境变量"><a href="#GOPATH环境变量" class="headerlink" title="GOPATH环境变量"></a>GOPATH环境变量</h3><p>GOPATH环境变量指定了工作空间的位置.linux默认是<code>~/go</code>,windows下面是<code>C:\Users\YourName\go</code>。</p>
<p>如果你喜欢在不同的位置工作，你需要设置下GOPATH指向你想要的那个目录(另一个常见的设置是<code>GOPATH=$HOME</code>)，注意GOPATH不要和Go安装的目录相同。</p>
<p><code>go env GOPATH</code>输出当前生效的GOPATH,如果没有设置会输出默认的值。</p>
<p>为了方便把工作目录的<code>bin</code>子目录设置加入到系统PATH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$export PATH=$PATH:$(go env GOPATH)/bin</div></pre></td></tr></table></figure>
<h3 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h3><p>一个导入路径是标识唯一个包的一串字符。一个包导入路径对应它在工作空间里面的目录或是一个远程仓库。</p>
<p>标准库的包导入路径非常短,比如:”fmt”、”net/http”.对于自己的包来说，你必须选择将来加入一些标准库或其它外部库不太可能会产生冲突的基础路径。</p>
<p>如果你把代码放在某个开源仓库，你应该仓库的根目录做为你的基础路径。比如:你的github帐号是<code>github.com/user</code>，这应该是你的基础路径。</p>
<p>注意在你可以编译之前最好不要发布你的代码到远程仓库。这是一个好的习惯来组织你的代码如果你在将来某一天发布。事实上你可以选择其它任意的目录名称，只要它对标准库和Go生态生成的路径唯一就好。</p>
<p>接下来我们会用<code>github.com/user</code>做为我们的基础路径。在你的工作空间创建一个目录来放你的源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$mkdir -p $GOPATH/src/github.com/user</div></pre></td></tr></table></figure></p>
<h3 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h3><p>编译和运行一个程序首先需要选择一个包路径(我们用github.com/user/hello)然后在你的工作空间创建相应的包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/hello</div></pre></td></tr></table></figure>
<p>接下来我们在目录下面创建一个叫<code>hello.go</code>的文件,文件内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Hello, world.\n"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在你可以用<code>go tool</code>编译然后安装这个程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go install github.com/user/hello</div></pre></td></tr></table></figure>
<p>注意你可以在你电脑的任何地方运行这个命令。<code>go tool</code>会在你的<code>GOPATH</code>查找<code>github.com/user/hello</code>对应的包。</p>
<p>如果你在包的目录下面运行<code>go install</code>话，你可以忽略包的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/github.com/user/hello</div><div class="line">$ go install</div></pre></td></tr></table></figure>
<p>这个命令编译hello生成一个可执行文件。然后安装这个二进制文件到工作空间的bin目录下，生成的名字是hello(windows下是hello.exe)。在我们的例子会在$GOPATH/bin/hello,也就是$HOME/go/bin/hello.</p>
<p><code>go tool</code>只会在有错误的情况下输出，如果没有任何输出说明是执行成功。</p>
<p>现在你可以在命令行输入绝对路径来运行你的程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ $GOPATH/bin/hello</div></pre></td></tr></table></figure></p>
<p>或者你已经把$GOPATH/bin加入到系统PATH了，你只需要输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, world.</div></pre></td></tr></table></figure></p>
<p>如果你正在用一个版本控制系统，那么现在是初始化一个仓库的最佳时机，新增这些文件，然后提交你第一次变更。再强调一次，这一步是可选的:你不需要用源代码控制系统来写Go代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cd $GOPATH/src/github.com/user/hello</div><div class="line">$ git init</div><div class="line">Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/</div><div class="line">$ git add hello.go</div><div class="line">$ git commit -m &quot;initial commit&quot;</div><div class="line">[master (root-commit) 0b4507d] initial commit</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line">  create mode 100644 hello.go</div></pre></td></tr></table></figure>
<h3 id="第一个库"><a href="#第一个库" class="headerlink" title="第一个库"></a>第一个库</h3><p>让我们写一个库并在hello程序里面使用这个库</p>
<p>再说下，第一步创建包路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir $GOPATH/src/github.com/user/stringutil</div></pre></td></tr></table></figure>
<p>接下来在目录下创建一个reverse.go的文件，内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></div><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	r := []<span class="keyword">rune</span>(s)</div><div class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</div><div class="line">		r[i], r[j] = r[j], r[i]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们用<code>go build</code>来编译这个包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build github.com/user/stringutil</div></pre></td></tr></table></figure></p>
<p>或进入目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go build</div></pre></td></tr></table></figure></p>
<p>这个不会产生文件。为了这样做，你必须用go install把这个包放到你工作空间的pkg目录。</p>
<p>在你确实stringutil包编译成功后，修改你原先的hello.go代码:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/user/stringutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行我们的程序，结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hello</div><div class="line">Hello, Go!</div></pre></td></tr></table></figure></p>
<p>经过上面的步骤后，我们的工作空间如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                 # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/          # this will reflect your OS and architecture</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a  # package object</div><div class="line">src/</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go      # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go    # package source</div></pre></td></tr></table></figure></p>
<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>在Go的源码里面第一条语句必需是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">package name</div></pre></td></tr></table></figure>
<p>name是包默认的名字用来导入。(一个包里所有的文件必须用同一个name)</p>
<p>Go的转换规则是把导入路径最后一个元素做为包名的:如果”crypto/rot13”导入的话name应该命名为rot13.</p>
<p>可执行的命令必须用package main.</p>
<p>在链接到一个二进制文件的时候不要求所有包里的名称都唯一，但是导入的路径必须唯一。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go有一个轻微测试框，由<code>go test</code>命令和testing包组成。</p>
<p>新建一个以_test.go结尾的文件名来做为测试，文件里面包含类TestXXX(t *testing.T)的函数。测试框架会运行每一个这样的函数;如果函数用T.Error或t.Fail调用失败，这个测试是被认为失败了。</p>
<p>到stringutil包里新增一个测试文件($GOPATH/src/github.com/user/stringutil/reverse_test.go),内容如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> stringutil</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	cases := []<span class="keyword">struct</span> &#123;</div><div class="line">		in, want <span class="keyword">string</span></div><div class="line">	&#125;&#123;</div><div class="line">		&#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</div><div class="line">		&#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</div><div class="line">		got := Reverse(c.in)</div><div class="line">		<span class="keyword">if</span> got != c.want &#123;</div><div class="line">			t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行这个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test github.com/user/stringutil</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<p>同样的，可以在包里面运行这个测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go test</div><div class="line">ok  	github.com/user/stringutil 0.165s</div></pre></td></tr></table></figure></p>
<h2 id="远程包"><a href="#远程包" class="headerlink" title="远程包"></a>远程包</h2><p>包的导入描述了是怎样通过版本控制系统获取包的源码的(如:git或Mercurial).<code>go tool</code>利用这个特性从远程仓库获取这个包。例如,在这个文章里面example是放在Github上面的(github.com/golang/example)。如果你在包的导入路径添加了这个地址，<code>go get</code>将会自动拉取、编译和安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/golang/example/hello</div><div class="line">$ $GOPATH/bin/hello</div><div class="line">Hello, Go examples!</div></pre></td></tr></table></figure>
<p>如果指定的包不存在当前的工作空间，<code>go get</code>将会把包放到由<code>GOPATH</code>指定的工作空间里面。(如果这个包已经在工作空间中存在,<code>go get</code>跳过从远程的拉取和安装)</p>
<p>执行上面<code>go get</code>命令后，现在的工作空间目录结构是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bin/</div><div class="line">    hello                           # command executable</div><div class="line">pkg/</div><div class="line">    linux_amd64/</div><div class="line">        github.com/golang/example/</div><div class="line">            stringutil.a            # package object</div><div class="line">        github.com/user/</div><div class="line">            stringutil.a            # package object</div><div class="line">src/</div><div class="line">    github.com/golang/example/</div><div class="line">	.git/                       # Git repository metadata</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div><div class="line">    github.com/user/</div><div class="line">        hello/</div><div class="line">            hello.go                # command source</div><div class="line">        stringutil/</div><div class="line">            reverse.go              # package source</div><div class="line">            reverse_test.go         # test source</div></pre></td></tr></table></figure></p>
<p>托管在Gihub上的<code>hello</code>程序和它依赖<code>stringutil</code>包在同一个仓库。在<code>hello.go</code>文件里用相同的导入路径转换，所以<code>go get</code>命令找到和安装依赖包到对应的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;github.com/golang/example/stringutil&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>英语很渣的一个翻译<br><a href="https://golang.org/doc/code.html" target="_blank" rel="external">参考</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/12/如何构建一个go项目/" data-id="cj81bptic000q2gq6vl3bowd6" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GOPATH/">GOPATH</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-go-solutions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/11/go-solutions/" class="article-date">
  <time datetime="2017-09-11T01:56:22.000Z" itemprop="datePublished">2017-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/golang/">golang</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/11/go-solutions/">golang开发中遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>在用golang编写服务器程序的时候，遇到下面一些问题，所以在这里做一些记录，尤其是<code>slice</code>隐藏的bug较隐性，若对<code>slice</code>工作原理不了解是较难发现的。</p>
<ul>
<li>slice元素被莫名替换</li>
<li>index out of range问题</li>
<li>空指针引用</li>
<li>map的并发读写导致进程挂掉</li>
<li>String方法导致的递归死循环</li>
<li>通道多次close(close of closed channel)</li>
<li>死锁</li>
<li>下次gc内存回收条件</li>
<li>定时任务的问题</li>
</ul>
<h3 id="slice元素被替换"><a href="#slice元素被替换" class="headerlink" title="slice元素被替换"></a>slice元素被替换</h3><blockquote>
<p>slice在开发中运用较频繁的基础数据类型,和数组相似，与数组最大的区别在于他是系统自动扩容的。</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</div><div class="line">	array unsafe.Pointer</div><div class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></div><div class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是<code>go runtime</code>里面对slice实现数据结构，指向一块内存的一个指针、一个当前slice里面的长度以及当前slice里面的最大容量。可以预想下<br>若另外一个指针同之前slice的指针有内存重叠的话，修改重叠部分是会相互影响的，下面我们用实例来确定下这个问题。</p>
<p><strong>test1.go</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</div><div class="line"></div><div class="line">sb := sa</div><div class="line">sb = <span class="built_in">append</span>(sb, <span class="number">5</span>) <span class="comment">// sb = append(sa, 5) 同样有问题</span></div><div class="line"></div><div class="line"><span class="comment">// 从小到大排序</span></div><div class="line">algorithm.Sort(sb, <span class="number">0</span>, <span class="built_in">len</span>(sb)<span class="number">-1</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 5 cap: 8 of slice sa: [1 2 3 4 5]</span></div><div class="line"><span class="comment">// len: 6 cap: 8 of slice sb: [1 2 3 4 5 6]</span></div></pre></td></tr></table></figure></p>
<p><strong>test2.go</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">sb := sa</div><div class="line">sb = <span class="built_in">append</span>(sb, <span class="number">9</span>)</div><div class="line"></div><div class="line"><span class="comment">// 从小到大排序</span></div><div class="line">algorithm.Sort(sb, <span class="number">0</span>, <span class="built_in">len</span>(sb)<span class="number">-1</span>)</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 8 cap: 8 of slice sa: [1 2 3 4 5 7 8 10]</span></div><div class="line"><span class="comment">// len: 9 cap: 16 of slice sb: [1 2 3 4 5 7 8 9 10]</span></div></pre></td></tr></table></figure></p>
<p>上面两个程序的输出可能看出，<code>test1.go</code>中对sb排完序后sa和sb第5个元素是被替换掉了的。<br>实际上sa和sb是两个指向同块内存的不同指针，只是它们的len值不一样,需要注意的是sb调用<br>append后cap的值还是和sa的一样。和<code>test2.go</code>形成鲜明的对比，只要slice的长度超过了默<br>认的容量后就会自动扩容。</p>
<p><strong>sb:=sa之后的代码写在函数里面同样有这样的问题，因为go里面传参都是按值传递的</strong></p>
<h3 id="index-out-of-range"><a href="#index-out-of-range" class="headerlink" title="index out of range"></a>index out of range</h3><ul>
<li>索引slice元素越界</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sa := []<span class="keyword">byte</span>&#123;&#125;</div><div class="line">sa = <span class="built_in">append</span>(sa, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)</div><div class="line"><span class="comment">// sa[5] = 20 // 这里会panic</span></div><div class="line"></div><div class="line">sb := sa[<span class="number">5</span>:]</div><div class="line"><span class="comment">// sb[0] = 5  // 这里会panic</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sa: %v\n"</span>, <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa), sa)</div><div class="line">fmt.Printf(<span class="string">"len: %d cap: %d of slice sb: %v\n"</span>, <span class="built_in">len</span>(sb), <span class="built_in">cap</span>(sb), sb)</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// len: 5 cap: 8 of slice sa: [1 2 3 4 6]</span></div><div class="line"><span class="comment">// len: 0 cap: 3 of slice sb: []</span></div></pre></td></tr></table></figure>
<p>对于这种下标越界的问题是当索引的下标号超出了<code>len(sa)</code>的时候就抛出越界的错误</p>
<ul>
<li>slice表达式越界问题</li>
</ul>
<blockquote>
<p>根据官方文档的说明slice表达式有两个，一种简单的表达式和参数更全的表达式<br>分别对应<code>a[low : high]</code>和<code>a[low : high : max]</code></p>
</blockquote>
<p><a href="https://golang.org/ref/spec#Slice_expressions" target="_blank" rel="external">spec说明</a><br>对于这类越界是下标不在<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>这范围时会出现问题</p>
<h3 id="空指针引用"><a href="#空指针引用" class="headerlink" title="空指针引用"></a>空指针引用</h3><p>相信不论是C系还是JAVA开发者都会遇到空指针的问题，C里面对空地址的访问是致命的，<br>并且不像JAVA能把这种异常捕获，go也不例外，为了保证服务正常运行同样可以通过<br>recover把所有runtime时的错捕获到，但并发读写的错误是不行的。所以我们项目里基本<br>在所有的协程里面有recover输出的。</p>
<p>项目中我们把一个自定义的interface的变量赋值一个<code>nil</code>，但去执行原先持有的类型的<br>函数时就panic掉了，所以对默认值为空值引用的都会出这种错误，比如:空指针和接口</p>
<p><strong>有趣的例子:</strong><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</div><div class="line">	Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stu)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"s is %v"</span>, s) <span class="comment">// 这里能正常调用,但不要再去调Stu里面的成员</span></div><div class="line">	<span class="keyword">return</span> <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> s *Stu</div><div class="line">	s.GetName()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子一开始出乎意料，但仔细一想其实是符合go的设计理念的，方法是属于类型的，<br>类型的变量当然是可以正常调用的，但变量为空再去调用里面的成员就是对空指针的访问了。</p>
<h3 id="map的并发读写导致进程挂掉"><a href="#map的并发读写导致进程挂掉" class="headerlink" title="map的并发读写导致进程挂掉"></a>map的并发读写导致进程挂掉</h3><p>对一个多线程程序来说对数据竞争的保护是必不可少的，但在处理日志输出的时候，如果<br>一个对象有map或数组之类的并对有并发读写这很容易导致进程panic掉。所以打印日志的<br>时候一定要注意不要输出一个对象。</p>
<h3 id="String方法导致的递归死循环"><a href="#String方法导致的递归死循环" class="headerlink" title="String方法导致的递归死循环"></a>String方法导致的递归死循环</h3><p>在日志输出的时候打印了一个对象并且对象实现了String()方法，如果String方法里面<br>又调了自身，这种使用方法是很危险的，在我们开发期间是有同事犯了这个一个错误的。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>既然是并发程序，难免会有数据竞争的问题，所以我们用了互斥锁来解决这个问题，<br>如果获取锁和释放锁没有成对使用或者是锁重入(递归获取锁)就会导致死锁的风险，<br>因为我们项目是针对房间的，虽然不影响所有的人，一出现死锁只会影响这个房间<br>的人，不过我们这种锁是睡眠锁,并不消耗CPU。</p>
<blockquote>
<p>我们的产品是一款地方麻将,用golang开发的</p>
</blockquote>
<p><strong>死锁1:</strong></p>
<p>我们的产品上线第二天就出现导致全服(多个逻辑服)服务不可用。后来经过排查是有死锁影响了全局。</p>
<p>一开始并不知道问题在哪，有以下两个解决方案:</p>
<ul>
<li>新增高版本的逻辑服(不影响新的玩家)</li>
<li>停服维护</li>
</ul>
<p>一开始我们选择的是一方案，但好像出了点问题，又换了二方案，二方案虽然可以但是已经开的房间的钻石没返还。<br>弄了好久才弄程序把需要返还钻石返还。</p>
<p>不过好在上线前有人说要开放pprof接口,经过日志分析是有很多goroutine阻塞在获取锁的地方。<br>上线前我们做了一个需求，10分钟没开局的房间需要解散掉。也没考虑太多，觉得这个需求比较<br>简单，所以逻辑服这边起了个定时任务1分钟扫下单个逻辑服的房间列表。</p>
<p>定时任务我们是用的读锁来执行的，从列表里面删除一个房间的是写锁的。读锁是可以多次获取的。<br>假如1分钟还没遍历完所有的房间，另外一个定时任务立即执行，又重新获取房间列表的读锁。1分<br>钟遍历的时候是有获取房间的锁的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">R*是获取房间里面的锁</div><div class="line">RA ——&gt; roomA</div><div class="line">RB ——&gt; roomB</div><div class="line">    再尝试获取房间列表写锁的:</div><div class="line">    RA ——&gt; list</div><div class="line">    RB ——&gt; list</div><div class="line"></div><div class="line">T*是定时任务得到房间列表的读锁:</div><div class="line">T1  ——&gt; list</div><div class="line">T2  ——&gt; list</div><div class="line">T3  ——&gt; list</div><div class="line">	再获取房间里面的锁</div><div class="line">	TA ——&gt; roomA</div><div class="line">	TB ——&gt; roomB</div></pre></td></tr></table></figure>
<p><strong>定时任务是有获取房间的锁的,如果刚好TA的锁等着RA的锁就会产生死锁</strong></p>
<p>后续我们的解决方案是为每一个房间启一个定时。能不用锁解决的问题千万不要不用，获取锁是会导致上下文的切换，<br>从一执行线程切换到另一个执行线程。</p>
<p>golang的<code>channel</code>就是通过锁来实现不同的协程之间可以通信。虽然用到了锁，但是这个锁对开发人员是无感的，所<br>以对使用者来说就安全了。</p>
<p><strong>死锁2:</strong></p>
<p>这个问题是异常情况下面导致的单个房间的死锁，当时写代码的时候能不用defer就不用，所以在一个加锁的函数的<br>地方没有用defer解锁，在函数执行当中有panic，所以没执行后面解锁的函数。如果用了defer解锁就不会有这个问<br>题了。所以在有锁的情况尽量用defer就用defer。</p>
<h3 id="下次gc内存回收条件"><a href="#下次gc内存回收条件" class="headerlink" title="下次gc内存回收条件"></a>下次gc内存回收条件</h3><p>线上因为通过<code>pprof</code>看到<code>heap</code>一直在增长，一天增长了一千多。用top观察实际res也增了几十兆的物理内存。<br>因此网上找了很多关于linux内存管理以及golang的pprof里面的heap各字段详细描述。</p>
<p>(MemStats)[<a href="https://golang.org/pkg/runtime/#MemStats" target="_blank" rel="external">https://golang.org/pkg/runtime/#MemStats</a>]</p>
<p>通过线上实际表现，内存是一直往上增的情况，所以看了下哪里可能有内存没被回收掉，以及GC的回收机制。</p>
<p>一开始自己有以下疑问:</p>
<ul>
<li>有垃圾回收的语言不是会自动回收的吗?</li>
<li>有回收的话哪些对象没被回收掉？</li>
</ul>
<p>一开始对代码大概的看了一下，除了其它一些频繁make的切片(也就十几个byte)的长度，这些部分是由他底层内存分配<br>管理器来控制的，我是束手无从的，不过也对一些频繁用到的对像用了内置的pool对象池。所以从其它地方想下还有哪<br>些地方没被回收掉，后来想到定时器！定时器确实也是有泄漏的(有些没有Stop掉)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export GODEBUG=GOGC=50,GCTRACE=1</div><div class="line">./main</div></pre></td></tr></table></figure>
<p>默认GOGC是100的，所以gc会在下次分配的内存和上次分配的内存的比是成倍的才会把内存回收掉，设置成50后<br>通过压测试后通过日志输出会发现回收的次数相对来说要频繁，所以内存没有出现大的增长，停下来的时候恢复<br>平稳的值，但设置成50的时候会偶发的卡顿。线上估计也只能设置成80左右吧！暂时这个值没放到线上去跑。</p>
<p><a href="https://golang.org/pkg/runtime/#GC" target="_blank" rel="external">参数说明</a></p>
<h3 id="定时任务的问题"><a href="#定时任务的问题" class="headerlink" title="定时任务的问题"></a>定时任务的问题</h3><p><strong>参考:</strong><br><a href="https://guidao.github.io/go_timer.html" target="_blank" rel="external">实现说明</a></p>
<p>go里面使用定时器有以下几种方式:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</div><div class="line">	t := &amp;Timer&#123;</div><div class="line">		C: c,</div><div class="line">		r: runtimeTimer&#123;</div><div class="line">			when: when(d),</div><div class="line">			f:    sendTime,</div><div class="line">			arg:  c,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	startTimer(&amp;t.r)</div><div class="line">	<span class="keyword">return</span> t</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">type</span> runtimeTimer <span class="keyword">struct</span> &#123;</div><div class="line">	i      <span class="keyword">int</span></div><div class="line">	when   <span class="keyword">int64</span></div><div class="line">	period <span class="keyword">int64</span></div><div class="line">	f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span> // <span class="title">NOTE</span>: <span class="title">must</span> <span class="title">not</span> <span class="title">be</span> <span class="title">closure</span></span></div><div class="line">	<span class="title">arg</span>    <span class="title">interface</span>&#123;&#125;</div><div class="line">	seq    <span class="keyword">uintptr</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span></span> &#123;</div><div class="line">	t := &amp;Timer&#123;</div><div class="line">		r: runtimeTimer&#123;</div><div class="line">			when: when(d),</div><div class="line">			f:    goFunc,</div><div class="line">			arg:  f,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	startTimer(&amp;t.r)</div><div class="line">	<span class="keyword">return</span> t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">goFunc</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="keyword">uintptr</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> arg.(<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="title">time</span>.<span class="title">NewTicker</span><span class="params">(time.Second)</span></div><div class="line"><span class="title">time</span>.<span class="title">After</span><span class="params">(time.Second)</span></div><div class="line"><span class="title">time</span>.<span class="title">AfterFun</span><span class="params">(time.Second, <span class="keyword">func</span>()</span>&#123;&#125;)</div></pre></td></tr></table></figure>
<p>通过源码以及使用接口总结，主要有两种定时器。1) 执行一次的  2) 定期执行的。通过数据结构<br>我们看了下不同接口实际的区别只在<code>period</code>字段。以及这个<code>f</code>参数用的默认的<code>sendTime</code>是非<br>阻塞的调用，<code>AfterFun</code>和前面两个接口不同的时没通过管道来实现定时器到点了(可以执行我的<br>业务了)，而它是直接用的goFunc包装在自己的协程里面执行</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">1000000</span>; i++ &#123;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-time.Tick(time.Second):</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果像上面的代码用<code>time.Tick()</code>创建的定时器(也就是管道)没<code>Stop()</code>掉，定时器任务<br>列表会一直规程，导致内存一直无法得到释放。尤其是循环条件加大到百万级别的时候就<br>更明显了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/11/go-solutions/" data-id="cj81bpthq00052gq6wtn0jbh9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang-slice-空指针-并发读写/">golang slice 空指针 并发读写</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-about-me" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/11/about-me/" class="article-date">
  <time datetime="2017-09-11T01:22:48.213Z" itemprop="datePublished">2017-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/11/about-me/">关于我</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>很高兴我的博客要和大家见面了，我是coder，一个普通的程序员，今年是第七个年头了。一直希望有个博客，借助这些开源的工具，折腾后终于搭建好了属于自己的博客了!</p>
<p>工作现基本是基于linux后台的开发，c、golang、lua、c++、php都做过项目，现在工作中用lua居多。空闲之余也研究js。</p>
<p>Love what you do,do what you love.</p>
<p>思考，思考，思考!<br>DO,DO,DO!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/11/about-me/" data-id="cj81bpthf00002gq6ffp2k5cz" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-enjoy-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/08/enjoy-hexo/" class="article-date">
  <time datetime="2017-09-08T02:50:37.000Z" itemprop="datePublished">2017-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/08/enjoy-hexo/">enjoy hexo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="搭建博客的过程"><a href="#搭建博客的过程" class="headerlink" title="搭建博客的过程"></a>搭建博客的过程</h4><p>对于没有购买自己域名的个人来说<code>hexo+github</code>是个不错的选择。</p>
<p>安装步骤:</p>
<ul>
<li>安装<code>git</code></li>
<li>安装<code>nodejs</code></li>
<li>在git上创建自己的仓库</li>
<li>用<code>hexo</code>创建博客并生成静态页面，关联自己的仓库，再<code>hexo deploy</code>基本就好了</li>
</ul>
<h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><ul>
<li><a href="https://git-for-windows.github.io/" target="_blank" rel="external">git下载</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs下载</a> 选择LTS(Long Term Support)版本就好</li>
<li><code>npm i -g hexo</code>安装hexo</li>
</ul>
<p>npm是nodejs来管理软件库的一个工具，i是安装-g 是全局安装,安装后尽情享受hexo –help的功能吧。<br><a href="https://hexo.io/themes/" target="_blank" rel="external">更换主题地址</a><code>git clone url themes/</code></p>
<h3 id="enjoy"><a href="#enjoy" class="headerlink" title="enjoy"></a>enjoy</h3><p>所有准备工作做好后直接用<code>hexo init name</code>初始化一个博客目录</p>
<ul>
<li><code>hexo new first-post</code>来创建自己的需要写的文章</li>
<li><code>hexo server</code>就可以通过访问<code>localhost:4000</code>博客地址了</li>
</ul>
<p>可以在配置文件里面支持分类、评论和主题等各种参数配置</p>
<p><strong>在配置git上面的仓库的时候用git协议每次更新就不需要输入密码~</strong></p>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>把自己本地的ssh的公钥放到github个人帐号的key下面,没有则用<code>ssh-keygen</code>一直回车生成,<code>cat ~/.ssh/id_rsa.pub</code><br>在配置里面自己github仓库地址</p>
<p><strong>仓库名格式:<code>名称+github.io</code> example:hello.github.io，否则无效</strong></p>
<p>每次有新文章需要发布的时候执行下面命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean   </div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/08/enjoy-hexo/" data-id="cj81bpthz000b2gq6wgihy8bo" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo-nodejs/">hexo nodejs</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/lock/" class="article-date">
  <time datetime="2017-03-14T09:56:08.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/lock/">lock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>os是多任务操作系统,同一个进程下面是可以有多个线程(进程)同时运行的,线程实际也是一个进程,只是对父进程的一个copy,与父进程共享地址空间进程,所以对同一进程共享的资源需要进行同步,同步的方法包括<code>mutex semaphore spinlock 条件变量</code></p>
<p>很多东西如果只停留在概念层面远远是不够的，我们还是要不断的思考下面的实现机制和原理,下面说下同步的东西。</p>
<h4 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> semaphore &#123;</div><div class="line">    <span class="keyword">atomic_t</span> count;</div><div class="line">    <span class="keyword">int</span> sleepers;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> counter; </div><div class="line">&#125; <span class="keyword">atomic_t</span>;</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/03/14/lock/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/lock/" data-id="cj81bpti1000d2gq64l62u9ke" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux-lock-mutex/">linux lock mutex</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux-io" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/linux-io/" class="article-date">
  <time datetime="2017-03-14T03:04:29.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/linux-io/">linux-io</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>少说话，多看代码，多思考，多动手</strong></p>
<p>io操作是一个程序必不可少的部分，io可以是对块设备的读写，文件的读写，基于网络上的io,这里通过内核select和epoll源码比较下这两种io的优劣。平常服务器需要处理客户端多个连接(基于tcp)的io事件。</p>
<p>对io的读写是有阻塞和非阻塞之分的，对于tcp连接上的读写实际是基于它的读写缓存区，如果fd是阻塞的话,对读来说,缓冲区没数据,对写来说，缓冲区不足够装下需要写的数据或已经满了同样会阻塞。下面是一个阻塞和非阻塞读取标准输入的程序。</p>
        
          <p class="article-more-link">
            <a href="/2017/03/14/linux-io/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/linux-io/" data-id="cj81bptht00072gq62ftqrvf4" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io-select-epoll-socket/">io select epoll socket</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c-lua" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/13/c-lua/" class="article-date">
  <time datetime="2017-03-13T01:59:28.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/c-lua/">c和lua交互</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要理解Lua和C++交互，首先要理解Lua堆栈。</p>
<p>简单来说，Lua和C/C++语言通信的主要方法是一个无处不在的虚拟栈。栈的特点是先进后出。</p>
<p>在Lua中，Lua堆栈就是一个struct，<strong>堆栈索引的方式可是是正数也可以是负数，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶。如图：</strong></p>
<p><img src="../../../../images/stack.png" alt=""></p>
        
          <p class="article-more-link">
            <a href="/2017/03/13/c-lua/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/13/c-lua/" data-id="cj81bpthj00012gq6hjdql0gc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-lua/">c lua</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-max-open-file" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/max-open-file/" class="article-date">
  <time datetime="2017-03-08T07:21:28.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux-c/">linux c</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/max-open-file/">最大可打开的文件数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>平常开发项目的时候会遇到进程下打开的最大fd超过默认设置，导致用户不能正常使用服务。<code>linux</code>是基于文件系统的一个操作系统,操作系统最基本的单元就是进程。最大可打开的文件描述符分为系统级别的和进程级别的。</p>
<h5 id="面向全系统的"><a href="#面向全系统的" class="headerlink" title="面向全系统的"></a>面向全系统的</h5><p>虽然操作系统是基于文件系统的，但它对整个系统中所打开的最大fd数目也是有限制的，默认的系统最大的fd在<code>/proc/sys/fs/file-max</code>文件里，记住<code>proc</code>目录只是一个虚拟的，实际控制的值是在<code>/etc/sysctl.conf</code>里可通过以下方式修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysctl.conf #fs.file-max=795165把这个放到文件最后</div><div class="line">sysctl -w fs.file-max=795165</div></pre></td></tr></table></figure>
<p>最后需要执行<code>sysctl -p</code>生效,再到<code>cat /proc/sys/fs/file-max</code>验证已经同步</p>
<p>&lt;! – more –&gt;</p>
<h5 id="面向进程"><a href="#面向进程" class="headerlink" title="面向进程"></a>面向进程</h5><p>我们知道<code>linux</code>系统是一个多用户多进程的多核操作系统,进程是属于具体某一个用户的，通过<code>xshell</code>等工具<code>ulimit</code>看到的东西是对这个用户的一些资源限制，默认的最大fd数是1024,这一般不能满足于我们的需求，所以需要我们手动修改<br>如果默认从终端(shell环境)启动的进程会继承这些参数，修改可以通过以下几种方式:</p>
<ul>
<li><p><code>/etc/profile /etc/bashrc ~/.bash_profile ~/.bashrc</code> 等脚本初始化地方加入<code>ulimit -n value</code></p>
</li>
<li><p><code>vim /etc/security/limits.conf</code> 按里面的说明还以为是对用户所有打开的fd有限制，经过测试并不是，对资源的限制还是针对进程的,只是用户登录shell会读取这个默认的值</p>
</li>
</ul>
<p>ulimit -n value value值不能超过硬链接数 <code>ulimit -Hn</code>可以查看硬链数,最好在<code>/etc/security/limits.conf</code>设置自己想要的值</p>
<p><a href="https://www.cyberciti.biz/faq/linux-increase-the-maximum-number-of-open-files/" target="_blank" rel="external">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/08/max-open-file/" data-id="cj81bpti4000h2gq6c66nbkmx" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux-ulimit-openfile/">linux ulimit openfile</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
     
     
            <a class="github" aria-hidden="true" href="https://github.com/tofindme" target="_blank" title="Github"></a>
    
     
          <a class="weibo" aria-hidden="true"  href="http://weibo.com/u/1924106177" target="_blank" title="微博"></a>
    
     
     
          <a class="email" aria-hidden="true"  href="mailto:849397833@qq.com" target="_blank" title="邮箱"></a>
    
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux-c/">linux c</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器/">容器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开源项目/">开源项目</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/GOPATH/" style="font-size: 10px;">GOPATH</a> <a href="/tags/c-lua/" style="font-size: 10px;">c lua</a> <a href="/tags/c-skynet-linux-lua/" style="font-size: 10px;">c skynet linux lua</a> <a href="/tags/docker-容器/" style="font-size: 10px;">docker 容器</a> <a href="/tags/golang-nsq-消息队列/" style="font-size: 10px;">golang nsq 消息队列</a> <a href="/tags/golang-slice-空指针-并发读写/" style="font-size: 10px;">golang slice 空指针 并发读写</a> <a href="/tags/hexo-nodejs/" style="font-size: 10px;">hexo nodejs</a> <a href="/tags/io-select-epoll-socket/" style="font-size: 10px;">io select epoll socket</a> <a href="/tags/linux-lock-mutex/" style="font-size: 10px;">linux lock mutex</a> <a href="/tags/linux-ulimit-openfile/" style="font-size: 10px;">linux ulimit openfile</a> <a href="/tags/内存管理-虚拟内存/" style="font-size: 10px;">内存管理  虚拟内存</a> <a href="/tags/内存管理-分页/" style="font-size: 10px;">内存管理 分页</a> <a href="/tags/容器-kurbenet-docker/" style="font-size: 10px;">容器 kurbenet docker</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/20/malloc/">malloc</a>
          </li>
        
          <li>
            <a href="/2017/09/13/深入理解Linux中内存管理/">深入理解Linux中内存管理</a>
          </li>
        
          <li>
            <a href="/2017/09/12/如何构建一个go项目/">如何构建一个go项目</a>
          </li>
        
          <li>
            <a href="/2017/09/11/go-solutions/">golang开发中遇到的问题</a>
          </li>
        
          <li>
            <a href="/2017/09/11/about-me/">关于我</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 Oscan&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;8493978933@qq.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
    



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>